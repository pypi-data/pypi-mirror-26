# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pymcell', [dirname(__file__)])
        except ImportError:
            import _pymcell
            return _pymcell
        if fp is not None:
            try:
                _mod = imp.load_module('_pymcell', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pymcell = swig_import_helper()
    del swig_import_helper
else:
    import _pymcell
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


"""pyMCell helper functions.

This defines functions to help pyMCell interface with the user. It
combines calls of the low level swig wrapped c code so that the
resulting python function calls for users using pyMCell are more
intuitive.

"""

import pymcell as m
from typing import List, Dict, Iterable, Any
import json
import logging
from enum import Enum


logging.basicConfig(format='%(message)s', level=logging.DEBUG)


class Orient(Enum):
    up = 1
    down = 2
    mix = 3


odict_sym = {Orient.up: "'", Orient.down: ",", Orient.mix: ";"}
odict_num = {Orient.up: 1, Orient.down: -1, Orient.mix: 0}


class MeshObj(object):
    """ An entire polygon object and its associated surface regions. """
    def __init__(
            self, name: str, vert_list: List, face_list: List) -> None:
        self.name = name
        self.vert_list = vert_list
        self.face_list = face_list
        self.regions = []  # type: List[SurfaceRegion]
        logging.info("Creating mesh object '%s'" % name)

    def __str__(self):
        return self.name


class Species(object):
    """ A type of molecule. """
    def __init__(
            self,
            name: str,
            diffusion_constant: float,
            surface: bool = False) -> None:
        self.name = name
        self.diffusion_constant = diffusion_constant
        self.surface = surface
        vol_surf = "surface" if surface else "volume"
        logging.info("Creating %s species '%s'" % (vol_surf, name))

    def __str__(self):
        return self.name


class Reaction(object):
    """ A reaction involving one or more molecules.
    ex: vm1 -> vm2 + vm3
    - Can be unimolecular or bimolecular.
    - Involves surface and/or volume molecules.
    """
    def __init__(
            self,
            reactants: List[Species],
            products: List[Species],
            rate_constant: float,
            bkwd_rate_constant=None,
            name=None) -> None:
        self.reactants = reactants
        self.products = products
        self.rate_constant = rate_constant
        self.bkwd_rate_constant = bkwd_rate_constant
        self.name = name
        reactant_names = [r[0].name+odict_sym[r[1]] for r in reactants]
        reactants_str = " + ".join(reactant_names)
        if products:
            product_names = [p[0].name+odict_sym[p[1]] for p in products]
            products_str = " + ".join(product_names)
        else:
            products_str = "NULL"
# arrow = "<->" if bkwd_rate_constant else "->"
        if bkwd_rate_constant:
            logging.info("Creating reaction %s <-> %s [%.2E, %.2E]" % (
                reactants_str, products_str, rate_constant, bkwd_rate_constant))
        else:
            logging.info("Creating reaction %s -> %s [%.2E]" % (
                reactants_str, products_str, rate_constant))

    def __str__(self):
        return self.name


class SurfaceRegion(object):
    """ Subsets of a surface.
    Examples of uses: molecules can be released on to these and surface classes
    can be assigned to them.
    """
    def __init__(self, mesh_obj: MeshObj,
                 reg_name: str,
                 surf_reg_face_list: List) -> None:
        self.reg_name = reg_name
        self.full_reg_name = "%s[%s]" % (mesh_obj.name, reg_name)
        self.surf_reg_face_list = surf_reg_face_list
# Relationship is symmetrical. Every region knows its object. Object
# knows its regions.
        self.mesh_obj = mesh_obj
        mesh_obj.regions.append(self)
        logging.info("Creating region '%s'" % self.reg_name)

    def __str__(self):
        return self.reg_name


class Vector3(object):
    """ Just a generic 3d  vector to be used for positions and whatnot. """
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0) -> None:
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        return "({}, {}, {})".format(self.x, self.y, self.z)


class SurfaceClass(object):
    """ These describe how species interact with various surfaces/meshes.
    ex: Species x are absorbed when they hit the front of a surface.
    """
    def __init__(
            self, name: str, sc_type: str, species: Species,
            orient: int = 0) -> None:
        self.name = name
        self.sc_type = sc_type
        self.species = species
        self.orient = orient
        logging.info("Creating surface class '%s'" % name)

    def __str__(self):
        return self.name


class MCellSim(object):
    """ Everything needed to run a pyMCell simulation. """
    def __init__(self, seed: int) -> None:
        self._world = m.mcell_create()
        self._started = False
# the value for _species & _surface_classes is a swig wrapped sym_entry
        self._species = {}  # type: Dict[str, Any]
        self._surface_classes = {}  # type: Dict[str, Any]
# the value for _mesh_objects is a swig wrapped "object"
        self._mesh_objects = {}  # type: Dict[str, Any]
# the value for _mesh_objects is a swig wrapped "region"
        self._regions = {}  # type: Dict[str, Any]
        self._releases = {}  # type: Dict[str, Any]
        self._counts = {}  # type: Dict[str, Any]
        self._iterations = 0
        self._current_iteration = 0
        self._finished = False
        self._output_freq = 10
        self._seed = seed
        m.mcell_set_seed(self._world, seed)
        m.mcell_silence_notifications(self._world)
        m.mcell_init_state(self._world)
# This is the top level instance object. We just call it "Scene" here
# to be consistent with the MDL output from Blender.
        self.scene_name = "Scene"
        self._scene = m.create_instance_object(self._world, self.scene_name)

    def __str__(self):
        return self.scene_name

    def __del__(self):
        self.end_sim()

    def set_output_freq(self, output_freq: int) -> None:
        """ How often do we output reaction data. """
        self._output_freq = output_freq

    def set_time_step(self, dt: float) -> None:
        """ Set time step in seconds. """
        m.mcell_set_time_step(self._world, dt)

    def set_iterations(self, iterations: int) -> None:
        """ Set number of iterations """
        m.mcell_set_iterations(self._world, iterations)
        self._iterations = iterations

# def set_seed(self, seed):
#     self._seed = seed
#     m.mcell_set_seed(self._world, seed)

    def add_reaction(self, rxn: Reaction) -> None:
        """ Add a reaction object. """
        r_spec_list = None
        p_spec_list = None
# import ipdb
# ipdb.set_trace()
        for r, orient in rxn.reactants:
            r_sym = m.create_species(
                self._world, r.name, r.diffusion_constant, r.surface)
            if r.name not in self._species:
                self._species[r.name] = r_sym
            r_spec_list = m.mcell_add_to_species_list(
                r_sym, True, odict_num[orient], r_spec_list)
        for p, orient in rxn.products:
            p_sym = m.create_species(
                self._world, p.name, p.diffusion_constant, p.surface)
            if p.name not in self._species:
                self._species[p.name] = p_sym
            p_spec_list = m.mcell_add_to_species_list(
                p_sym, True, odict_num[orient], p_spec_list)
        m.create_reaction(
            self._world,
            r_spec_list,
            p_spec_list,
            rxn.rate_constant,
            name=rxn.name)

    def add_geometry(self, mesh_obj: MeshObj) -> None:
        """ Add a mesh object. """
        mesh = m.create_polygon_object(
            self._world,
            mesh_obj.vert_list,
            mesh_obj.face_list,
            self._scene,
            mesh_obj.name)
        if mesh_obj.name not in self._mesh_objects:
            self._mesh_objects[mesh_obj.name] = mesh
        for reg in mesh_obj.regions:
            region_swig_obj = m.create_surface_region(
                self._world, mesh, reg.surf_reg_face_list, reg.reg_name)
            full_reg_name = "%s[%s]" % (mesh_obj.name, reg.reg_name)
            if reg.reg_name not in self._regions:
                self._regions[full_reg_name] = region_swig_obj

    def add_viz(self, species: Iterable[Species]) -> None:
        """ Add this to the list of species to be visualized. """
        viz_list = None
        for spec in species:
            viz_list = m.mcell_add_to_species_list(
                self._species[spec.name], False, 0, viz_list)
        m.mcell_create_viz_output(
            self._world, "./viz_data/seed_%04i/Scene" % self._seed, viz_list,
            0, self._iterations, 1)


    def release_into_meshobj(
            self,
            mesh_obj: MeshObj,
            species: Species,
            count: int,
            orient: int = None) -> None:
        """ Release the specified amount of species into an object. """
        rel_name = "%s_%s_rel" % (species.name, mesh_obj.name)

        mol_sym = self._species[species.name]
        if orient:
            mol_list = m.mcell_add_to_species_list(mol_sym, True, orient, None)
        else:
            mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
        rel_object = m.object()
        number_type = 0
        release_object = m.mcell_create_region_release(
            self._world, self._scene, self._mesh_objects[mesh_obj.name],
            rel_name, "ALL", mol_list, float(count),
            number_type, 1, None, rel_object)
        if rel_name not in self._releases:
            self._releases[rel_name] = release_object
        m.mcell_delete_species_list(mol_list)

        return release_object


    def create_release_site(
            self, species: Species, count: int, shape: str,
            pos_vec3: Vector3 = None, diam_vec3=None) -> None:
        """ Create a spherical/cubic release shape. """
        if pos_vec3 is None:
            pos_vec3 = m.Vector3()
        if diam_vec3 is None:
            diam_vec3 = m.Vector3()
        species_sym = self._species[species.name]
        rel_name = "%s_%s_rel" % (species.name, shape)
        if shape == "spherical":
            shape = m.SHAPE_SPHERICAL
        elif shape == "cubic":
            shape = m.SHAPE_CUBIC
        position, diameter, release_object = m.create_release_site(
            self._world, self._scene, pos_vec3, diam_vec3, shape,
            count, 0, species_sym, rel_name)
        if rel_name not in self._releases:
            self._releases[rel_name] = (position, diameter, release_object)

    def add_partitions(
            self, axis: str, start: float, stop: float, step: float) -> None:
        """ Add partitions to speed up the simulation. """
        if axis == "x":
            axis_num = 0
        elif axis == "y":
            axis_num = 1
        elif axis == "z":
            axis_num = 2
        m.create_partitions(self._world, axis_num, start, stop, step)

    def add_count(self, species: Species, mesh_obj: MeshObj) -> None:
        """ Add this to the list of species to be counted. """
        species_sym = self._species[species.name]
        mesh = self._mesh_objects[mesh_obj.name]
        mesh_sym = m.mcell_get_obj_sym(mesh)
        count_str = "react_data/seed_%04d/%s_%s" % (
                self._seed, species.name, mesh_obj.name)
        count_list, os, out_times, output = m.create_count(
            self._world, mesh_sym, species_sym, count_str, 1e-5)
        self._counts[count_str] = (count_list, os, out_times, output)

    def assign_surf_class(
            self, sc: SurfaceClass, region: SurfaceRegion) -> None:
        """ Assign a surface class to a region. """

        if sc.sc_type == "reflect":
            sc_type = m.RFLCT
        elif sc.sc_type == "transparent":
            sc_type = m.TRANSP
        elif sc.sc_type == "absorptive":
            sc_type = m.SINK
        else:
            print("Surface class '%s' is not a valid option" % sc_type)
        sc_sym = m.create_surf_class(self._world, sc.name)
        self._surface_classes[sc.name] = sc_sym
        spec_sym = self._species[sc.species.name]
        m.mcell_add_surf_class_properties(
            self._world, sc_type, sc_sym, spec_sym, sc.orient)
        region_swig_obj = self._regions[region.full_reg_name]
        m.mcell_assign_surf_class_to_region(sc_sym, region_swig_obj)

    def get_species_count(self, species: Species, mesh_obj: MeshObj) -> int:
        """ Get the current count of a molecule species. """
        return m.mcell_get_count(
            species.name, "Scene.%s,ALL" % mesh_obj.name, self._world)

    def modify_rate_constant(
            self, rxn: Reaction, new_rate_constant: float) -> None:
        """ Modify the rate constant of the specified reaction. """
        if not rxn.name:
            print("You can only change a named reaction.")
        else:
            m.mcell_modify_rate_constant(
                self._world, rxn.name, new_rate_constant)

    def run_iteration(self) -> None:
        """ Run a single iteration. """
        if self._finished:
            print("The simulation is done running")
            return

        if not self._started:
            m.mcell_init_simulation(self._world)
            m.mcell_init_output(self._world)
            self._started = True
        if self._current_iteration <= self._iterations:
            m.mcell_run_iteration(self._world, self._output_freq, 0)
# You have to kill it now or it will hang
        if self._current_iteration == self._iterations:
            m.mcell_flush_data(self._world)
            m.mcell_print_final_warnings(self._world)
            m.mcell_print_final_statistics(self._world)
            self._finished = True
        self._current_iteration += 1

    def run_sim(self) -> None:
        """ Run the entire simulation without interruption. """
        if self._finished:
            print("The simulation is done running")
            return

        m.mcell_init_simulation(self._world)
        m.mcell_init_output(self._world)

        for i in range(self._iterations+1):
            m.mcell_run_iteration(self._world, self._output_freq, 0)
        m.mcell_flush_data(self._world)
        m.mcell_print_final_warnings(self._world)
        m.mcell_print_final_statistics(self._world)
        self._finished = True

    def end_sim(self) -> None:
        """ Call this if we end the simulation early """
        if self._started and not self._finished:
            m.mcell_flush_data(self._world)
            m.mcell_print_final_warnings(self._world)
            m.mcell_print_final_statistics(self._world)
            self._finished = True


def create_partitions(world, axis, start, stop, step):
    expr_list = m.num_expr_list_head()
    expr_list.value_head = None
    expr_list.value_tail = None
    expr_list.value_count = 0
    expr_list.shared = 1
    m.mcell_generate_range(expr_list, start, stop, step)
    expr_list.shared = 1
    m.mcell_set_partition(world, axis, expr_list)


def create_release_pattern(
    world, name, delay=0, release_interval=1e20, train_interval=1e20,
        train_duration=1e20, number_of_trains=1):
    """Create a release pattern

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name -- name of the release pattern
        other arguments -- as listed
    """

    return m.mcell_create_release_pattern(
        world, name, delay, release_interval, train_interval, train_duration,
        number_of_trains)


def create_count(world, where, mol_sym, file_path, step):
    """Creates a count for a specified molecule in a specified region
    and initializes an output block for the count data that will be
    generated.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        where (sym_entry) -- symbol entry for the location you want to
            record
        mol_sym (sym_entry) -- symbol entry for the molecule
        file_path (dir) -- name of the file path to output the data to
        step -- frequency of output in seconds

    Returns:
        The return values count list, output set, output times and
        output structure

    """
    report_flags = m.REPORT_CONTENTS
    c_list = m.output_column_list()
# XXX: m.ORIENT_NOT_SET is using -100 instead of SHRT_MIN (used typemap
# for mcell_create_count in mcell_react_out.i) because limits.h does not
# work well with swig
    count_list = m.mcell_create_count(
        world, mol_sym, m.ORIENT_NOT_SET, where, report_flags, None, c_list)

    os = m.output_set()
    os = m.mcell_create_new_output_set(
        None, 0, count_list.column_head, m.FILE_SUBSTITUTE, file_path)

    out_times = m.output_times_inlist()
    out_times.type = m.OUTPUT_BY_STEP
    out_times.step = step

    output = m.output_set_list()
    output.set_head = os
    output.set_tail = os

    m.mcell_add_reaction_output_block(world, output, 10000, out_times)

    return (count_list, os, out_times, output)


def create_species(world, name, D, is_2d, custom_time_step=0):
    """Creates a molecule species

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- Name of the molecule species that will be
            generated
        D (double) -- Diffusion Coefficient for the molecule species
            that will be generated.
        is_2d (bool) -- Boolean describing whether new species is a
            surface molecule
        custom_time_step -- Custom time step (< 0.0 for a custom space step,
                       >0.0 for custom timestep, 0.0 for default timestep)
    Returns:
        (mcell_symbol) Returns a species sym_entry

    """
    species_def = m.mcell_species_spec()
    species_def.name = name
    species_def.D = D
    is_2d = 1 if is_2d else 0
    species_def.is_2d = is_2d
    species_def.custom_time_step = custom_time_step
    species_def.target_only = 0
    species_def.max_step_length = 0

    species_temp_sym = m.mcell_symbol()
    species_sym = m.mcell_create_species(
        world, species_def, species_temp_sym)

    return species_sym


def create_reaction(
        world, reactants, products, rate_constant,
        backward_rate_constant=0.0, surf_class=None, name=None):
    """Creates a molecular reaction

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        reactants (mcell_species_list) -- list of species that are the
            reactants for the reaction
        products (mcell_species_list) -- list of species that are the
            products for the reaction
        rate_constant (double) -- the rate constant for the forward
            direction reaction -> product
        backward_rate_constant (double)(optional) -- the rate constant
            for the backward direction reaction <- product
        surf_class (mcell species list surface class)(optional) -- the
            surface class upon which the reaction will happen
        name (string)(optional) -- Name of the reaction

    Returns:
        void -- creates a reaction, by generating reaction_rates
            structure

    """

    if surf_class:
# Do nothing, surf_class has been added and a null object is not needed
        pass
    else:
        surf_class = m.mcell_add_to_species_list(None, False, 0, None)

    arrow = m.reaction_arrow()
# reversible reaction e.g. A<->B
    if backward_rate_constant:
        arrow.flags = m.ARROW_BIDIRECTIONAL
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_CONSTANT,
            backward_rate_constant)
# irreversible reaction e.g. A->B
    else:
        arrow.flags = m.REGULAR_ARROW
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_UNSET, 0)
    arrow.catalyst = m.mcell_species()
    arrow.catalyst.next = None
    arrow.catalyst.mol_type = None
    arrow.catalyst.orient_set = 0
    arrow.catalyst.orient = 0

    if (name):
        name_sym = m.mcell_new_rxn_pathname(world, name)
    else:
        name_sym = None
    m.mcell_add_reaction_simplified(
        world, reactants, arrow, surf_class, products, rate_constant, name_sym)


def create_instance_object(world, name):
    """Creates an instance object. Simple translation from wrapped code
    to python function. Frees the user from having to initialize the
    scene object and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        instance object

    """
    scene_temp = m.object()
    return m.mcell_create_instance_object(world, name, scene_temp)


def create_surf_class(world, name):
    """Creates a surface class. Simple translation from wrapped code to
    python function Frees the user from having to initialize the surface
    class symbol and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        mcell_symbol for surface class

    """

    sc_temp = m.mcell_symbol()
    return m.mcell_create_surf_class(world, name, sc_temp)


def create_list_release_site(
    world, scene, mol_list, xpos, ypos, zpos, name, surf_flags=None,
        orientations=None, diameter=1e-4):
    '''
    Creates a list release site
    All is self explanatory except mol_list:
    This is a list of "mol_sym" that you get back when you create the species.
    This is a Python list - it is converted to a species list in this function
    for you. By default, assumes all molecules are volume molecules. Else, need
    to pass surf_flags=[True,True,False,...] and their orientations =
    [1,0,1,...] Diameter is the diameter we search for to place a surface mol
    It can be None (= NULL in C) but then we do a poor job of placing surface
    mols
    '''

# Check that they're all the same length
    n = len(mol_list)
    if len(xpos) != n or len(ypos) != n or len(zpos) != n:
        raise ValueError("All lists must have the same length.")

# Check that if there are surface molecules
    if surf_flags is not None:
# Check that there are enough
        if len(surf_flags) != n or len(orientations) != n:
            raise ValueError(
                "surf_flags and orientations lists must have the same lengths "
                "as the others.")

# Convert to floats (can't be int)
    xpos = [float(q) for q in xpos]
    ypos = [float(q) for q in ypos]
    zpos = [float(q) for q in zpos]

# Diameter
    diam = m.vector3()
    diam.x = diameter
    diam.y = diameter
    diam.z = diameter

# Mols
    mol_list.reverse()
    species_list = None
# All volume molecules
    if surf_flags is None:
        for mol_sym in mol_list:
            species_list = m.mcell_add_to_species_list(
                mol_sym, False, 0, species_list)
    else:
        for i, mol_sym in enumerate(mol_list):
            species_list = m.mcell_add_to_species_list(
                mol_sym, surf_flags[i], orientations[i], species_list)

    rel_object = m.object()
    ret = m.mcell_create_list_release_site(
        world, scene, name, species_list, xpos, ypos, zpos, n, diam,
        rel_object)
# Delete the species list
    m.mcell_delete_species_list(species_list)

# VERY IMPORTANT HERE - MUST RETURN "ret"
# If we throw this away, all is lost....
    return (rel_object, ret)


def create_release_site(
        world, scene, pos, diam, shape, number, number_type, mol_sym, name):
    """Creates a molecule release site

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        pos (vector3) -- position of release site
        diam (vector3) -- diameter of release site
        number (int or float) -- number to be release at release site
        number_type (int) -- 0 for NUMBER, 1 for CONCENTRATION
        mol_sym (mcell_symbol) -- species to be released
        name (string) -- name of the release site

    Returns:
        void -- generates a species release site

    """

    position = m.vector3()
    position.x = pos.x
    position.y = pos.y
    position.z = pos.z
    diameter = m.vector3()
    diameter.x = diam.x
    diameter.y = diam.y
    diameter.z = diam.z

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_geometrical_release_site(
        world, scene, name, shape, position, diameter, mol_list, float(number),
        number_type, 1, None, rel_object)
    m.mcell_delete_species_list(mol_list)

    return (position, diameter, release_object)


def create_region_release_site(
        world, scene, mesh, release_name, reg_name, number, number_type,
        mol_sym):
    """Creates a release site on a specific region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        mesh (mesh object) -- scene object where the release will occur
        release_name (string) -- name of the region release site
        reg_name (string) -- name of the region for the release site
        number (int or float) -- number to be released at the region release
            site
        number_type (int) -- 0 for NUMBER, 1 for CONCENTRATION
        mol_sym (mcell_symbol) -- species to be released

    Returns:
        release object (object)

    """

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_region_release(
        world, scene, mesh, release_name, reg_name, mol_list, float(number),
        number_type, 1, None, rel_object)
    m.mcell_delete_species_list(mol_list)

    return release_object


def create_box(world, scene, half_length, name):
    """Creates the verteces and lines of a cube object at the origin

    Args:
        half_length (double) -- half length of the cube

    Returns:
        vertex list and element connection list

    """

    hl = half_length
    verts = m.mcell_add_to_vertex_list(hl, hl, -hl, None)
    verts = m.mcell_add_to_vertex_list(hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, hl, verts)

    elems = m.mcell_add_to_connection_list(1, 2, 3, None)
    elems = m.mcell_add_to_connection_list(7, 6, 5, elems)
    elems = m.mcell_add_to_connection_list(0, 4, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 5, 6, elems)
    elems = m.mcell_add_to_connection_list(6, 7, 3, elems)
    elems = m.mcell_add_to_connection_list(0, 3, 7, elems)
    elems = m.mcell_add_to_connection_list(0, 1, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 7, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 0, 5, elems)
    elems = m.mcell_add_to_connection_list(2, 1, 6, elems)
    elems = m.mcell_add_to_connection_list(2, 6, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 0, 7, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = 8
    pobj.connections = elems
    pobj.num_conn = 12

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def change_geometry(world, scene_name, obj_list):

    pobj_list = None
    verts = None
    elems = None

    for p in obj_list:

        verts = None
        for x, y, z in p.vert_list:
            verts = m.mcell_add_to_vertex_list(x, y, z, verts)

        elems = None
        for x, y, z in p.face_list:
            elems = m.mcell_add_to_connection_list(x, y, z, elems)

        pobj = m.poly_object()
        pobj.obj_name = p.obj_name
        pobj.vertices = verts
        pobj.num_vert = len(p.vert_list)
        pobj.connections = elems
        pobj.num_conn = len(p.face_list)

        surf_reg_faces = None
        for idx in p.surf_reg_face_list:
            surf_reg_faces = m.mcell_add_to_region_list(surf_reg_faces, idx)

        pobj_list = m.mcell_add_to_poly_obj_list(
                pobj_list, p.obj_name, verts, len(p.vert_list), elems,
                len(p.face_list), surf_reg_faces, p.reg_name)

    m.mcell_change_geometry(world, pobj_list)


def create_polygon_object(world, vert_list, face_list, scene, name):
    """Creates a polygon object from a vertex and element lest

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        vert_list (vertex list) -- verteces for the polygon
        face_list (element connection list) -- faces for the polygon
        scene (instance object) -- scene for mcell simulation
        name (string) -- name of polygon object that will be created

    Returns:
        polygon object
    """

    verts = None
    vert_list = vert_list[::-1]
    for x, y, z in vert_list:
        verts = m.mcell_add_to_vertex_list(x, y, z, verts)

    elems = None
    face_list = face_list[::-1]
    for x, y, z in face_list:
        elems = m.mcell_add_to_connection_list(x, y, z, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = len(vert_list)
    pobj.connections = elems
    pobj.num_conn = len(face_list)

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def create_surface_region(world, mesh, surf_reg_face_list, region_name):
    """Creates a surface region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        mesh (polygon object) -- object where surface region will reside
        surf_reg_face_list (element connection list) -- list of surface
            region faces
        region_name (string) -- name of the surface region being created

    Returns:
        region object

    """

    surface_region = m.mcell_create_region(world, mesh, region_name)

    surf_reg_faces = None
    for idx in surf_reg_face_list:
        surf_reg_faces = m.mcell_add_to_region_list(surf_reg_faces, idx)

    m.mcell_set_region_elements(surface_region, surf_reg_faces, 1)

    return surface_region

import pymcell as m


def read_json_data_model(file_name: str):
    with open(file_name, 'r') as f:
        json_model = f.read()
        data_model = json.loads(json_model)
    return data_model


def create_species_from_dm(data_model: Dict) -> List[Species]:
    species_dm_list = data_model['mcell']['define_molecules']['molecule_list']
# species_list = []
    species_dict = {}
    for species_dm in species_dm_list:
        species_name = species_dm['mol_name']
        dc = float(species_dm['diffusion_constant'])
        species_type = species_dm['mol_type']
        surface = False
        if species_type == '2D':
            surface = True
        species_dm = m.Species(species_name, dc, surface)
        species_dict[species_name] = species_dm
# species_list.append(species_dm)
    return species_dict
# return species_list

def make_spec_orient_list(mol_str_list, species):
# mol_str_list = reactant_products.split(" + ")
    spec_orient_list = []
    for r in mol_str_list:
        if r.endswith("'") or r.endswith(","):
            r_str = r[:-1]
            r_orient = r[-1]
            if r_orient == "'":
                orient = m.Orient.up
            elif r_orient == ",":
                orient = m.Orient.down
            else:
                orient = m.Orient.mix
        else:
            r_str = r
            orient = m.Orient.mix
# r_orient = ""
        spec = species[r_str]
        spec_orient = (spec, orient)
        spec_orient_list.append(spec_orient)
    return spec_orient_list


def create_reactions_from_dm(
        data_model: Dict, species: Dict[str, Species]) -> List[Reaction]:
    rxn_dm_list = data_model['mcell']['define_reactions']['reaction_list']
    rxn_list = []
    for rxn_dm in rxn_dm_list:
        rxn_name = rxn_dm['rxn_name']
        fwd_rate = float(rxn_dm['fwd_rate'])
        try:
            bkwd_rate = float(rxn_dm['bkwd_rate'])
        except ValueError:
            pass
        reactants_str_list = rxn_dm['reactants'].split(" + ")
        products_str_list = rxn_dm['products'].split(" + ")
        r_list = make_spec_orient_list(reactants_str_list, species)
        p_list = make_spec_orient_list(products_str_list, species)
        rxn_type = rxn_dm['rxn_type']
        rxn_dm = m.Reaction(r_list, p_list, fwd_rate)
        rxn_list.append(rxn_dm)
    return rxn_list


def create_meshobjs_from_dm(dm: Dict):
    meshobj_dm_list = dm['mcell']['geometrical_objects']['object_list']
    meshobj_list = []
    for meshobj in meshobj_dm_list:
        name = meshobj['name']
        vert_list = meshobj['vertex_list']
        face_list = meshobj['element_connections']
        meshobj_list.append(m.MeshObj(name, vert_list, face_list))
    return meshobj_list


_pymcell.MCELL_SUCCESS_swigconstant(_pymcell)
MCELL_SUCCESS = _pymcell.MCELL_SUCCESS

_pymcell.MCELL_FAIL_swigconstant(_pymcell)
MCELL_FAIL = _pymcell.MCELL_FAIL
class num_expr_list_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_expr_list_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_expr_list_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_set
    __swig_getmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_get
    if _newclass:
        value_head = _swig_property(_pymcell.num_expr_list_head_value_head_get, _pymcell.num_expr_list_head_value_head_set)
    __swig_setmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_set
    __swig_getmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_get
    if _newclass:
        value_tail = _swig_property(_pymcell.num_expr_list_head_value_tail_get, _pymcell.num_expr_list_head_value_tail_set)
    __swig_setmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_set
    __swig_getmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_get
    if _newclass:
        value_count = _swig_property(_pymcell.num_expr_list_head_value_count_get, _pymcell.num_expr_list_head_value_count_set)
    __swig_setmethods__["shared"] = _pymcell.num_expr_list_head_shared_set
    __swig_getmethods__["shared"] = _pymcell.num_expr_list_head_shared_get
    if _newclass:
        shared = _swig_property(_pymcell.num_expr_list_head_shared_get, _pymcell.num_expr_list_head_shared_set)

    def __init__(self, *args):
        """__init__(self) -> num_expr_list_head"""
        this = _pymcell.new_num_expr_list_head(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_num_expr_list_head
    __del__ = lambda self: None
num_expr_list_head_swigregister = _pymcell.num_expr_list_head_swigregister
num_expr_list_head_swigregister(num_expr_list_head)


def mcell_set_seed(state: 'MCELL_STATE *', seed: 'int') -> "void":
    return _pymcell.mcell_set_seed(state, seed)
mcell_set_seed = _pymcell.mcell_set_seed

def mcell_create() -> "MCELL_STATE *":
    return _pymcell.mcell_create()
mcell_create = _pymcell.mcell_create

def mcell_init_state(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_state(state)
mcell_init_state = _pymcell.mcell_init_state

def mcell_init_simulation(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_simulation(state)
mcell_init_simulation = _pymcell.mcell_init_simulation

def mcell_init_read_checkpoint(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_read_checkpoint(state)
mcell_init_read_checkpoint = _pymcell.mcell_init_read_checkpoint

def mcell_init_output(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_output(state)
mcell_init_output = _pymcell.mcell_init_output

def mcell_set_partition(state: 'MCELL_STATE *', dim: 'int', head: 'num_expr_list_head') -> "MCELL_STATUS":
    return _pymcell.mcell_set_partition(state, dim, head)
mcell_set_partition = _pymcell.mcell_set_partition

def mcell_set_time_step(state: 'MCELL_STATE *', step: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_set_time_step(state, step)
mcell_set_time_step = _pymcell.mcell_set_time_step

def mcell_set_iterations(state: 'MCELL_STATE *', iterations: 'long long') -> "MCELL_STATUS":
    return _pymcell.mcell_set_iterations(state, iterations)
mcell_set_iterations = _pymcell.mcell_set_iterations

def mcell_silence_notifications(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_silence_notifications(state)
mcell_silence_notifications = _pymcell.mcell_silence_notifications

def mcell_print_version() -> "void":
    return _pymcell.mcell_print_version()
mcell_print_version = _pymcell.mcell_print_version

def mcell_print_usage(executable_name: 'char const *') -> "void":
    return _pymcell.mcell_print_usage(executable_name)
mcell_print_usage = _pymcell.mcell_print_usage

def mcell_print_stats() -> "void":
    return _pymcell.mcell_print_stats()
mcell_print_stats = _pymcell.mcell_print_stats

def mcell_argparse(argc: 'int', argv: 'char **', state: 'MCELL_STATE *') -> "int":
    return _pymcell.mcell_argparse(argc, argv, state)
mcell_argparse = _pymcell.mcell_argparse

def mcell_copysort_numeric_list(head: 'num_expr_list') -> "struct num_expr_list *":
    return _pymcell.mcell_copysort_numeric_list(head)
mcell_copysort_numeric_list = _pymcell.mcell_copysort_numeric_list

def mcell_sort_numeric_list(head: 'num_expr_list') -> "void":
    return _pymcell.mcell_sort_numeric_list(head)
mcell_sort_numeric_list = _pymcell.mcell_sort_numeric_list

def mcell_free_numeric_list(nel: 'num_expr_list') -> "void":
    return _pymcell.mcell_free_numeric_list(nel)
mcell_free_numeric_list = _pymcell.mcell_free_numeric_list

def mcell_generate_range(list: 'num_expr_list_head', start: 'double', end: 'double', step: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_generate_range(list, start, end, step)
mcell_generate_range = _pymcell.mcell_generate_range

def mcell_generate_range_singleton(lh: 'num_expr_list_head', value: 'double') -> "int":
    return _pymcell.mcell_generate_range_singleton(lh, value)
mcell_generate_range_singleton = _pymcell.mcell_generate_range_singleton

def mcell_print(message: 'char const *') -> "void":
    return _pymcell.mcell_print(message)
mcell_print = _pymcell.mcell_print
class object_creation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object_creation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object_creation, name)
    __repr__ = _swig_repr
    __swig_setmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_set
    __swig_getmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_get
    if _newclass:
        object_name_list = _swig_property(_pymcell.object_creation_object_name_list_get, _pymcell.object_creation_object_name_list_set)
    __swig_setmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_set
    __swig_getmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_get
    if _newclass:
        object_name_list_end = _swig_property(_pymcell.object_creation_object_name_list_end_get, _pymcell.object_creation_object_name_list_end_set)
    __swig_setmethods__["current_object"] = _pymcell.object_creation_current_object_set
    __swig_getmethods__["current_object"] = _pymcell.object_creation_current_object_get
    if _newclass:
        current_object = _swig_property(_pymcell.object_creation_current_object_get, _pymcell.object_creation_current_object_set)

    def __init__(self, *args):
        """__init__(self) -> object_creation"""
        this = _pymcell.new_object_creation(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_object_creation
    __del__ = lambda self: None
object_creation_swigregister = _pymcell.object_creation_swigregister
object_creation_swigregister(object_creation)

class poly_object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, poly_object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, poly_object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["obj_name"] = _pymcell.poly_object_obj_name_set
    __swig_getmethods__["obj_name"] = _pymcell.poly_object_obj_name_get
    if _newclass:
        obj_name = _swig_property(_pymcell.poly_object_obj_name_get, _pymcell.poly_object_obj_name_set)
    __swig_setmethods__["vertices"] = _pymcell.poly_object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.poly_object_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.poly_object_vertices_get, _pymcell.poly_object_vertices_set)
    __swig_setmethods__["num_vert"] = _pymcell.poly_object_num_vert_set
    __swig_getmethods__["num_vert"] = _pymcell.poly_object_num_vert_get
    if _newclass:
        num_vert = _swig_property(_pymcell.poly_object_num_vert_get, _pymcell.poly_object_num_vert_set)
    __swig_setmethods__["connections"] = _pymcell.poly_object_connections_set
    __swig_getmethods__["connections"] = _pymcell.poly_object_connections_get
    if _newclass:
        connections = _swig_property(_pymcell.poly_object_connections_get, _pymcell.poly_object_connections_set)
    __swig_setmethods__["num_conn"] = _pymcell.poly_object_num_conn_set
    __swig_getmethods__["num_conn"] = _pymcell.poly_object_num_conn_get
    if _newclass:
        num_conn = _swig_property(_pymcell.poly_object_num_conn_get, _pymcell.poly_object_num_conn_set)

    def __init__(self, *args):
        """__init__(self) -> poly_object"""
        this = _pymcell.new_poly_object(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_poly_object
    __del__ = lambda self: None
poly_object_swigregister = _pymcell.poly_object_swigregister
poly_object_swigregister(poly_object)

class poly_object_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, poly_object_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, poly_object_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["obj_name"] = _pymcell.poly_object_list_obj_name_set
    __swig_getmethods__["obj_name"] = _pymcell.poly_object_list_obj_name_get
    if _newclass:
        obj_name = _swig_property(_pymcell.poly_object_list_obj_name_get, _pymcell.poly_object_list_obj_name_set)
    __swig_setmethods__["vertices"] = _pymcell.poly_object_list_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.poly_object_list_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.poly_object_list_vertices_get, _pymcell.poly_object_list_vertices_set)
    __swig_setmethods__["num_vert"] = _pymcell.poly_object_list_num_vert_set
    __swig_getmethods__["num_vert"] = _pymcell.poly_object_list_num_vert_get
    if _newclass:
        num_vert = _swig_property(_pymcell.poly_object_list_num_vert_get, _pymcell.poly_object_list_num_vert_set)
    __swig_setmethods__["connections"] = _pymcell.poly_object_list_connections_set
    __swig_getmethods__["connections"] = _pymcell.poly_object_list_connections_get
    if _newclass:
        connections = _swig_property(_pymcell.poly_object_list_connections_get, _pymcell.poly_object_list_connections_set)
    __swig_setmethods__["num_conn"] = _pymcell.poly_object_list_num_conn_set
    __swig_getmethods__["num_conn"] = _pymcell.poly_object_list_num_conn_get
    if _newclass:
        num_conn = _swig_property(_pymcell.poly_object_list_num_conn_get, _pymcell.poly_object_list_num_conn_set)
    __swig_setmethods__["surf_reg_faces"] = _pymcell.poly_object_list_surf_reg_faces_set
    __swig_getmethods__["surf_reg_faces"] = _pymcell.poly_object_list_surf_reg_faces_get
    if _newclass:
        surf_reg_faces = _swig_property(_pymcell.poly_object_list_surf_reg_faces_get, _pymcell.poly_object_list_surf_reg_faces_set)
    __swig_setmethods__["reg_name"] = _pymcell.poly_object_list_reg_name_set
    __swig_getmethods__["reg_name"] = _pymcell.poly_object_list_reg_name_get
    if _newclass:
        reg_name = _swig_property(_pymcell.poly_object_list_reg_name_get, _pymcell.poly_object_list_reg_name_set)
    __swig_setmethods__["next"] = _pymcell.poly_object_list_next_set
    __swig_getmethods__["next"] = _pymcell.poly_object_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.poly_object_list_next_get, _pymcell.poly_object_list_next_set)

    def __init__(self, *args):
        """__init__(self) -> poly_object_list"""
        this = _pymcell.new_poly_object_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_poly_object_list
    __del__ = lambda self: None
poly_object_list_swigregister = _pymcell.poly_object_list_swigregister
poly_object_list_swigregister(poly_object_list)


def mcell_create_instance_object(state: 'MCELL_STATE *', name: 'char *', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_instance_object(state, name, new_object)
mcell_create_instance_object = _pymcell.mcell_create_instance_object

def mcell_create_poly_object(state: 'MCELL_STATE *', parent: 'object', poly_obj: 'poly_object', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_poly_object(state, parent, poly_obj, new_object)
mcell_create_poly_object = _pymcell.mcell_create_poly_object

def new_polygon_list(state: 'MCELL_STATE *', obj_ptr: 'object', n_vertices: 'int', vertices: 'struct vertex_list *', n_connections: 'int', connections: 'struct element_connection_list *') -> "struct polygon_object *":
    return _pymcell.new_polygon_list(state, obj_ptr, n_vertices, vertices, n_connections, connections)
new_polygon_list = _pymcell.new_polygon_list

def make_new_object(dg_parse: 'struct dyngeom_parse_vars *', obj_sym_table: 'sym_table_head', obj_name: 'char *', error_code: 'int *') -> "struct object *":
    return _pymcell.make_new_object(dg_parse, obj_sym_table, obj_name, error_code)
make_new_object = _pymcell.make_new_object

def push_object_name(obj_creation: 'object_creation', name: 'char *') -> "char *":
    return _pymcell.push_object_name(obj_creation, name)
push_object_name = _pymcell.push_object_name

def pop_object_name(obj_creation: 'object_creation') -> "void":
    return _pymcell.pop_object_name(obj_creation)
pop_object_name = _pymcell.pop_object_name

def mcell_add_to_vertex_list(x: 'double', y: 'double', z: 'double', vertices: 'struct vertex_list *') -> "struct vertex_list *":
    return _pymcell.mcell_add_to_vertex_list(x, y, z, vertices)
mcell_add_to_vertex_list = _pymcell.mcell_add_to_vertex_list

def free_vertex_list(vert_list: 'struct vertex_list *') -> "void":
    return _pymcell.free_vertex_list(vert_list)
free_vertex_list = _pymcell.free_vertex_list

def mcell_add_to_connection_list(v1: 'int', v2: 'int', v3: 'int', elements: 'struct element_connection_list *') -> "struct element_connection_list *":
    return _pymcell.mcell_add_to_connection_list(v1, v2, v3, elements)
mcell_add_to_connection_list = _pymcell.mcell_add_to_connection_list

def free_connection_list(elem_conn_list: 'struct element_connection_list *') -> "void":
    return _pymcell.free_connection_list(elem_conn_list)
free_connection_list = _pymcell.free_connection_list

def mcell_set_region_elements(rgn: 'struct region *', elements: 'struct element_list *', normalize_now: 'int') -> "int":
    return _pymcell.mcell_set_region_elements(rgn, elements, normalize_now)
mcell_set_region_elements = _pymcell.mcell_set_region_elements

def mcell_add_to_region_list(elements: 'struct element_list *', region_idx: 'unsigned int') -> "struct element_list *":
    return _pymcell.mcell_add_to_region_list(elements, region_idx)
mcell_add_to_region_list = _pymcell.mcell_add_to_region_list

def add_child_objects(parent: 'object', child_head: 'object', child_tail: 'object') -> "void":
    return _pymcell.add_child_objects(parent, child_head, child_tail)
add_child_objects = _pymcell.add_child_objects

def mcell_create_region(state: 'MCELL_STATE *', objp: 'object', name: 'char *') -> "struct region *":
    return _pymcell.mcell_create_region(state, objp, name)
mcell_create_region = _pymcell.mcell_create_region

def make_new_region(dg_parse: 'struct dyngeom_parse_vars *', state: 'MCELL_STATE *', obj_name: 'char *', region_last_name: 'char *') -> "struct region *":
    return _pymcell.make_new_region(dg_parse, state, obj_name, region_last_name)
make_new_region = _pymcell.make_new_region

def remove_gaps_from_regions(obj_ptr: 'object') -> "void":
    return _pymcell.remove_gaps_from_regions(obj_ptr)
remove_gaps_from_regions = _pymcell.remove_gaps_from_regions

def check_degenerate_polygon_list(obj_ptr: 'object') -> "int":
    return _pymcell.check_degenerate_polygon_list(obj_ptr)
check_degenerate_polygon_list = _pymcell.check_degenerate_polygon_list

def common_ancestor(a: 'object', b: 'object') -> "struct object *":
    return _pymcell.common_ancestor(a, b)
common_ancestor = _pymcell.common_ancestor

def allocate_polygon_object(desc: 'char const *') -> "struct polygon_object *":
    return _pymcell.allocate_polygon_object(desc)
allocate_polygon_object = _pymcell.allocate_polygon_object

def new_element_list(begin: 'unsigned int', end: 'unsigned int') -> "struct element_list *":
    return _pymcell.new_element_list(begin, end)
new_element_list = _pymcell.new_element_list

def normalize_elements(reg: 'struct region *', existing: 'int') -> "int":
    return _pymcell.normalize_elements(reg, existing)
normalize_elements = _pymcell.normalize_elements

def count_cuboid_elements(sb: 'struct subdivided_box *') -> "int":
    return _pymcell.count_cuboid_elements(sb)
count_cuboid_elements = _pymcell.count_cuboid_elements

def cuboid_patch_to_bits(subd_box: 'struct subdivided_box *', v1: 'vector3', v2: 'vector3', bit_arr: 'struct bit_array *') -> "int":
    return _pymcell.cuboid_patch_to_bits(subd_box, v1, v2, bit_arr)
cuboid_patch_to_bits = _pymcell.cuboid_patch_to_bits

def check_patch(b: 'struct subdivided_box *', p1: 'vector3', p2: 'vector3', egd: 'double') -> "int":
    return _pymcell.check_patch(b, p1, p2, egd)
check_patch = _pymcell.check_patch

def mcell_get_obj_sym(obj: 'object') -> "struct sym_entry *":
    return _pymcell.mcell_get_obj_sym(obj)
mcell_get_obj_sym = _pymcell.mcell_get_obj_sym

def mcell_get_reg_sym(reg: 'struct region *') -> "struct sym_entry *":
    return _pymcell.mcell_get_reg_sym(reg)
mcell_get_reg_sym = _pymcell.mcell_get_reg_sym

def mcell_add_to_poly_obj_list(poly_obj_list: 'poly_object_list', obj_name: 'char *', vertices: 'struct vertex_list *', num_vert: 'int', connections: 'struct element_connection_list *', num_conn: 'int', surf_reg_faces: 'struct element_list *', reg_name: 'char *') -> "struct poly_object_list *":
    return _pymcell.mcell_add_to_poly_obj_list(poly_obj_list, obj_name, vertices, num_vert, connections, num_conn, surf_reg_faces, reg_name)
mcell_add_to_poly_obj_list = _pymcell.mcell_add_to_poly_obj_list
class output_column_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_column_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_column_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["column_head"] = _pymcell.output_column_list_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_column_list_column_head_get
    if _newclass:
        column_head = _swig_property(_pymcell.output_column_list_column_head_get, _pymcell.output_column_list_column_head_set)
    __swig_setmethods__["column_tail"] = _pymcell.output_column_list_column_tail_set
    __swig_getmethods__["column_tail"] = _pymcell.output_column_list_column_tail_get
    if _newclass:
        column_tail = _swig_property(_pymcell.output_column_list_column_tail_get, _pymcell.output_column_list_column_tail_set)

    def __init__(self, *args):
        """__init__(self) -> output_column_list"""
        this = _pymcell.new_output_column_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_column_list
    __del__ = lambda self: None
output_column_list_swigregister = _pymcell.output_column_list_swigregister
output_column_list_swigregister(output_column_list)

class output_set_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["set_head"] = _pymcell.output_set_list_set_head_set
    __swig_getmethods__["set_head"] = _pymcell.output_set_list_set_head_get
    if _newclass:
        set_head = _swig_property(_pymcell.output_set_list_set_head_get, _pymcell.output_set_list_set_head_set)
    __swig_setmethods__["set_tail"] = _pymcell.output_set_list_set_tail_set
    __swig_getmethods__["set_tail"] = _pymcell.output_set_list_set_tail_get
    if _newclass:
        set_tail = _swig_property(_pymcell.output_set_list_set_tail_get, _pymcell.output_set_list_set_tail_set)

    def __init__(self, *args):
        """__init__(self) -> output_set_list"""
        this = _pymcell.new_output_set_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_set_list
    __del__ = lambda self: None
output_set_list_swigregister = _pymcell.output_set_list_swigregister
output_set_list_swigregister(output_set_list)

class output_times_inlist(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_times_inlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_times_inlist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _pymcell.output_times_inlist_type_set
    __swig_getmethods__["type"] = _pymcell.output_times_inlist_type_get
    if _newclass:
        type = _swig_property(_pymcell.output_times_inlist_type_get, _pymcell.output_times_inlist_type_set)
    __swig_setmethods__["step"] = _pymcell.output_times_inlist_step_set
    __swig_getmethods__["step"] = _pymcell.output_times_inlist_step_get
    if _newclass:
        step = _swig_property(_pymcell.output_times_inlist_step_get, _pymcell.output_times_inlist_step_set)
    __swig_setmethods__["values"] = _pymcell.output_times_inlist_values_set
    __swig_getmethods__["values"] = _pymcell.output_times_inlist_values_get
    if _newclass:
        values = _swig_property(_pymcell.output_times_inlist_values_get, _pymcell.output_times_inlist_values_set)

    def __init__(self, *args):
        """__init__(self) -> output_times_inlist"""
        this = _pymcell.new_output_times_inlist(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_times_inlist
    __del__ = lambda self: None
output_times_inlist_swigregister = _pymcell.output_times_inlist_swigregister
output_times_inlist_swigregister(output_times_inlist)


def mcell_get_count(mol_name: 'char *', reg_name: 'char *', world: 'struct volume *') -> "int":
    return _pymcell.mcell_get_count(mol_name, reg_name, world)
mcell_get_count = _pymcell.mcell_get_count

def mcell_new_output_request(state: 'MCELL_STATE *', target: 'mcell_symbol', orientation: 'short', location: 'mcell_symbol', img: 'struct periodic_image *', report_flags: 'int') -> "struct output_request *":
    return _pymcell.mcell_new_output_request(state, target, orientation, location, img, report_flags)
mcell_new_output_request = _pymcell.mcell_new_output_request

def mcell_create_new_output_set(comment: 'char *', exact_time: 'int', col_head: 'struct output_column *', file_flags: 'int', outfile_name: 'char *') -> "struct output_set *":
    return _pymcell.mcell_create_new_output_set(comment, exact_time, col_head, file_flags, outfile_name)
mcell_create_new_output_set = _pymcell.mcell_create_new_output_set

def mcell_prepare_single_count_expr(list: 'output_column_list', expr: 'struct output_expression *', custom_header: 'char *') -> "MCELL_STATUS":
    return _pymcell.mcell_prepare_single_count_expr(list, expr, custom_header)
mcell_prepare_single_count_expr = _pymcell.mcell_prepare_single_count_expr

def mcell_add_reaction_output_block(state: 'MCELL_STATE *', osets: 'output_set_list', buffer_size: 'int', otimes: 'output_times_inlist') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction_output_block(state, osets, buffer_size, otimes)
mcell_add_reaction_output_block = _pymcell.mcell_add_reaction_output_block

def mcell_create_count(state: 'MCELL_STATE *', target: 'mcell_symbol', orientation: 'short', location: 'mcell_symbol', report_flags: 'int', custom_header: 'char *', count_list: 'output_column_list') -> "struct output_column_list *":
    return _pymcell.mcell_create_count(state, target, orientation, location, report_flags, custom_header, count_list)
mcell_create_count = _pymcell.mcell_create_count

def mcell_get_counter_value(state: 'MCELL_STATE *', counter_name: 'char const *', column: 'int', count_data: 'double *', count_data_type: 'enum count_type_t *') -> "MCELL_STATUS":
    return _pymcell.mcell_get_counter_value(state, counter_name, column, count_data, count_data_type)
mcell_get_counter_value = _pymcell.mcell_get_counter_value

_pymcell.REGULAR_ARROW_swigconstant(_pymcell)
REGULAR_ARROW = _pymcell.REGULAR_ARROW

_pymcell.ARROW_BIDIRECTIONAL_swigconstant(_pymcell)
ARROW_BIDIRECTIONAL = _pymcell.ARROW_BIDIRECTIONAL

_pymcell.ARROW_CATALYTIC_swigconstant(_pymcell)
ARROW_CATALYTIC = _pymcell.ARROW_CATALYTIC

_pymcell.RATE_UNSET_swigconstant(_pymcell)
RATE_UNSET = _pymcell.RATE_UNSET

_pymcell.RATE_CONSTANT_swigconstant(_pymcell)
RATE_CONSTANT = _pymcell.RATE_CONSTANT

_pymcell.RATE_FILE_swigconstant(_pymcell)
RATE_FILE = _pymcell.RATE_FILE

_pymcell.RFLCT_swigconstant(_pymcell)
RFLCT = _pymcell.RFLCT

_pymcell.TRANSP_swigconstant(_pymcell)
TRANSP = _pymcell.TRANSP

_pymcell.SINK_swigconstant(_pymcell)
SINK = _pymcell.SINK
class reaction_def(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_def, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_def, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sym"] = _pymcell.reaction_def_sym_set
    __swig_getmethods__["sym"] = _pymcell.reaction_def_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.reaction_def_sym_get, _pymcell.reaction_def_sym_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_def"""
        this = _pymcell.new_reaction_def(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_def
    __del__ = lambda self: None
reaction_def_swigregister = _pymcell.reaction_def_swigregister
reaction_def_swigregister(reaction_def)

class release_single_molecule_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_single_molecule_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_single_molecule_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_set
    __swig_getmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_get
    if _newclass:
        rsm_head = _swig_property(_pymcell.release_single_molecule_list_rsm_head_get, _pymcell.release_single_molecule_list_rsm_head_set)
    __swig_setmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_set
    __swig_getmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_get
    if _newclass:
        rsm_tail = _swig_property(_pymcell.release_single_molecule_list_rsm_tail_get, _pymcell.release_single_molecule_list_rsm_tail_set)
    __swig_setmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_set
    __swig_getmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_get
    if _newclass:
        rsm_count = _swig_property(_pymcell.release_single_molecule_list_rsm_count_get, _pymcell.release_single_molecule_list_rsm_count_set)

    def __init__(self, *args):
        """__init__(self) -> release_single_molecule_list"""
        this = _pymcell.new_release_single_molecule_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_single_molecule_list
    __del__ = lambda self: None
release_single_molecule_list_swigregister = _pymcell.release_single_molecule_list_swigregister
release_single_molecule_list_swigregister(release_single_molecule_list)

class reaction_arrow(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_arrow, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_arrow, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _pymcell.reaction_arrow_flags_set
    __swig_getmethods__["flags"] = _pymcell.reaction_arrow_flags_get
    if _newclass:
        flags = _swig_property(_pymcell.reaction_arrow_flags_get, _pymcell.reaction_arrow_flags_set)
    __swig_setmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_set
    __swig_getmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_get
    if _newclass:
        catalyst = _swig_property(_pymcell.reaction_arrow_catalyst_get, _pymcell.reaction_arrow_catalyst_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_arrow"""
        this = _pymcell.new_reaction_arrow(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_arrow
    __del__ = lambda self: None
reaction_arrow_swigregister = _pymcell.reaction_arrow_swigregister
reaction_arrow_swigregister(reaction_arrow)

class reaction_rate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_set
    __swig_getmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_get
    if _newclass:
        rate_type = _swig_property(_pymcell.reaction_rate_rate_type_get, _pymcell.reaction_rate_rate_type_set)
    __swig_getmethods__["v"] = _pymcell.reaction_rate_v_get
    if _newclass:
        v = _swig_property(_pymcell.reaction_rate_v_get)

    def __init__(self, *args):
        """__init__(self) -> reaction_rate"""
        this = _pymcell.new_reaction_rate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate
    __del__ = lambda self: None
reaction_rate_swigregister = _pymcell.reaction_rate_swigregister
reaction_rate_swigregister(reaction_rate)

class reaction_rate_v(_object):
    """Proxy of C reaction_rate_v struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate_v, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate_v, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_set
    __swig_getmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_get
    if _newclass:
        rate_constant = _swig_property(_pymcell.reaction_rate_v_rate_constant_get, _pymcell.reaction_rate_v_rate_constant_set)
    __swig_setmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_set
    __swig_getmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_get
    if _newclass:
        rate_file = _swig_property(_pymcell.reaction_rate_v_rate_file_get, _pymcell.reaction_rate_v_rate_file_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_rate_v"""
        this = _pymcell.new_reaction_rate_v(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate_v
    __del__ = lambda self: None
reaction_rate_v_swigregister = _pymcell.reaction_rate_v_swigregister
reaction_rate_v_swigregister(reaction_rate_v)

class reaction_rates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rates, name)
    __repr__ = _swig_repr
    __swig_setmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_set
    __swig_getmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_get
    if _newclass:
        forward_rate = _swig_property(_pymcell.reaction_rates_forward_rate_get, _pymcell.reaction_rates_forward_rate_set)
    __swig_setmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_set
    __swig_getmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_get
    if _newclass:
        backward_rate = _swig_property(_pymcell.reaction_rates_backward_rate_get, _pymcell.reaction_rates_backward_rate_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_rates"""
        this = _pymcell.new_reaction_rates(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rates
    __del__ = lambda self: None
reaction_rates_swigregister = _pymcell.reaction_rates_swigregister
reaction_rates_swigregister(reaction_rates)


def mcell_modify_multiple_rate_constants(world: 'struct volume *', names: 'char **', rate_constants: 'double *', n_rxns: 'int') -> "MCELL_STATUS":
    return _pymcell.mcell_modify_multiple_rate_constants(world, names, rate_constants, n_rxns)
mcell_modify_multiple_rate_constants = _pymcell.mcell_modify_multiple_rate_constants

def mcell_modify_rate_constant(world: 'struct volume *', name: 'char *', rate: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_modify_rate_constant(world, name, rate)
mcell_modify_rate_constant = _pymcell.mcell_modify_rate_constant

def mcell_add_reaction_simplified(state: 'struct volume *', reactants: 'mcell_species', arrow: 'reaction_arrow', surfs: 'mcell_species', products: 'mcell_species', rates: 'reaction_rates', pathname: 'mcell_symbol') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction_simplified(state, reactants, arrow, surfs, products, rates, pathname)
mcell_add_reaction_simplified = _pymcell.mcell_add_reaction_simplified

def mcell_add_reaction(notify: 'struct notifications *', r_step_release: 'double **', rxn_sym_table: 'sym_table_head', radial_subdivisions: 'u_int', vacancy_search_dist2: 'double', reactants: 'mcell_species', react_arrow: 'reaction_arrow', surf_class: 'mcell_species', products: 'mcell_species', pathname: 'mcell_symbol', rates: 'reaction_rates', forward_rate_filename: 'char const *', backward_rate_filename: 'char const *') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction(notify, r_step_release, rxn_sym_table, radial_subdivisions, vacancy_search_dist2, reactants, react_arrow, surf_class, products, pathname, rates, forward_rate_filename, backward_rate_filename)
mcell_add_reaction = _pymcell.mcell_add_reaction

def mcell_add_surface_reaction(rxn_sym_table: 'sym_table_head', reaction_type: 'int', surface_class: 'struct species *', reactant_sym: 'mcell_symbol', orient: 'short') -> "MCELL_STATUS":
    return _pymcell.mcell_add_surface_reaction(rxn_sym_table, reaction_type, surface_class, reactant_sym, orient)
mcell_add_surface_reaction = _pymcell.mcell_add_surface_reaction

def mcell_add_concentration_clamp(rxn_sym_table: 'sym_table_head', surface_class: 'struct species *', mol_sym: 'mcell_symbol', orient: 'short', conc: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_add_concentration_clamp(rxn_sym_table, surface_class, mol_sym, orient, conc)
mcell_add_concentration_clamp = _pymcell.mcell_add_concentration_clamp

def init_reactions(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.init_reactions(state)
init_reactions = _pymcell.init_reactions

def mcell_change_reaction_rate(state: 'MCELL_STATE *', reaction_name: 'char const *', new_rate: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_change_reaction_rate(state, reaction_name, new_rate)
mcell_change_reaction_rate = _pymcell.mcell_change_reaction_rate

def mcell_create_reaction_rates(forwardRateType: 'int', forwardRate: 'double', backwardRateType: 'int', backwardRate: 'double') -> "struct reaction_rates":
    return _pymcell.mcell_create_reaction_rates(forwardRateType, forwardRate, backwardRateType, backwardRate)
mcell_create_reaction_rates = _pymcell.mcell_create_reaction_rates

def mcell_new_rxn_pathname(state: 'struct volume *', name: 'char *') -> "struct sym_entry *":
    return _pymcell.mcell_new_rxn_pathname(state, name)
mcell_new_rxn_pathname = _pymcell.mcell_new_rxn_pathname

def mcell_create_list_release_site(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', mol: 'mcell_species', x_pos: 'double *', y_pos: 'double *', z_pos: 'double *', n_site: 'int', diameter: 'vector3', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_list_release_site(state, parent, site_name, mol, x_pos, y_pos, z_pos, n_site, diameter, new_object)
mcell_create_list_release_site = _pymcell.mcell_create_list_release_site

def mcell_create_geometrical_release_site(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', shape: 'int', position: 'vector3', diameter: 'vector3', mol: 'mcell_species', num: 'double', num_type: 'int', release_prob: 'double', rpatp: 'release_pattern', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_geometrical_release_site(state, parent, site_name, shape, position, diameter, mol, num, num_type, release_prob, rpatp, new_object)
mcell_create_geometrical_release_site = _pymcell.mcell_create_geometrical_release_site

def mcell_start_release_site(state: 'MCELL_STATE *', sym_ptr: 'mcell_symbol', obj: 'struct object **') -> "MCELL_STATUS":
    return _pymcell.mcell_start_release_site(state, sym_ptr, obj)
mcell_start_release_site = _pymcell.mcell_start_release_site

def mcell_finish_release_site(sym_ptr: 'mcell_symbol', obj: 'struct object **') -> "MCELL_STATUS":
    return _pymcell.mcell_finish_release_site(sym_ptr, obj)
mcell_finish_release_site = _pymcell.mcell_finish_release_site

def set_release_site_concentration(rel_site_obj_ptr: 'struct release_site_obj *', conc: 'double') -> "int":
    return _pymcell.set_release_site_concentration(rel_site_obj_ptr, conc)
set_release_site_concentration = _pymcell.set_release_site_concentration

def mcell_create_region_release(state: 'MCELL_STATE *', parent: 'object', release_on_in: 'object', site_name: 'char *', reg_name: 'char *', mol: 'mcell_species', num: 'double', num_type: 'int', rel_prob: 'double', rpatp: 'release_pattern', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_region_release(state, parent, release_on_in, site_name, reg_name, mol, num, num_type, rel_prob, rpatp, new_object)
mcell_create_region_release = _pymcell.mcell_create_region_release

def mcell_create_region_release_boolean(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', mol: 'mcell_species', num: 'double', num_type: 'int', rel_prob: 'double', rpatp: 'release_pattern', rel_eval: 'release_evaluator', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_region_release_boolean(state, parent, site_name, mol, num, num_type, rel_prob, rpatp, rel_eval, new_object)
mcell_create_region_release_boolean = _pymcell.mcell_create_region_release_boolean

def mcell_create_release_pattern(state: 'MCELL_STATE *', name: 'char *', delay: 'double', release_interval: 'double', train_interval: 'double', train_duration: 'double', number_of_trains: 'int') -> "struct release_pattern *":
    return _pymcell.mcell_create_release_pattern(state, name, delay, release_interval, train_interval, train_duration, number_of_trains)
mcell_create_release_pattern = _pymcell.mcell_create_release_pattern

def mcell_set_release_site_geometry_region(state: 'MCELL_STATE *', rel_site_obj_ptr: 'struct release_site_obj *', objp: 'object', re: 'release_evaluator') -> "int":
    return _pymcell.mcell_set_release_site_geometry_region(state, rel_site_obj_ptr, objp, re)
mcell_set_release_site_geometry_region = _pymcell.mcell_set_release_site_geometry_region

def check_release_regions(rel: 'release_evaluator', parent: 'object', instance: 'object') -> "int":
    return _pymcell.check_release_regions(rel, parent, instance)
check_release_regions = _pymcell.check_release_regions

def is_release_site_valid(rel_site_obj_ptr: 'struct release_site_obj *') -> "int":
    return _pymcell.is_release_site_valid(rel_site_obj_ptr)
is_release_site_valid = _pymcell.is_release_site_valid

def new_release_region_expr_term(my_sym: 'mcell_symbol') -> "struct release_evaluator *":
    return _pymcell.new_release_region_expr_term(my_sym)
new_release_region_expr_term = _pymcell.new_release_region_expr_term

def set_release_site_constant_number(rel_site_obj_ptr: 'struct release_site_obj *', num: 'double') -> "void":
    return _pymcell.set_release_site_constant_number(rel_site_obj_ptr, num)
set_release_site_constant_number = _pymcell.set_release_site_constant_number

def set_release_site_gaussian_number(rel_site_obj_ptr: 'struct release_site_obj *', mean: 'double', stdev: 'double') -> "void":
    return _pymcell.set_release_site_gaussian_number(rel_site_obj_ptr, mean, stdev)
set_release_site_gaussian_number = _pymcell.set_release_site_gaussian_number

def new_release_region_expr_binary(reL: 'release_evaluator', reR: 'release_evaluator', op: 'int') -> "struct release_evaluator *":
    return _pymcell.new_release_region_expr_binary(reL, reR, op)
new_release_region_expr_binary = _pymcell.new_release_region_expr_binary

def set_release_site_location(state: 'MCELL_STATE *', rel_site_obj_ptr: 'struct release_site_obj *', location: 'vector3') -> "void":
    return _pymcell.set_release_site_location(state, rel_site_obj_ptr, location)
set_release_site_location = _pymcell.set_release_site_location

def existing_region(state: 'MCELL_STATE *', obj_symp: 'mcell_symbol', region_name: 'char *') -> "struct sym_entry *":
    return _pymcell.existing_region(state, obj_symp, region_name)
existing_region = _pymcell.existing_region
class mcell_symbol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_symbol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_symbol, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_symbol_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_symbol_next_get
    if _newclass:
        next = _swig_property(_pymcell.mcell_symbol_next_get, _pymcell.mcell_symbol_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_get
    if _newclass:
        sym_type = _swig_property(_pymcell.mcell_symbol_sym_type_get, _pymcell.mcell_symbol_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.mcell_symbol_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_symbol_name_get
    if _newclass:
        name = _swig_property(_pymcell.mcell_symbol_name_get, _pymcell.mcell_symbol_name_set)
    __swig_setmethods__["value"] = _pymcell.mcell_symbol_value_set
    __swig_getmethods__["value"] = _pymcell.mcell_symbol_value_get
    if _newclass:
        value = _swig_property(_pymcell.mcell_symbol_value_get, _pymcell.mcell_symbol_value_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_symbol"""
        this = _pymcell.new_mcell_symbol(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_symbol
    __del__ = lambda self: None
mcell_symbol_swigregister = _pymcell.mcell_symbol_swigregister
mcell_symbol_swigregister(mcell_symbol)

class mcell_species_spec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_spec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_spec, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _pymcell.mcell_species_spec_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_species_spec_name_get
    if _newclass:
        name = _swig_property(_pymcell.mcell_species_spec_name_get, _pymcell.mcell_species_spec_name_set)
    __swig_setmethods__["D"] = _pymcell.mcell_species_spec_D_set
    __swig_getmethods__["D"] = _pymcell.mcell_species_spec_D_get
    if _newclass:
        D = _swig_property(_pymcell.mcell_species_spec_D_get, _pymcell.mcell_species_spec_D_set)
    __swig_setmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_set
    __swig_getmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_get
    if _newclass:
        is_2d = _swig_property(_pymcell.mcell_species_spec_is_2d_get, _pymcell.mcell_species_spec_is_2d_set)
    __swig_setmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_set
    __swig_getmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_get
    if _newclass:
        custom_time_step = _swig_property(_pymcell.mcell_species_spec_custom_time_step_get, _pymcell.mcell_species_spec_custom_time_step_set)
    __swig_setmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_set
    __swig_getmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_get
    if _newclass:
        target_only = _swig_property(_pymcell.mcell_species_spec_target_only_get, _pymcell.mcell_species_spec_target_only_set)
    __swig_setmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_set
    __swig_getmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_get
    if _newclass:
        max_step_length = _swig_property(_pymcell.mcell_species_spec_max_step_length_get, _pymcell.mcell_species_spec_max_step_length_set)
    __swig_setmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_set
    __swig_getmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_get
    if _newclass:
        space_step = _swig_property(_pymcell.mcell_species_spec_space_step_get, _pymcell.mcell_species_spec_space_step_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species_spec"""
        this = _pymcell.new_mcell_species_spec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_spec
    __del__ = lambda self: None
mcell_species_spec_swigregister = _pymcell.mcell_species_spec_swigregister
mcell_species_spec_swigregister(mcell_species_spec)

class mcell_species(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_species_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_species_next_get
    if _newclass:
        next = _swig_property(_pymcell.mcell_species_next_get, _pymcell.mcell_species_next_set)
    __swig_setmethods__["mol_type"] = _pymcell.mcell_species_mol_type_set
    __swig_getmethods__["mol_type"] = _pymcell.mcell_species_mol_type_get
    if _newclass:
        mol_type = _swig_property(_pymcell.mcell_species_mol_type_get, _pymcell.mcell_species_mol_type_set)
    __swig_setmethods__["orient_set"] = _pymcell.mcell_species_orient_set_set
    __swig_getmethods__["orient_set"] = _pymcell.mcell_species_orient_set_get
    if _newclass:
        orient_set = _swig_property(_pymcell.mcell_species_orient_set_get, _pymcell.mcell_species_orient_set_set)
    __swig_setmethods__["orient"] = _pymcell.mcell_species_orient_set
    __swig_getmethods__["orient"] = _pymcell.mcell_species_orient_get
    if _newclass:
        orient = _swig_property(_pymcell.mcell_species_orient_get, _pymcell.mcell_species_orient_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species"""
        this = _pymcell.new_mcell_species(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species
    __del__ = lambda self: None
mcell_species_swigregister = _pymcell.mcell_species_swigregister
mcell_species_swigregister(mcell_species)

class mcell_species_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_set
    __swig_getmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_get
    if _newclass:
        mol_type_head = _swig_property(_pymcell.mcell_species_list_mol_type_head_get, _pymcell.mcell_species_list_mol_type_head_set)
    __swig_setmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_set
    __swig_getmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_get
    if _newclass:
        mol_type_tail = _swig_property(_pymcell.mcell_species_list_mol_type_tail_get, _pymcell.mcell_species_list_mol_type_tail_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species_list"""
        this = _pymcell.new_mcell_species_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_list
    __del__ = lambda self: None
mcell_species_list_swigregister = _pymcell.mcell_species_list_swigregister
mcell_species_list_swigregister(mcell_species_list)


def mcell_create_species(state: 'MCELL_STATE *', species: 'mcell_species_spec', species_ptr: 'mcell_symbol **') -> "struct sym_entry **":
    return _pymcell.mcell_create_species(state, species, species_ptr)
mcell_create_species = _pymcell.mcell_create_species

def mcell_add_to_species_list(species_ptr: 'mcell_symbol', is_oriented: 'bool', orientation: 'int', species_list: 'mcell_species') -> "struct mcell_species *":
    return _pymcell.mcell_add_to_species_list(species_ptr, is_oriented, orientation, species_list)
mcell_add_to_species_list = _pymcell.mcell_add_to_species_list

def mcell_delete_species_list(species: 'mcell_species') -> "void":
    return _pymcell.mcell_delete_species_list(species)
mcell_delete_species_list = _pymcell.mcell_delete_species_list

def new_mol_species(state: 'MCELL_STATE *', name: 'char *', sym_ptr: 'struct sym_entry **') -> "int":
    return _pymcell.new_mol_species(state, name, sym_ptr)
new_mol_species = _pymcell.new_mol_species

def mcell_create_viz_output(state: 'MCELL_STATE *', filename: 'char *', mol_viz_list: 'mcell_species', start: 'long long', end: 'long long', step: 'long long') -> "MCELL_STATUS":
    return _pymcell.mcell_create_viz_output(state, filename, mol_viz_list, start, end, step)
mcell_create_viz_output = _pymcell.mcell_create_viz_output

def mcell_new_viz_output_block(vizblk: 'struct viz_output_block *') -> "void":
    return _pymcell.mcell_new_viz_output_block(vizblk)
mcell_new_viz_output_block = _pymcell.mcell_new_viz_output_block

def mcell_create_viz_frame(time_type: 'int', type: 'int', iteration_list: 'num_expr_list') -> "struct frame_data_list *":
    return _pymcell.mcell_create_viz_frame(time_type, type, iteration_list)
mcell_create_viz_frame = _pymcell.mcell_create_viz_frame

def mcell_set_molecule_viz_state(vizblk: 'struct viz_output_block *', specp: 'struct species *', viz_state: 'int') -> "int":
    return _pymcell.mcell_set_molecule_viz_state(vizblk, specp, viz_state)
mcell_set_molecule_viz_state = _pymcell.mcell_set_molecule_viz_state

def mcell_add_surf_class_properties(state: 'MCELL_STATE *', reaction_type: 'int', sc_sym: 'mcell_symbol', reactant_sym: 'mcell_symbol', orient: 'short') -> "MCELL_STATUS":
    return _pymcell.mcell_add_surf_class_properties(state, reaction_type, sc_sym, reactant_sym, orient)
mcell_add_surf_class_properties = _pymcell.mcell_add_surf_class_properties

def mcell_create_surf_class(state: 'MCELL_STATE *', surf_class_name: 'char *', sc_sym: 'mcell_symbol **') -> "struct sym_entry **":
    return _pymcell.mcell_create_surf_class(state, surf_class_name, sc_sym)
mcell_create_surf_class = _pymcell.mcell_create_surf_class

def mcell_add_mol_release_to_surf_class(state: 'MCELL_STATE *', sc_sym: 'mcell_symbol', sm_info: 'mcell_species', quantity: 'double', density_or_num: 'int', smd_list: 'struct sm_dat *') -> "struct sm_dat *":
    return _pymcell.mcell_add_mol_release_to_surf_class(state, sc_sym, sm_info, quantity, density_or_num, smd_list)
mcell_add_mol_release_to_surf_class = _pymcell.mcell_add_mol_release_to_surf_class

def mcell_assign_surf_class_to_region(sc_sym: 'mcell_symbol', rgn: 'struct region *') -> "MCELL_STATUS":
    return _pymcell.mcell_assign_surf_class_to_region(sc_sym, rgn)
mcell_assign_surf_class_to_region = _pymcell.mcell_assign_surf_class_to_region

def mcell_run_simulation(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_run_simulation(state)
mcell_run_simulation = _pymcell.mcell_run_simulation

def mcell_run_n_iterations(state: 'MCELL_STATE *', output_frequency: 'long long', INPUT: 'int *', n_iter: 'int') -> "MCELL_STATUS":
    return _pymcell.mcell_run_n_iterations(state, output_frequency, INPUT, n_iter)
mcell_run_n_iterations = _pymcell.mcell_run_n_iterations

def mcell_run_iteration(state: 'MCELL_STATE *', output_frequency: 'long long', INPUT: 'int *') -> "MCELL_STATUS":
    return _pymcell.mcell_run_iteration(state, output_frequency, INPUT)
mcell_run_iteration = _pymcell.mcell_run_iteration

def mcell_flush_data(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_flush_data(state)
mcell_flush_data = _pymcell.mcell_flush_data

def mcell_print_final_warnings(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_print_final_warnings(state)
mcell_print_final_warnings = _pymcell.mcell_print_final_warnings

def mcell_print_final_statistics(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_print_final_statistics(state)
mcell_print_final_statistics = _pymcell.mcell_print_final_statistics

_pymcell.ORIENT_NOT_SET_swigconstant(_pymcell)
ORIENT_NOT_SET = _pymcell.ORIENT_NOT_SET
class object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.object_next_set
    __swig_getmethods__["next"] = _pymcell.object_next_get
    if _newclass:
        next = _swig_property(_pymcell.object_next_get, _pymcell.object_next_set)
    __swig_setmethods__["parent"] = _pymcell.object_parent_set
    __swig_getmethods__["parent"] = _pymcell.object_parent_get
    if _newclass:
        parent = _swig_property(_pymcell.object_parent_get, _pymcell.object_parent_set)
    __swig_setmethods__["first_child"] = _pymcell.object_first_child_set
    __swig_getmethods__["first_child"] = _pymcell.object_first_child_get
    if _newclass:
        first_child = _swig_property(_pymcell.object_first_child_get, _pymcell.object_first_child_set)
    __swig_setmethods__["last_child"] = _pymcell.object_last_child_set
    __swig_getmethods__["last_child"] = _pymcell.object_last_child_get
    if _newclass:
        last_child = _swig_property(_pymcell.object_last_child_get, _pymcell.object_last_child_set)
    __swig_setmethods__["sym"] = _pymcell.object_sym_set
    __swig_getmethods__["sym"] = _pymcell.object_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.object_sym_get, _pymcell.object_sym_set)
    __swig_setmethods__["last_name"] = _pymcell.object_last_name_set
    __swig_getmethods__["last_name"] = _pymcell.object_last_name_get
    if _newclass:
        last_name = _swig_property(_pymcell.object_last_name_get, _pymcell.object_last_name_set)
    __swig_setmethods__["object_type"] = _pymcell.object_object_type_set
    __swig_getmethods__["object_type"] = _pymcell.object_object_type_get
    if _newclass:
        object_type = _swig_property(_pymcell.object_object_type_get, _pymcell.object_object_type_set)
    __swig_setmethods__["contents"] = _pymcell.object_contents_set
    __swig_getmethods__["contents"] = _pymcell.object_contents_get
    if _newclass:
        contents = _swig_property(_pymcell.object_contents_get, _pymcell.object_contents_set)
    __swig_setmethods__["num_regions"] = _pymcell.object_num_regions_set
    __swig_getmethods__["num_regions"] = _pymcell.object_num_regions_get
    if _newclass:
        num_regions = _swig_property(_pymcell.object_num_regions_get, _pymcell.object_num_regions_set)
    __swig_setmethods__["regions"] = _pymcell.object_regions_set
    __swig_getmethods__["regions"] = _pymcell.object_regions_get
    if _newclass:
        regions = _swig_property(_pymcell.object_regions_get, _pymcell.object_regions_set)
    __swig_setmethods__["n_walls"] = _pymcell.object_n_walls_set
    __swig_getmethods__["n_walls"] = _pymcell.object_n_walls_get
    if _newclass:
        n_walls = _swig_property(_pymcell.object_n_walls_get, _pymcell.object_n_walls_set)
    __swig_setmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_set
    __swig_getmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_get
    if _newclass:
        n_walls_actual = _swig_property(_pymcell.object_n_walls_actual_get, _pymcell.object_n_walls_actual_set)
    __swig_setmethods__["walls"] = _pymcell.object_walls_set
    __swig_getmethods__["walls"] = _pymcell.object_walls_get
    if _newclass:
        walls = _swig_property(_pymcell.object_walls_get, _pymcell.object_walls_set)
    __swig_setmethods__["wall_p"] = _pymcell.object_wall_p_set
    __swig_getmethods__["wall_p"] = _pymcell.object_wall_p_get
    if _newclass:
        wall_p = _swig_property(_pymcell.object_wall_p_get, _pymcell.object_wall_p_set)
    __swig_setmethods__["n_verts"] = _pymcell.object_n_verts_set
    __swig_getmethods__["n_verts"] = _pymcell.object_n_verts_get
    if _newclass:
        n_verts = _swig_property(_pymcell.object_n_verts_get, _pymcell.object_n_verts_set)
    __swig_setmethods__["vertices"] = _pymcell.object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.object_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.object_vertices_get, _pymcell.object_vertices_set)
    __swig_setmethods__["total_area"] = _pymcell.object_total_area_set
    __swig_getmethods__["total_area"] = _pymcell.object_total_area_get
    if _newclass:
        total_area = _swig_property(_pymcell.object_total_area_get, _pymcell.object_total_area_set)
    __swig_setmethods__["n_tiles"] = _pymcell.object_n_tiles_set
    __swig_getmethods__["n_tiles"] = _pymcell.object_n_tiles_get
    if _newclass:
        n_tiles = _swig_property(_pymcell.object_n_tiles_get, _pymcell.object_n_tiles_set)
    __swig_setmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_set
    __swig_getmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_get
    if _newclass:
        n_occupied_tiles = _swig_property(_pymcell.object_n_occupied_tiles_get, _pymcell.object_n_occupied_tiles_set)
    __swig_setmethods__["t_matrix"] = _pymcell.object_t_matrix_set
    __swig_getmethods__["t_matrix"] = _pymcell.object_t_matrix_get
    if _newclass:
        t_matrix = _swig_property(_pymcell.object_t_matrix_get, _pymcell.object_t_matrix_set)
    __swig_setmethods__["periodic_x"] = _pymcell.object_periodic_x_set
    __swig_getmethods__["periodic_x"] = _pymcell.object_periodic_x_get
    if _newclass:
        periodic_x = _swig_property(_pymcell.object_periodic_x_get, _pymcell.object_periodic_x_set)
    __swig_setmethods__["periodic_y"] = _pymcell.object_periodic_y_set
    __swig_getmethods__["periodic_y"] = _pymcell.object_periodic_y_get
    if _newclass:
        periodic_y = _swig_property(_pymcell.object_periodic_y_get, _pymcell.object_periodic_y_set)
    __swig_setmethods__["periodic_z"] = _pymcell.object_periodic_z_set
    __swig_getmethods__["periodic_z"] = _pymcell.object_periodic_z_get
    if _newclass:
        periodic_z = _swig_property(_pymcell.object_periodic_z_get, _pymcell.object_periodic_z_set)

    def __init__(self, *args):
        """__init__(self) -> object"""
        this = _pymcell.new_object(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_object
    __del__ = lambda self: None
object_swigregister = _pymcell.object_swigregister
object_swigregister(object)


_pymcell.SHAPE_UNDEFINED_swigconstant(_pymcell)
SHAPE_UNDEFINED = _pymcell.SHAPE_UNDEFINED

_pymcell.SHAPE_SPHERICAL_swigconstant(_pymcell)
SHAPE_SPHERICAL = _pymcell.SHAPE_SPHERICAL

_pymcell.SHAPE_CUBIC_swigconstant(_pymcell)
SHAPE_CUBIC = _pymcell.SHAPE_CUBIC

_pymcell.SHAPE_ELLIPTIC_swigconstant(_pymcell)
SHAPE_ELLIPTIC = _pymcell.SHAPE_ELLIPTIC

_pymcell.SHAPE_RECTANGULAR_swigconstant(_pymcell)
SHAPE_RECTANGULAR = _pymcell.SHAPE_RECTANGULAR

_pymcell.SHAPE_SPHERICAL_SHELL_swigconstant(_pymcell)
SHAPE_SPHERICAL_SHELL = _pymcell.SHAPE_SPHERICAL_SHELL

_pymcell.SHAPE_REGION_swigconstant(_pymcell)
SHAPE_REGION = _pymcell.SHAPE_REGION

_pymcell.SHAPE_LIST_swigconstant(_pymcell)
SHAPE_LIST = _pymcell.SHAPE_LIST

_pymcell.NOTIFY_NONE_swigconstant(_pymcell)
NOTIFY_NONE = _pymcell.NOTIFY_NONE

_pymcell.NOTIFY_BRIEF_swigconstant(_pymcell)
NOTIFY_BRIEF = _pymcell.NOTIFY_BRIEF

_pymcell.NOTIFY_FULL_swigconstant(_pymcell)
NOTIFY_FULL = _pymcell.NOTIFY_FULL

_pymcell.WARN_COPE_swigconstant(_pymcell)
WARN_COPE = _pymcell.WARN_COPE

_pymcell.WARN_WARN_swigconstant(_pymcell)
WARN_WARN = _pymcell.WARN_WARN

_pymcell.WARN_ERROR_swigconstant(_pymcell)
WARN_ERROR = _pymcell.WARN_ERROR

_pymcell.FILE_UNDEFINED_swigconstant(_pymcell)
FILE_UNDEFINED = _pymcell.FILE_UNDEFINED

_pymcell.FILE_OVERWRITE_swigconstant(_pymcell)
FILE_OVERWRITE = _pymcell.FILE_OVERWRITE

_pymcell.FILE_SUBSTITUTE_swigconstant(_pymcell)
FILE_SUBSTITUTE = _pymcell.FILE_SUBSTITUTE

_pymcell.FILE_APPEND_swigconstant(_pymcell)
FILE_APPEND = _pymcell.FILE_APPEND

_pymcell.FILE_APPEND_HEADER_swigconstant(_pymcell)
FILE_APPEND_HEADER = _pymcell.FILE_APPEND_HEADER

_pymcell.FILE_CREATE_swigconstant(_pymcell)
FILE_CREATE = _pymcell.FILE_CREATE

_pymcell.REPORT_CONTENTS_swigconstant(_pymcell)
REPORT_CONTENTS = _pymcell.REPORT_CONTENTS

_pymcell.REPORT_WORLD_swigconstant(_pymcell)
REPORT_WORLD = _pymcell.REPORT_WORLD

_pymcell.REPORT_ENCLOSED_swigconstant(_pymcell)
REPORT_ENCLOSED = _pymcell.REPORT_ENCLOSED

_pymcell.REPORT_TRIGGER_swigconstant(_pymcell)
REPORT_TRIGGER = _pymcell.REPORT_TRIGGER
class release_pattern(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_pattern, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_pattern, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sym"] = _pymcell.release_pattern_sym_set
    __swig_getmethods__["sym"] = _pymcell.release_pattern_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.release_pattern_sym_get, _pymcell.release_pattern_sym_set)
    __swig_setmethods__["delay"] = _pymcell.release_pattern_delay_set
    __swig_getmethods__["delay"] = _pymcell.release_pattern_delay_get
    if _newclass:
        delay = _swig_property(_pymcell.release_pattern_delay_get, _pymcell.release_pattern_delay_set)
    __swig_setmethods__["release_interval"] = _pymcell.release_pattern_release_interval_set
    __swig_getmethods__["release_interval"] = _pymcell.release_pattern_release_interval_get
    if _newclass:
        release_interval = _swig_property(_pymcell.release_pattern_release_interval_get, _pymcell.release_pattern_release_interval_set)
    __swig_setmethods__["train_interval"] = _pymcell.release_pattern_train_interval_set
    __swig_getmethods__["train_interval"] = _pymcell.release_pattern_train_interval_get
    if _newclass:
        train_interval = _swig_property(_pymcell.release_pattern_train_interval_get, _pymcell.release_pattern_train_interval_set)
    __swig_setmethods__["train_duration"] = _pymcell.release_pattern_train_duration_set
    __swig_getmethods__["train_duration"] = _pymcell.release_pattern_train_duration_get
    if _newclass:
        train_duration = _swig_property(_pymcell.release_pattern_train_duration_get, _pymcell.release_pattern_train_duration_set)
    __swig_setmethods__["number_of_trains"] = _pymcell.release_pattern_number_of_trains_set
    __swig_getmethods__["number_of_trains"] = _pymcell.release_pattern_number_of_trains_get
    if _newclass:
        number_of_trains = _swig_property(_pymcell.release_pattern_number_of_trains_get, _pymcell.release_pattern_number_of_trains_set)

    def __init__(self, *args):
        """__init__(self) -> release_pattern"""
        this = _pymcell.new_release_pattern(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_pattern
    __del__ = lambda self: None
release_pattern_swigregister = _pymcell.release_pattern_swigregister
release_pattern_swigregister(release_pattern)

class release_evaluator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_evaluator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_evaluator, name)
    __repr__ = _swig_repr
    __swig_setmethods__["op"] = _pymcell.release_evaluator_op_set
    __swig_getmethods__["op"] = _pymcell.release_evaluator_op_get
    if _newclass:
        op = _swig_property(_pymcell.release_evaluator_op_get, _pymcell.release_evaluator_op_set)
    __swig_setmethods__["left"] = _pymcell.release_evaluator_left_set
    __swig_getmethods__["left"] = _pymcell.release_evaluator_left_get
    if _newclass:
        left = _swig_property(_pymcell.release_evaluator_left_get, _pymcell.release_evaluator_left_set)
    __swig_setmethods__["right"] = _pymcell.release_evaluator_right_set
    __swig_getmethods__["right"] = _pymcell.release_evaluator_right_get
    if _newclass:
        right = _swig_property(_pymcell.release_evaluator_right_get, _pymcell.release_evaluator_right_set)

    def __init__(self, *args):
        """__init__(self) -> release_evaluator"""
        this = _pymcell.new_release_evaluator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_evaluator
    __del__ = lambda self: None
release_evaluator_swigregister = _pymcell.release_evaluator_swigregister
release_evaluator_swigregister(release_evaluator)

class output_set(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.output_set_next_set
    __swig_getmethods__["next"] = _pymcell.output_set_next_get
    if _newclass:
        next = _swig_property(_pymcell.output_set_next_get, _pymcell.output_set_next_set)
    __swig_setmethods__["block"] = _pymcell.output_set_block_set
    __swig_getmethods__["block"] = _pymcell.output_set_block_get
    if _newclass:
        block = _swig_property(_pymcell.output_set_block_get, _pymcell.output_set_block_set)
    __swig_setmethods__["outfile_name"] = _pymcell.output_set_outfile_name_set
    __swig_getmethods__["outfile_name"] = _pymcell.output_set_outfile_name_get
    if _newclass:
        outfile_name = _swig_property(_pymcell.output_set_outfile_name_get, _pymcell.output_set_outfile_name_set)
    __swig_setmethods__["file_flags"] = _pymcell.output_set_file_flags_set
    __swig_getmethods__["file_flags"] = _pymcell.output_set_file_flags_get
    if _newclass:
        file_flags = _swig_property(_pymcell.output_set_file_flags_get, _pymcell.output_set_file_flags_set)
    __swig_setmethods__["chunk_count"] = _pymcell.output_set_chunk_count_set
    __swig_getmethods__["chunk_count"] = _pymcell.output_set_chunk_count_get
    if _newclass:
        chunk_count = _swig_property(_pymcell.output_set_chunk_count_get, _pymcell.output_set_chunk_count_set)
    __swig_setmethods__["header_comment"] = _pymcell.output_set_header_comment_set
    __swig_getmethods__["header_comment"] = _pymcell.output_set_header_comment_get
    if _newclass:
        header_comment = _swig_property(_pymcell.output_set_header_comment_get, _pymcell.output_set_header_comment_set)
    __swig_setmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_set
    __swig_getmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_get
    if _newclass:
        exact_time_flag = _swig_property(_pymcell.output_set_exact_time_flag_get, _pymcell.output_set_exact_time_flag_set)
    __swig_setmethods__["column_head"] = _pymcell.output_set_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_set_column_head_get
    if _newclass:
        column_head = _swig_property(_pymcell.output_set_column_head_get, _pymcell.output_set_column_head_set)

    def __init__(self, *args):
        """__init__(self) -> output_set"""
        this = _pymcell.new_output_set(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_set
    __del__ = lambda self: None
output_set_swigregister = _pymcell.output_set_swigregister
output_set_swigregister(output_set)


_pymcell.OUTPUT_BY_STEP_swigconstant(_pymcell)
OUTPUT_BY_STEP = _pymcell.OUTPUT_BY_STEP

_pymcell.OUTPUT_BY_TIME_LIST_swigconstant(_pymcell)
OUTPUT_BY_TIME_LIST = _pymcell.OUTPUT_BY_TIME_LIST

_pymcell.OUTPUT_BY_ITERATION_LIST_swigconstant(_pymcell)
OUTPUT_BY_ITERATION_LIST = _pymcell.OUTPUT_BY_ITERATION_LIST
class sym_table_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["entries"] = _pymcell.sym_table_head_entries_set
    __swig_getmethods__["entries"] = _pymcell.sym_table_head_entries_get
    if _newclass:
        entries = _swig_property(_pymcell.sym_table_head_entries_get, _pymcell.sym_table_head_entries_set)
    __swig_setmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_set
    __swig_getmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_get
    if _newclass:
        n_entries = _swig_property(_pymcell.sym_table_head_n_entries_get, _pymcell.sym_table_head_n_entries_set)
    __swig_setmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_set
    __swig_getmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_get
    if _newclass:
        n_bins = _swig_property(_pymcell.sym_table_head_n_bins_get, _pymcell.sym_table_head_n_bins_set)

    def __init__(self, *args):
        """__init__(self) -> sym_table_head"""
        this = _pymcell.new_sym_table_head(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_head
    __del__ = lambda self: None
sym_table_head_swigregister = _pymcell.sym_table_head_swigregister
sym_table_head_swigregister(sym_table_head)

class sym_entry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_entry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_entry, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_entry_next_set
    __swig_getmethods__["next"] = _pymcell.sym_entry_next_get
    if _newclass:
        next = _swig_property(_pymcell.sym_entry_next_get, _pymcell.sym_entry_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.sym_entry_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.sym_entry_sym_type_get
    if _newclass:
        sym_type = _swig_property(_pymcell.sym_entry_sym_type_get, _pymcell.sym_entry_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.sym_entry_name_set
    __swig_getmethods__["name"] = _pymcell.sym_entry_name_get
    if _newclass:
        name = _swig_property(_pymcell.sym_entry_name_get, _pymcell.sym_entry_name_set)
    __swig_setmethods__["value"] = _pymcell.sym_entry_value_set
    __swig_getmethods__["value"] = _pymcell.sym_entry_value_get
    if _newclass:
        value = _swig_property(_pymcell.sym_entry_value_get, _pymcell.sym_entry_value_set)

    def __init__(self, *args):
        """__init__(self) -> sym_entry"""
        this = _pymcell.new_sym_entry(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_entry
    __del__ = lambda self: None
sym_entry_swigregister = _pymcell.sym_entry_swigregister
sym_entry_swigregister(sym_entry)

class sym_table_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_table_list_next_set
    __swig_getmethods__["next"] = _pymcell.sym_table_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.sym_table_list_next_get, _pymcell.sym_table_list_next_set)
    __swig_setmethods__["node"] = _pymcell.sym_table_list_node_set
    __swig_getmethods__["node"] = _pymcell.sym_table_list_node_get
    if _newclass:
        node = _swig_property(_pymcell.sym_table_list_node_get, _pymcell.sym_table_list_node_set)

    def __init__(self, *args):
        """__init__(self) -> sym_table_list"""
        this = _pymcell.new_sym_table_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_list
    __del__ = lambda self: None
sym_table_list_swigregister = _pymcell.sym_table_list_swigregister
sym_table_list_swigregister(sym_table_list)

class num_expr_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_expr_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_expr_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.num_expr_list_next_set
    __swig_getmethods__["next"] = _pymcell.num_expr_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.num_expr_list_next_get, _pymcell.num_expr_list_next_set)
    __swig_setmethods__["value"] = _pymcell.num_expr_list_value_set
    __swig_getmethods__["value"] = _pymcell.num_expr_list_value_get
    if _newclass:
        value = _swig_property(_pymcell.num_expr_list_value_get, _pymcell.num_expr_list_value_set)

    def __init__(self, *args):
        """__init__(self) -> num_expr_list"""
        this = _pymcell.new_num_expr_list(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_num_expr_list
    __del__ = lambda self: None
num_expr_list_swigregister = _pymcell.num_expr_list_swigregister
num_expr_list_swigregister(num_expr_list)

class mesh_region_string_buffs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mesh_region_string_buffs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mesh_region_string_buffs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["old_inst_mesh_names"] = _pymcell.mesh_region_string_buffs_old_inst_mesh_names_set
    __swig_getmethods__["old_inst_mesh_names"] = _pymcell.mesh_region_string_buffs_old_inst_mesh_names_get
    if _newclass:
        old_inst_mesh_names = _swig_property(_pymcell.mesh_region_string_buffs_old_inst_mesh_names_get, _pymcell.mesh_region_string_buffs_old_inst_mesh_names_set)
    __swig_setmethods__["old_region_names"] = _pymcell.mesh_region_string_buffs_old_region_names_set
    __swig_getmethods__["old_region_names"] = _pymcell.mesh_region_string_buffs_old_region_names_get
    if _newclass:
        old_region_names = _swig_property(_pymcell.mesh_region_string_buffs_old_region_names_get, _pymcell.mesh_region_string_buffs_old_region_names_set)

    def __init__(self, *args):
        """__init__(self) -> mesh_region_string_buffs"""
        this = _pymcell.new_mesh_region_string_buffs(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mesh_region_string_buffs
    __del__ = lambda self: None
mesh_region_string_buffs_swigregister = _pymcell.mesh_region_string_buffs_swigregister
mesh_region_string_buffs_swigregister(mesh_region_string_buffs)


def mcell_change_geometry(state: 'struct volume *', pobj_list: 'poly_object_list') -> "int":
    return _pymcell.mcell_change_geometry(state, pobj_list)
mcell_change_geometry = _pymcell.mcell_change_geometry
class vector2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector2, name)
    __repr__ = _swig_repr
    __swig_setmethods__["u"] = _pymcell.vector2_u_set
    __swig_getmethods__["u"] = _pymcell.vector2_u_get
    if _newclass:
        u = _swig_property(_pymcell.vector2_u_get, _pymcell.vector2_u_set)
    __swig_setmethods__["v"] = _pymcell.vector2_v_set
    __swig_getmethods__["v"] = _pymcell.vector2_v_get
    if _newclass:
        v = _swig_property(_pymcell.vector2_v_get, _pymcell.vector2_v_set)

    def __init__(self, *args):
        """__init__(self) -> vector2"""
        this = _pymcell.new_vector2(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_vector2
    __del__ = lambda self: None
vector2_swigregister = _pymcell.vector2_swigregister
vector2_swigregister(vector2)

class vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pymcell.vector3_x_set
    __swig_getmethods__["x"] = _pymcell.vector3_x_get
    if _newclass:
        x = _swig_property(_pymcell.vector3_x_get, _pymcell.vector3_x_set)
    __swig_setmethods__["y"] = _pymcell.vector3_y_set
    __swig_getmethods__["y"] = _pymcell.vector3_y_get
    if _newclass:
        y = _swig_property(_pymcell.vector3_y_get, _pymcell.vector3_y_set)
    __swig_setmethods__["z"] = _pymcell.vector3_z_set
    __swig_getmethods__["z"] = _pymcell.vector3_z_get
    if _newclass:
        z = _swig_property(_pymcell.vector3_z_get, _pymcell.vector3_z_set)

    def __init__(self, *args):
        """__init__(self) -> vector3"""
        this = _pymcell.new_vector3(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_vector3
    __del__ = lambda self: None
vector3_swigregister = _pymcell.vector3_swigregister
vector3_swigregister(vector3)


def mult_matrix(m1: 'double (*)[4]', m2: 'double (*)[4]', om: 'double (*)[4]', l: 'unsigned short', m: 'unsigned short', n: 'unsigned short') -> "void":
    return _pymcell.mult_matrix(m1, m2, om, l, m, n)
mult_matrix = _pymcell.mult_matrix

def normalize(v: 'vector3') -> "void":
    return _pymcell.normalize(v)
normalize = _pymcell.normalize

def init_matrix(im: 'double (*)[4]') -> "void":
    return _pymcell.init_matrix(im)
init_matrix = _pymcell.init_matrix

def scale_matrix(im: 'double (*)[4]', om: 'double (*)[4]', scale: 'vector3') -> "void":
    return _pymcell.scale_matrix(im, om, scale)
scale_matrix = _pymcell.scale_matrix

def translate_matrix(im: 'double (*)[4]', om: 'double (*)[4]', translate: 'vector3') -> "void":
    return _pymcell.translate_matrix(im, om, translate)
translate_matrix = _pymcell.translate_matrix

def rotate_matrix(im: 'double (*)[4]', om: 'double (*)[4]', axis: 'vector3', angle: 'double') -> "void":
    return _pymcell.rotate_matrix(im, om, axis, angle)
rotate_matrix = _pymcell.rotate_matrix

def tform_matrix(scale: 'vector3', translate: 'vector3', axis: 'vector3', angle: 'double', om: 'double (*)[4]') -> "void":
    return _pymcell.tform_matrix(scale, translate, axis, angle, om)
tform_matrix = _pymcell.tform_matrix

def vectorize(p1: 'vector3', p2: 'vector3', v: 'vector3') -> "void":
    return _pymcell.vectorize(p1, p2, v)
vectorize = _pymcell.vectorize

def vect_length(v: 'vector3') -> "double":
    return _pymcell.vect_length(v)
vect_length = _pymcell.vect_length

def dot_prod(v1: 'vector3', v2: 'vector3') -> "double":
    return _pymcell.dot_prod(v1, v2)
dot_prod = _pymcell.dot_prod

def cross_prod(v1: 'vector3', v2: 'vector3', v3: 'vector3') -> "void":
    return _pymcell.cross_prod(v1, v2, v3)
cross_prod = _pymcell.cross_prod

def vect_sum(v1: 'vector3', v2: 'vector3', v3: 'vector3') -> "void":
    return _pymcell.vect_sum(v1, v2, v3)
vect_sum = _pymcell.vect_sum

def scalar_prod(v1: 'vector3', a: 'double', result: 'vector3') -> "void":
    return _pymcell.scalar_prod(v1, a, result)
scalar_prod = _pymcell.scalar_prod

def distinguishable_vec3(a: 'vector3', b: 'vector3', eps: 'double') -> "int":
    return _pymcell.distinguishable_vec3(a, b, eps)
distinguishable_vec3 = _pymcell.distinguishable_vec3

def distinguishable_vec2(a: 'vector2', b: 'vector2', eps: 'double') -> "int":
    return _pymcell.distinguishable_vec2(a, b, eps)
distinguishable_vec2 = _pymcell.distinguishable_vec2

def distance_vec3(a: 'vector3', b: 'vector3') -> "double":
    return _pymcell.distance_vec3(a, b)
distance_vec3 = _pymcell.distance_vec3

def parallel_segments(A: 'vector3', B: 'vector3', R: 'vector3', S: 'vector3') -> "int":
    return _pymcell.parallel_segments(A, B, R, S)
parallel_segments = _pymcell.parallel_segments

def point_in_triangle(p: 'vector3', a: 'vector3', b: 'vector3', c: 'vector3') -> "int":
    return _pymcell.point_in_triangle(p, a, b, c)
point_in_triangle = _pymcell.point_in_triangle

def same_side(p1: 'vector3', p2: 'vector3', a: 'vector3', b: 'vector3') -> "int":
    return _pymcell.same_side(p1, p2, a, b)
same_side = _pymcell.same_side

def intersect_point_segment(P: 'vector3', A: 'vector3', B: 'vector3') -> "int":
    return _pymcell.intersect_point_segment(P, A, B)
intersect_point_segment = _pymcell.intersect_point_segment

def cross2D(a: 'vector2', b: 'vector2') -> "double":
    return _pymcell.cross2D(a, b)
cross2D = _pymcell.cross2D

def vectorize2D(p1: 'vector2', p2: 'vector2', p3: 'vector2') -> "void":
    return _pymcell.vectorize2D(p1, p2, p3)
vectorize2D = _pymcell.vectorize2D

def point_in_triangle_2D(p: 'vector2', a: 'vector2', b: 'vector2', c: 'vector2') -> "int":
    return _pymcell.point_in_triangle_2D(p, a, b, c)
point_in_triangle_2D = _pymcell.point_in_triangle_2D

def point_in_box(low_left: 'vector3', up_right: 'vector3', point: 'vector3') -> "int":
    return _pymcell.point_in_box(low_left, up_right, point)
point_in_box = _pymcell.point_in_box
# This file is compatible with both classic and new-style classes.


