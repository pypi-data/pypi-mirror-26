#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Nov  2 13:12:45 2017 by generateDS.py version 2.28b.
# Python 3.5.2 (default, Sep 14 2017, 22:51:06)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('-o', 'nfelib/v4_00/leiauteNFe.py')
#
# Command line arguments:
#   schemas/v4_00/leiauteNFe_v4.00.xsd
#
# Command line:
#   /home/rvalyi/DEV/generateds/generateDS.py -o "nfelib/v4_00/leiauteNFe.py" schemas/v4_00/leiauteNFe_v4.00.xsd
#
# Current working directory (os.getcwd()):
#   nfelib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#


try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values

        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')

        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values

        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()

        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            return None

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            if not isinstance(self, type(other)):
                return False
            return self.__dict__ == other.__dict__

        def __ne__(self, other):
            return not self.__eq__(other)

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
# ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
# exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))

    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None, complex=0, _help=""):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
        self.complex = complex
        self._help = _help

    def set_name(self, name): self.name = name

    def get_name(self): return self.name

    def set_data_type(self, data_type): self.data_type = data_type

    def get_data_type_chain(self): return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def get_primary_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[0]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container): self.container = container

    def get_container(self): return self.container

    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs

    def get_child_attrs(self): return self.child_attrs

    def set_choice(self, choice): self.choice = choice

    def get_choice(self): return self.choice

    def set_optional(self, optional): self.optional = optional

    def get_optional(self): return self.optional

    def get_complex(self): return self.complex

    def get_help(self): return self._help


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


SimpleTypes = {
    "dFab": """ Tipo data AAAA-MM-DD""",
    "condVeic": """Condição do veículo (1 - acabado; 2 - inacabado; 3 - semi-acabado)""",
    "finNFe": """Tipo Finalidade da NF-e (1=Normal; 2=Complementar; 3=Ajuste; 4=Devolução/Retorno)""",
    "cStat": """Tipo Código da Mensagem enviada""",
    "ref": """Mês e Ano de Referência, formato: MM/AAAA""",
    "xCor": """Descrição da cor""",
    "serie": """Tipo Série do Documento Fiscal """,
    "vICMSOp": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vFrete": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "modFrete": """Modalidade do frete
0- Contratação do Frete por conta do Remetente (CIF);
1- Contratação do Frete por conta do destinatário/remetente (FOB);
2- Contratação do Frete por conta de terceiros;
3- Transporte próprio por conta do remetente;
4- Transporte próprio por conta do destinatário;
9- Sem Ocorrência de transporte.""",
    "vDesc": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "UFST": """Tipo Sigla da UF""",
    "qTotAnt": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "cilin": """Capacidade voluntária do motor expressa em centímetros cúbicos (CC). (cilindradas)""",
    "verAplic": """Tipo Versão do Aplicativo""",
    "nBomba": """Numero de identificação da bomba ao qual o bico está interligado""",
    "pST": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "balsa": """Identificação da balsa (v2.0)""",
    "dhCont": """Data e Hora, formato UTC (AAAA-MM-DDThh:mm:ssTZD, onde TZD = +hh:mm ou -hh:mm)""",
    "vFCPST": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pIPI": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "dhRecbto": """Data e Hora, formato UTC (AAAA-MM-DDThh:mm:ssTZD, onde TZD = +hh:mm ou -hh:mm)""",
    "nDI": """Numero do Documento de Importação DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E) (NT2011/004)""",
    "CNAE": """CNAE Fiscal""",
    "vSeg": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "nVol": """Numeração dos volumes transportados""",
    "nSerie": """Serial (série)""",
    "indSinc": """Indicador de processamento síncrono. 0=NÃO; 1=SIM=Síncrono""",
    "vBCFCP": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vPIS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "vBCIRRF": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "cSelo": """Código do selo de controle do IPI""",
    "pICMSInter": """Alíquota interestadual das UF envolvidas: - 4% alíquota interestadual para produtos importados; - 7% para os Estados de origem do Sul e Sudeste (exceto ES), destinado para os Estados do Norte e Nordeste  ou ES; - 12% para os demais casos.""",
    "vAliq": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "uCom": """Unidade comercial""",
    "tpArma": """Indicador do tipo de arma de fogo (0 - Uso permitido; 1 - Uso restrito)""",
    "anoMod": """Ano Modelo de Fabricação""",
    "pDevol": """Tipo Decimal com 3 inteiros (no máximo 100), com 2 decimais""",
    "vPag": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "dDesemb": """ Tipo data AAAA-MM-DD""",
    "vBCST": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "CRT": """Código de Regime Tributário.
Este campo será obrigatoriamente preenchido com:
1 – Simples Nacional;
2 – Simples Nacional – excesso de sublimite de receita bruta;
3 – Regime Normal.""",
    "vNF": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "refNFe": """Tipo Chave da Nota Fiscal Eletrônica""",
    "pRedBCST": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "verProc": """versão do aplicativo utilizado no processo de
emissão""",
    "cMod": """Código Marca Modelo (utilizar tabela RENAVAM)""",
    "cEAN": """GTIN (Global Trade Item Number) do produto, antigo código EAN ou código de barras""",
    "nDAR": """Número do Documento de Arrecadação de Receita""",
    "safra": """Identificação da safra""",
    "vICMS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "AAMM": """AAMM da emissão""",
    "CEP": """CEP""",
    "nCano": """Número de série do cano""",
    "vISSQN": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "qTemp": """Tipo Decimal com 12 inteiros, 1 a 4 decimais""",
    "procEmi": """Tipo processo de emissão da NF-e""",
    "CSOSN": """101- Tributada pelo Simples Nacional com permissão de crédito. (v.2.0)""",
    "dDI": """ Tipo data AAAA-MM-DD""",
    "cUF": """Tipo Código da UF da tabela do IBGE""",
    "tpIntermedio": """Forma de Importação quanto a intermediação
																	1-por conta propria;2-por conta e ordem;3-encomenda""",
    "tpEmis": """Forma de emissão da NF-e
1 - Normal;
2 - Contingência FS
3 - Contingência SCAN
4 - Contingência DPEC
5 - Contingência FSDA
6 - Contingência SVC - AN
7 - Contingência SVC - RS
9 - Contingência off-line NFC-e""",
    "pCOFINS": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "dEmi": """ Tipo data AAAA-MM-DD""",
    "xNEmp": """Informação da Nota de Empenho de compras públicas (NT2011/004)""",
    "xEnder": """Endereço completo""",
    "tpViaTransp": """Via de transporte internacional informada na DI
																	1-Maritima;2-Fluvial;3-Lacustre;4-Aerea;5-Postal;6-Ferroviaria;7-Rodoviaria;8-Conduto;9-Meios Proprios;10-Entrada/Saida Ficta.""",
    "nProt": """Tipo Número do Protocolo de Status""",
    "nRE": """Registro de exportação""",
    "xAgente": """Nome do agente""",
    "indIEDest": """Indicador da IE do destinatário:
1 – Contribuinte ICMSpagamento à vista;
2 – Contribuinte isento de inscrição;
9 – Não Contribuinte""",
    "xMsg": """Mensagem da SEFAZ para o emissor. (v2.0)""",
    "UFDesemb": """Tipo Sigla da UF de emissor // acrescentado em 24/10/08 """,
    "ISUF": """Inscrição na SUFRAMA (Obrigatório nas operações com as áreas com benefícios de incentivos fiscais sob controle da SUFRAMA) PL_005d - 11/08/09 - alterado para aceitar 8 ou 9 dígitos""",
    "xDed": """Descrição da Dedução""",
    "nItemPed": """Número do Item do Pedido de Compra - Identificação do número do item do pedido de Compra""",
    "infCpl": """Informações complementares de interesse do Contribuinte""",
    "cMun": """Tipo Código do Município da tabela do IBGE""",
    "indISS": """Exibilidade do ISS:1-Exigível;2-Não incidente;3-Isenção;4-Exportação;5-Imunidade;6-Exig.Susp. Judicial;7-Exig.Susp. ADM""",
    "xProd": """Descrição do produto ou serviço""",
    "pBCOp": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "vIOF": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pesoL": """Tipo Decimal com 12 inteiros, podendo ter  3 decimais""",
    "tPag": """Forma de Pagamento:01-Dinheiro;02-Cheque;03-Cartão de Crédito;04-Cartão de Débito;05-Crédito Loja;10-Vale Alimentação;11-Vale Refeição;12-Vale Presente;13-Vale Combustível;14 - Duplicata Mercantil;15 - Boleto Bancario;90 - Sem Pagamento;99 - Outros""",
    "cPais": """Código de Pais""",
    "qSelo": """Quantidade de selo de controle do IPI""",
    "pRedBC": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "vII": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "tpOp": """Tipo da Operação (1 - Venda concessionária; 2 - Faturamento direto; 3 - Venda direta; 0 - Outros)""",
    "vDed": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "nTanque": """Numero de identificação do tanque ao qual o bico está interligado""",
    "IM": """Inscrição Municipal""",
    "indProc": """Origem do processo, informar com:
0 - SEFAZ;
1 - Justiça Federal;
2 - Justiça Estadual;
3 - Secex/RFB;
9 - Outros""",
    "cFabricante": """Código do fabricante estrangeiro (usado nos sistemas internos de informação do emitente da NF-e)""",
    "cEANTrib": """GTIN (Global Trade Item Number) da unidade tributável, antigo código EAN ou código de barras""",
    "vDeducao": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "tpPint": """Tipo de pintura""",
    "qLote": """Tipo Decimal com 8 inteiros, podendo ter de 1 até 3 decimais""",
    "cMunFG": """Tipo Código do Município da tabela do IBGE""",
    "vISSRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "cExportador": """Código do exportador (usado nos sistemas internos de informação do emitente da NF-e)""",
    "pFCPSTRet": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "vRetCOFINS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "tMed": """ Tipo temp médio em segundos""",
    "cAgreg": """""",
    "vIPIDevol": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "tpComb": """Tipo de combustível-Tabela RENAVAM: 01-Álcool; 02-Gasolina; 03-Diesel; 16-Álcool/Gas.; 17-Gas./Álcool/GNV; 18-Gasolina/Elétrico""",
    "xPed": """pedido de compra - Informação de interesse do emissor para controle do B2B.""",
    "pICMS": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "vICMSRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pPIS": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "pICMSRet": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "pFCP": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "vCIDE": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "IEST": """Tipo Inscrição Estadual do ST // acrescentado EM 24/10/08""",
    "xPais": """Nome do país""",
    "vBCFCPUFDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "xCont": """Informação do contrato""",
    "matr": """Matrícula do agente""",
    "vRetCSLL": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "vICMSSTDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vBCSTDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vProd": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pDif": """Tipo Decimal com 3 inteiros (no máximo 100), com até 4 decimais""",
    "vIPI": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "nDraw": """Número do ato concessório de Drawback""",
    "marca": """Marca dos volumes transportados""",
    "nLacre": """Número dos Lacres""",
    "pICMSInterPart": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "refCTe": """Tipo Chave da Nota Fiscal Eletrônica""",
    "nSeqAdic": """Número seqüencial do item dentro da Adição""",
    "pFCPST": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "xCpl": """Complemento""",
    "nFCI": """Identificador único (Globally Unique Identifier)""",
    "cCor": """Cor do veículo (código de cada montadora)""",
    "vFor": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "EXTIPI": """Código EX TIPI (3 posições)""",
    "vBCRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "dPag": """ Tipo data AAAA-MM-DD""",
    "CMT": """CMT-Capacidade Máxima de Tração - em Toneladas 4 casas decimais""",
    "vagao": """Identificação do vagão (v2.0)""",
    "cServico": """Código do serviço prestado dentro do município""",
    "xTexto": """""",
    "vDescDI": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "cProdANP": """Código de produto da ANP. codificação de produtos do SIMP (http://www.anp.gov.br)""",
    "cNF": """Código numérico que compõe a Chave de Acesso. Número aleatório gerado pelo emitente para cada NF-e.""",
    "vBC": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "qUnid": """Tipo Decimal com 12 inteiros de 1 até 4 decimais""",
    "CEST": """Codigo especificador da Substuicao Tributaria - CEST, que identifica a mercadoria sujeita aos regimes de  substituicao tributária e de antecipação do recolhimento  do imposto""",
    "cCorDENATRAN": """Código da Cor Segundo as regras de pré-cadastro do DENATRAN: 01-AMARELO;02-AZUL;03-BEGE;04-BRANCA;05-CINZA;06-DOURADA;07-GRENA
08-LARANJA;09-MARROM;10-PRATA;11-PRETA;12-ROSA;13-ROXA;14-VERDE;15-VERMELHA;16-FANTASIA""",
    "dhSaiEnt": """Data e Hora, formato UTC (AAAA-MM-DDThh:mm:ssTZD, onde TZD = +hh:mm ou -hh:mm)""",
    "xFant": """Nome fantasia""",
    "digVal": """Digest Value da NF-e processada. Utilizado para conferir a integridade da NF-e original.""",
    "vFCPSTRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vDescIncond": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "vOutro": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "nBico": """Numero de identificação do Bico utilizado no abastecimento""",
    "descANP": """Descrição do Produto conforme ANP. Utilizar a descrição de produtos do Sistema de Informações de Movimentação de Produtos - SIMP (http://www.anp.gov.br/simp/).""",
    "cRegTrib": """Código do regime especial de tributação""",
    "vRetPIS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "uTrib": """Unidade Tributável""",
    "CFOP": """Cfop""",
    "nProcesso": """Número do Processo administrativo ou judicial de suspenção do processo""",
    "esp": """Espécie dos volumes transportados""",
    "vDup": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "chassi": """Chassi do veículo - VIN (código-identificação-veículo)""",
    "urlChave": """Informar a URL da "Consulta por chave de acesso da NFC-e". A mesma URL que deve estar informada no DANFE NFC-e para consulta por chave de acesso.""",
    "qtde": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "UFTerceiro": """Tipo Sigla da UF de emissor // acrescentado em 24/10/08 """,
    "modBC": """Modalidade de determinação da BC do ICMS:
0 - Margem Valor Agregado (%);
1 - Pauta (valor);
2 - Preço Tabelado Máximo (valor);
3 - Valor da Operação.""",
    "xJust": """Informar a Justificativa da entrada""",
    "vBCFCPST": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "UF": """Tipo Sigla da UF""",
    "cMsg": """Código da Mensagem (v2.0)
alterado para tamanho variavel 1-4. (NT2011/004)""",
    "vUnCom": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "qBCProd": """Tipo Decimal com 12 inteiros e 4 decimais""",
    "infAdFisco": """Informações adicionais de interesse do Fisco (v2.0)""",
    "tpRest": """Restrição
0 - Não há;
1 - Alienação Fiduciária;
2 - Arrendamento Mercantil;
3 - Reserva de Domínio;
4 - Penhor de Veículos;
9 - outras.""",
    "nRec": """Tipo Número do Recibo do envio de lote de NF-e""",
    "DigestValue": """""",
    "vUnid": """Tipo Decimal com 11 inteiros, podendo ter 4 decimais""",
    "qTotGer": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "qrCode": """Texto com o QR-Code impresso no DANFE NFC-e""",
    "pFCPUFDest": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "vICMSST": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "fone": """Telefone, preencher com Código DDD + número do telefone , nas operações com exterior é permtido informar o código do país + código da localidade + número do telefone""",
    "nro": """Número""",
    "CNPJProd": """Tipo Número do CNPJ""",
    "tpIntegra": """Tipo de Integração do processo de pagamento com o sistema de automação da empresa/
																1=Pagamento integrado com o sistema de automação da empresa Ex. equipamento TEF , Comercio Eletronico
																2=Pagamento não integrado com o sistema de automação da empresa Ex: equipamento POS""",
    "qTrib": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 4 decimais""",
    "xLocDespacho": """Descrição do local de despacho""",
    "natOp": """Descrição da Natureza da Operação""",
    "xLocDesemb": """Local do desembaraço aduaneiro""",
    "dVal": """ Tipo data AAAA-MM-DD""",
    "vCredICMSSN": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "xMun": """Nome do município, informar EXTERIOR para operações com o exterior.""",
    "CODIF": """Código de autorização / registro do CODIF. Informar apenas quando a UF utilizar o CODIF (Sistema de Controle do 			Diferimento do Imposto nas Operações com AEAC - Álcool Etílico Anidro Combustível).""",
    "tpAmb": """Tipo Ambiente""",
    "dCompet": """ Tipo data AAAA-MM-DD""",
    "vRetPrev": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "motDesICMS": """Motivo da desoneração do ICMS:3-Uso na agropecuária;9-Outros;12-Fomento agropecuário""",
    "VIN": """Informa-se o veículo tem VIN (chassi) remarcado.
R-Remarcado
N-NormalVIN""",
    "idEstrangeiro": """Identificador do destinatário, em caso de comprador estrangeiro""",
    "clEnq": """Classe de Enquadramento do IPI para Cigarros e Bebidas""",
    "vServ": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pGLP": """Tipo Decimal com 3 inteiros (no máximo 100), com até 4 decimais""",
    "xNome": """Razão Social ou Nome do emitente""",
    "dhEmi": """Data e Hora, formato UTC (AAAA-MM-DDThh:mm:ssTZD, onde TZD = +hh:mm ou -hh:mm)""",
    "vST": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "CST": """Tributção pelo ICMS
00 - Tributada integralmente""",
    "vLiq": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "tpVeic": """Tipo de veículo (utilizar tabela RENAVAM)""",
    "NVE": """Nomenclatura de Valor aduaneio e Estatístico""",
    "qVol": """Quantidade de volumes transportados""",
    "modBCST": """Modalidade de determinação da BC do ICMS ST:
0 – Preço tabelado ou máximo  sugerido;
1 - Lista Negativa (valor);
2 - Lista Positiva (valor);
3 - Lista Neutra (valor);
4 - Margem Valor Agregado (%);
5 - Pauta (valor);""",
    "xMotivo": """Tipo Motivo""",
    "cDV": """Digito Verificador da Chave de Acesso da NF-e""",
    "nCOO": """Informar o Número do Contador de Ordem de Operação - COO vinculado à NF-e""",
    "RNTC": """Registro Nacional de Transportador de Carga (ANTT)""",
    "vICMSDif": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vDescCond": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "cEnq": """Código de Enquadramento Legal do IPI (tabela a ser criada pela RFB)""",
    "vUnTrib": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "vICMSUFDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "tBand": """Bandeira da operadora de cartão de crédito/débito:01–Visa; 02–Mastercard; 03–American Express; 04–Sorocred;05-Diners Club;06-Elo;07-Hipercard;08-Aura;09-Cabal;99–Outros""",
    "cListServ": """Tipo Código da Lista de Serviços LC 116/2003""",
    "infAdProd": """Informações adicionais do produto (norma referenciada, informações complementares, etc)""",
    "pICMSST": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "nAdicao": """Número da Adição""",
    "vFCP": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vIRRF": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "email": """Informar o e-mail do destinatário. O campo pode ser utilizado para informar o e-mail
de recepção da NF-e indicada pelo destinatário""",
    "indFinal": """Indica operação com consumidor final (0-Não;1-Consumidor Final)""",
    "vFCPUFDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "nFat": """Número da fatura""",
    "idDest": """Identificador de Local de destino da operação (1-Interna;2-Interestadual;3-Exterior)""",
    "nLote": """Número do lote do produto.""",
    "vBCSTRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vDAR": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vEncIni": """Tipo Decimal com 12 inteiros, podendo ter  3 decimais""",
    "orig": """Tipo Origem da mercadoria CST ICMS  origem da mercadoria: 0-Nacional exceto as indicadas nos códigos 3, 4, 5 e 8;
1-Estrangeira - Importação direta; 2-Estrangeira - Adquirida no mercado interno; 3-Nacional, conteudo superior 40% e inferior ou igual a 70%; 4-Nacional, processos produtivos básicos; 5-Nacional, conteudo inferior 40%; 6-Estrangeira - Importação direta, com similar nacional, lista CAMEX; 7-Estrangeira - mercado interno, sem simular,lista CAMEX;8-Nacional, Conteúdo de Importação superior a 70%.""",
    "qExport": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 4 decimais""",
    "tpNF": """Tipo do Documento Fiscal (0 - entrada; 1 - saída)""",
    "placa": """Placa do veículo (NT2011/004)""",
    "indTot": """Este campo deverá ser preenchido com:
 0 – o valor do item (vProd) não compõe o valor total da NF-e (vProd)
 1  – o valor do item (vProd) compõe o valor total da NF-e (vProd)""",
    "xOrgao": """Órgão emitente""",
    "vEncFin": """Tipo Decimal com 12 inteiros, podendo ter  3 decimais""",
    "vOrig": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "CNPJ": """Tipo Número do CNPJ""",
    "chNFe": """Tipo Chave da Nota Fiscal Eletrônica""",
    "vICMSSTRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vTotTrib": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "cBenef": """""",
    "vBCUFDest": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "indPres": """Indicador de presença do comprador no estabelecimento comercial no momento da oepração
											(0-Não se aplica (ex.: Nota Fiscal complementar ou de ajuste;1-Operação presencial;2-Não presencial, internet;3-Não presencial, teleatendimento;4-NFC-e entrega em domicílio;5-Operação presencial, fora do estabelecimento;9-Não presencial, outros)""",
    "cProdANVISA": """Código de Produto da ANVISA. Utilizar o número do registro do produto da Câmara de Regulação do Mercado de Medicamento – CMED.""",
    "pGNi": """Tipo Decimal com 3 inteiros (no máximo 100), com até 4 decimais""",
    "xLocExporta": """Local de Embarque ou de transposição de fronteira""",
    "xBairro": """Bairro""",
    "UFSaidaPais": """Tipo Sigla da UF de emissor // acrescentado em 24/10/08 """,
    "vBCRetPrev": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "vISS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "dVenc": """ Tipo data AAAA-MM-DD""",
    "tpImp": """Formato de impressão do DANFE (0-sem DANFE;1-DANFe Retrato; 2-DANFe Paisagem;3-DANFe Simplificado;
											4-DANFe NFC-e;5-DANFe NFC-e em mensagem eletrônica)""",
    "vAFRMM": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "repEmi": """Repartição Fiscal emitente""",
    "vPMC": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "lota": """Quantidade máxima de permitida de passageiros sentados, inclusive motorista.""",
    "nProc": """Indentificador do processo ou ato
concessório""",
    "pMVAST": """Tipo Decimal com até 3 dígitos inteiros e 2 até 4 decimais. Utilizados em TAGs opcionais, não aceita valor zero.""",
    "vPart": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "pICMSUFDest": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "cProd": """Código do produto ou serviço. Preencher com CFOP caso se trate de itens não relacionados com mercadorias/produto e que o contribuinte não possua codificação própria
Formato ”CFOP9999”.""",
    "vLiqFor": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vTroco": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "vICMSDeson": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "descr": """Descrição completa da arma, compreendendo: calibre, marca, capacidade, tipo de funcionamento, comprimento e demais elementos que permitam a sua perfeita identificação.""",
    "NCM": """Código NCM (8 posições), será permitida a informação do gênero (posição do capítulo do NCM) quando a operação não for de comércio exterior (importação/exportação) ou o produto não seja tributado pelo IPI. Em caso de item de serviço ou item que não tenham produto (Ex. transferência de crédito, crédito do ativo imobilizado, etc.), informar o código 00 (zeros) (v2.0)""",
    "nECF": """Informar o número de ordem seqüencial do ECF que emitiu o Cupom Fiscal vinculado à NF-e""",
    "dist": """Distância entre eixos""",
    "pesoB": """Tipo Decimal com 12 inteiros, podendo ter  3 decimais""",
    "vDespAdu": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "qCom": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 4 decimais""",
    "cAut": """Número de autorização da operação cartão de crédito/débito""",
    "mod": """Código do modelo do Documento Fiscal. 55 = NF-e; 65 = NFC-e.""",
    "qTotMes": """Tipo Decimal com 11 inteiros, podendo ter de 1 até 10 decimais""",
    "CNPJFab": """Tipo Número do CNPJ""",
    "IE": """Tipo Inscrição Estadual do Destinatário // alterado para aceitar vazio ou ISENTO - maio/2010 v2.0""",
    "nDup": """Número da duplicata""",
    "vAliqProd": """Tipo Decimal com 11 inteiros, podendo ter 4 decimais""",
    "pCredSN": """Tipo Decimal com até 3 dígitos inteiros, podendo ter de 2 até 4 decimais""",
    "vICMSUFRemet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "xLgr": """Logradouro""",
    "pot": """Potência máxima do motor do veículo em cavalo vapor (CV). (potência-veículo)""",
    "nMotor": """Número do motor""",
    "espVeic": """Espécie de veículo (utilizar tabela RENAVAM)""",
    "idLote": """ Tipo Identificação de Lote""",
    "indIncentivo": """Indicador de Incentivo Fiscal. 1=Sim; 2=Não""",
    "vTotDed": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "UFCons": """Tipo Sigla da UF""",
    "anoFab": """Ano de Fabricação""",
    "pGNn": """Tipo Decimal com 3 inteiros (no máximo 100), com até 4 decimais""",
    "vCOFINS": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais""",
    "vBCFCPSTRet": """Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais""",
    "CPF": """Tipo Número do CPF""",
    "indEscala": """""",
    "nRECOPI": """Número do RECOPI""",
    "nNF": """Tipo Número do Documento Fiscal""",
}


STEnumerations = {
    "indISS": ['1', '2', '3', '4', '5', '6', '7'],
    "condVeic": ['1', '2', '3'],
    "finNFe": ['1', '2', '3', '4'],
    "idDest": ['1', '2', '3'],
    "tPag": ['01', '02', '03', '04', '05', '10', '11', '12', '13', '14', '15', '90', '99'],
    "cPais": ['1058'],
    "indProc": ['0', '1', '2', '3', '9'],
    "motDesICMS": ['3', '9', '12'],
    "orig": ['0', '1', '2', '3', '4', '5', '6', '7', '8'],
    "CST": ['01', '02', '03', '04', '05', '51', '52', '53', '54', '55'],
    "pICMSInter": ['4.00', '7.00', '12.00'],
    "tpNF": ['0', '1'],
    "UFTerceiro": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'],
    "indTot": ['0', '1'],
    "indFinal": ['0', '1'],
    "modBC": ['0', '1', '2', '3'],
    "UF": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX'],
    "UFST": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX'],
    "cRegTrib": ['1', '2', '3', '4', '5', '6'],
    "indPres": ['0', '1', '2', '3', '4', '5', '9'],
    "indEscala": ['S', 'N'],
    "tpViaTransp": ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    "indSinc": ['0', '1'],
    "tpRest": ['0', '1', '2', '3', '4', '9'],
    "UFSaidaPais": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'],
    "tpImp": ['0', '1', '2', '3', '4', '5'],
    "tpAmb": ['1', '2'],
    "xPais": ['Brasil', 'BRASIL'],
    "tpArma": ['0', '1'],
    "tpOp": ['0', '1', '2', '3'],
    "CRT": ['1', '2', '3'],
    "VIN": ['R', 'N'],
    "mod": ['2B', '2C', '2D'],
    "modFrete": ['0', '1', '2', '3', '4', '9'],
    "tpIntegra": ['1', '2'],
    "modBCST": ['0', '1', '2', '3', '4', '5'],
    "procEmi": ['0', '1', '2', '3'],
    "CSOSN": ['900'],
    "tBand": ['01', '02', '03', '04', '05', '06', '07', '08', '09', '99'],
    "cUF": ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53'],
    "tpIntermedio": ['1', '2', '3'],
    "tpEmis": ['1', '2', '3', '4', '5', '6', '7', '9'],
    "indIncentivo": ['1', '2'],
    "UFCons": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX'],
    "indIEDest": ['1', '2', '9'],
    "cListServ": ['01.01', '01.02', '01.03', '01.04', '01.05', '01.06', '01.07', '01.08', '02.01', '03.02', '03.03', '03.04', '03.05', '04.01', '04.02', '04.03', '04.04', '04.05', '04.06', '04.07', '04.08', '04.09', '04.10', '04.11', '04.12', '04.13', '04.14', '04.15', '04.16', '04.17', '04.18', '04.19', '04.20', '04.21', '04.22', '04.23', '05.01', '05.02', '05.03', '05.04', '05.05', '05.06', '05.07', '05.08', '05.09', '06.01', '06.02', '06.03', '06.04', '06.05', '07.01', '07.02', '07.03', '07.04', '07.05', '07.06', '07.07', '07.08', '07.09', '07.10', '07.11', '07.12', '07.13', '07.16', '07.17', '07.18', '07.19', '07.20', '07.21', '07.22', '08.01', '08.02', '09.01', '09.02', '09.03', '10.01', '10.02', '10.03', '10.04', '10.05', '10.06', '10.07', '10.08', '10.09', '10.10', '11.01', '11.02', '11.03', '11.04', '12.01', '12.02', '12.03', '12.04', '12.05', '12.06', '12.07', '12.08', '12.09', '12.10', '12.11', '12.12', '12.13', '12.14', '12.15', '12.16', '12.17', '13.02', '13.03', '13.04', '13.05', '14.01', '14.02', '14.03', '14.04', '14.05', '14.06', '14.07', '14.08', '14.09', '14.10', '14.11', '14.12', '14.13', '15.01', '15.02', '15.03', '15.04', '15.05', '15.06', '15.07', '15.08', '15.09', '15.10', '15.11', '15.12', '15.13', '15.14', '15.15', '15.16', '15.17', '15.18', '16.01', '17.01', '17.02', '17.03', '17.04', '17.05', '17.06', '17.08', '17.09', '17.10', '17.11', '17.12', '17.13', '17.14', '17.15', '17.16', '17.17', '17.18', '17.19', '17.20', '17.21', '17.22', '17.23', '17.24', '18.01', '19.01', '20.01', '20.02', '20.03', '21.01', '22.01', '23.01', '24.01', '25.01', '25.02', '25.03', '25.04', '26.01', '27.01', '28.01', '29.01', '30.01', '31.01', '32.01', '33.01', '34.01', '35.01', '36.01', '37.01', '38.01', '39.01', '40.01'],
    "UFDesemb": ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'],
}


AutoMany2ones = {
    "TVeiculo": "transp",
    "obsCont": "infAdic",
    "forDia": "cana",
    "DI": "prod",
    "autXML": "infNFe",
    "Transform": "Transforms",
    "dup": "cobr",
    "TNFe": "TEnviNFe",
    "obsFisco": "infAdic",
    "procRef": "infAdic",
    "lacres": "vol",
    "det": "infNFe",
    "TProtNFe": "TRetConsReciNFe",
    "detExport": "prod",
    "vol": "transp",
    "deduc": "cana",
    "NFref": "ide",
    "detPag": "pag",
    "arma": "prod",
    "adi": "DI",
    "rastro": "prod",
}


class TNFe(GeneratedsSuper):
    """Tipo Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None

    def __init__(self, infNFe=None, infNFeSupl=None, Signature=None):
        self.original_tagname_ = None
        self.infNFe = infNFe
        self.infNFeSupl = infNFeSupl
        self.Signature = Signature

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNFe.subclass:
            return TNFe.subclass(*args_, **kwargs_)
        else:
            return TNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_infNFe(self): return self.infNFe

    def set_infNFe(self, infNFe): self.infNFe = infNFe

    def get_infNFeSupl(self): return self.infNFeSupl

    def set_infNFeSupl(self, infNFeSupl): self.infNFeSupl = infNFeSupl

    def get_Signature(self): return self.Signature

    def set_Signature(self, Signature): self.Signature = Signature

    def hasContent_(self):
        if (
            self.infNFe is not None or
            self.infNFeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TNFe'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infNFe is not None:
            self.infNFe.export(
                outfile,
                level,
                namespace_,
                name_='infNFe',
                pretty_print=pretty_print)
        if self.infNFeSupl is not None:
            self.infNFeSupl.export(
                outfile,
                level,
                namespace_,
                name_='infNFeSupl',
                pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(
                outfile,
                level,
                namespace_='ds:',
                name_='Signature',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNFe':
            obj_ = infNFeType.factory()
            obj_.build(child_)
            self.infNFe = obj_
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infNFeSupl':
            obj_ = infNFeSuplType.factory()
            obj_.build(child_)
            self.infNFeSupl = obj_
            obj_.original_tagname_ = 'infNFeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TNFe


class TProtNFe(GeneratedsSuper):
    """Tipo Protocolo de status resultado do processamento da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, infProt=None, Signature=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.infProt = infProt
        self.Signature = Signature

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtNFe.subclass:
            return TProtNFe.subclass(*args_, **kwargs_)
        else:
            return TProtNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_infProt(self): return self.infProt

    def set_infProt(self, infProt): self.infProt = infProt

    def get_Signature(self): return self.Signature

    def set_Signature(self, Signature): self.Signature = Signature

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.infProt is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TProtNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TProtNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TProtNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TProtNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TProtNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            self.infProt.export(
                outfile,
                level,
                namespace_,
                name_='infProt',
                pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(
                outfile,
                level,
                namespace_='ds:',
                name_='Signature',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infProt':
            obj_ = infProtType.factory()
            obj_.build(child_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtNFe


class TEnviNFe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, idLote=None, indSinc=None, NFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.indSinc = indSinc
        self.validate_indSincType(self.indSinc)
        if NFe is None:
            self.NFe = []
        else:
            self.NFe = NFe

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviNFe.subclass:
            return TEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_idLote(self): return self.idLote

    def set_idLote(self, idLote): self.idLote = idLote

    def get_indSinc(self): return self.indSinc

    def set_indSinc(self, indSinc): self.indSinc = indSinc

    def get_NFe(self): return self.NFe

    def set_NFe(self, NFe): self.NFe = NFe

    def add_NFe(self, value): self.NFe.append(value)

    def insert_NFe_at(self, index, value): self.NFe.insert(index, value)

    def replace_NFe_at(self, index, value): self.NFe[index] = value

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TIdLote_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIdLote_patterns_, ))
    validate_TIdLote_patterns_ = [['^[0-9]{1,15}$']]

    def validate_indSincType(self, value):
        # Validate type indSincType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indSincType' % {
        "value": value.encode("utf-8")})

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.idLote is not None or
            self.indSinc is not None or
            self.NFe
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TEnviNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TEnviNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sidLote>%s</%sidLote>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.idLote),
            input_name='idLote')),
                    namespace_,
                    eol_))
        if self.indSinc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindSinc>%s</%sindSinc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indSinc),
            input_name='indSinc')),
                    namespace_,
                    eol_))
        for NFe_ in self.NFe:
            NFe_.export(
                outfile,
                level,
                namespace_,
                name_='NFe',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'indSinc':
            indSinc_ = child_.text
            indSinc_ = self.gds_validate_string(indSinc_, node, 'indSinc')
            self.indSinc = indSinc_
            # validate type indSincType
            self.validate_indSincType(self.indSinc)
        elif nodeName_ == 'NFe':
            obj_ = TNFe.factory()
            obj_.build(child_)
            self.NFe.append(obj_)
            obj_.original_tagname_ = 'NFe'
# end class TEnviNFe


class TRetEnviNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, tpAmb=None, verAplic=None, cStat=None,
                 xMotivo=None, cUF=None, dhRecbto=None, infRec=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.infRec = infRec
        self.protNFe = protNFe

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviNFe.subclass:
            return TRetEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpAmb(self): return self.tpAmb

    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb

    def get_verAplic(self): return self.verAplic

    def set_verAplic(self, verAplic): self.verAplic = verAplic

    def get_cStat(self): return self.cStat

    def set_cStat(self, cStat): self.cStat = cStat

    def get_xMotivo(self): return self.xMotivo

    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo

    def get_cUF(self): return self.cUF

    def set_cUF(self, cUF): self.cUF = cUF

    def get_dhRecbto(self): return self.dhRecbto

    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto

    def get_infRec(self): return self.infRec

    def set_infRec(self, infRec): self.infRec = infRec

    def get_protNFe(self): return self.protNFe

    def set_protNFe(self, protNFe): self.protNFe = protNFe

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {
        "value": value.encode("utf-8")})

    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TStat' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]

    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '11',
                '12',
                '13',
                '14',
                '15',
                '16',
                '17',
                '21',
                '22',
                '23',
                '24',
                '25',
                '26',
                '27',
                '28',
                '29',
                '31',
                '32',
                '33',
                '35',
                '41',
                '42',
                '43',
                '50',
                '51',
                '52',
                '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {
        "value": value.encode("utf-8")})

    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.infRec is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TRetEnviNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TRetEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TRetEnviNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TRetEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TRetEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpAmb>%s</%stpAmb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpAmb),
            input_name='tpAmb')),
                    namespace_,
                    eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sverAplic>%s</%sverAplic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.verAplic),
            input_name='verAplic')),
                    namespace_,
                    eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scStat>%s</%scStat>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cStat),
            input_name='cStat')),
                    namespace_,
                    eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMotivo>%s</%sxMotivo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMotivo),
            input_name='xMotivo')),
                    namespace_,
                    eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scUF>%s</%scUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cUF),
            input_name='cUF')),
                    namespace_,
                    eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhRecbto>%s</%sdhRecbto>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhRecbto),
            input_name='dhRecbto')),
                    namespace_,
                    eol_))
        if self.infRec is not None:
            self.infRec.export(
                outfile,
                level,
                namespace_,
                name_='infRec',
                pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(
                outfile,
                level,
                namespace_,
                name_='protNFe',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'infRec':
            obj_ = infRecType.factory()
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TRetEnviNFe


class TConsReciNFe(GeneratedsSuper):
    """Tipo Pedido de Consulta do Recido do Lote de Notas Fiscais
    Eletrônicas"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, tpAmb=None, nRec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.nRec = nRec
        self.validate_TRec(self.nRec)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TConsReciNFe.subclass:
            return TConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpAmb(self): return self.tpAmb

    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb

    def get_nRec(self): return self.nRec

    def set_nRec(self, nRec): self.nRec = nRec

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {
        "value": value.encode("utf-8")})

    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TRec' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.nRec is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TConsReciNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TConsReciNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpAmb>%s</%stpAmb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpAmb),
            input_name='tpAmb')),
                    namespace_,
                    eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snRec>%s</%snRec>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nRec),
            input_name='nRec')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
# end class TConsReciNFe


class TRetConsReciNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Consulta do Recido do Lote de Notas
    Fiscais Eletrônicas"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, tpAmb=None, verAplic=None, nRec=None, cStat=None,
                 xMotivo=None, cUF=None, dhRecbto=None, cMsg=None, xMsg=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.cMsg = cMsg
        self.validate_cMsgType(self.cMsg)
        self.xMsg = xMsg
        self.validate_xMsgType(self.xMsg)
        if protNFe is None:
            self.protNFe = []
        else:
            self.protNFe = protNFe

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetConsReciNFe.subclass:
            return TRetConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TRetConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpAmb(self): return self.tpAmb

    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb

    def get_verAplic(self): return self.verAplic

    def set_verAplic(self, verAplic): self.verAplic = verAplic

    def get_nRec(self): return self.nRec

    def set_nRec(self, nRec): self.nRec = nRec

    def get_cStat(self): return self.cStat

    def set_cStat(self, cStat): self.cStat = cStat

    def get_xMotivo(self): return self.xMotivo

    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo

    def get_cUF(self): return self.cUF

    def set_cUF(self, cUF): self.cUF = cUF

    def get_dhRecbto(self): return self.dhRecbto

    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto

    def get_cMsg(self): return self.cMsg

    def set_cMsg(self, cMsg): self.cMsg = cMsg

    def get_xMsg(self): return self.xMsg

    def set_xMsg(self, xMsg): self.xMsg = xMsg

    def get_protNFe(self): return self.protNFe

    def set_protNFe(self, protNFe): self.protNFe = protNFe

    def add_protNFe(self, value): self.protNFe.append(value)

    def insert_protNFe_at(
        self,
        index,
        value): self.protNFe.insert(
        index,
        value)

    def replace_protNFe_at(self, index, value): self.protNFe[index] = value

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {
        "value": value.encode("utf-8")})

    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TRec' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]

    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TStat' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]

    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '11',
                '12',
                '13',
                '14',
                '15',
                '16',
                '17',
                '21',
                '22',
                '23',
                '24',
                '25',
                '26',
                '27',
                '28',
                '29',
                '31',
                '32',
                '33',
                '35',
                '41',
                '42',
                '43',
                '50',
                '51',
                '52',
                '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {
        "value": value.encode("utf-8")})

    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]

    def validate_cMsgType(self, value):
        # Validate type cMsgType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cMsgType_patterns_, ))
    validate_cMsgType_patterns_ = [['^[0-9]{1,4}$']]

    def validate_xMsgType(self, value):
        # Validate type xMsgType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 200:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xMsgType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xMsgType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xMsgType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xMsgType_patterns_, ))
    validate_xMsgType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.nRec is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.cMsg is not None or
            self.xMsg is not None or
            self.protNFe
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TRetConsReciNFe',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TRetConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TRetConsReciNFe',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TRetConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TRetConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpAmb>%s</%stpAmb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpAmb),
            input_name='tpAmb')),
                    namespace_,
                    eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sverAplic>%s</%sverAplic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.verAplic),
            input_name='verAplic')),
                    namespace_,
                    eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snRec>%s</%snRec>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nRec),
            input_name='nRec')),
                    namespace_,
                    eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scStat>%s</%scStat>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cStat),
            input_name='cStat')),
                    namespace_,
                    eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMotivo>%s</%sxMotivo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMotivo),
            input_name='xMotivo')),
                    namespace_,
                    eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scUF>%s</%scUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cUF),
            input_name='cUF')),
                    namespace_,
                    eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhRecbto>%s</%sdhRecbto>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhRecbto),
            input_name='dhRecbto')),
                    namespace_,
                    eol_))
        if self.cMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMsg>%s</%scMsg>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMsg),
            input_name='cMsg')),
                    namespace_,
                    eol_))
        if self.xMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMsg>%s</%sxMsg>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMsg),
            input_name='xMsg')),
                    namespace_,
                    eol_))
        for protNFe_ in self.protNFe:
            protNFe_.export(
                outfile,
                level,
                namespace_,
                name_='protNFe',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'cMsg':
            cMsg_ = child_.text
            cMsg_ = self.gds_validate_string(cMsg_, node, 'cMsg')
            self.cMsg = cMsg_
            # validate type cMsgType
            self.validate_cMsgType(self.cMsg)
        elif nodeName_ == 'xMsg':
            xMsg_ = child_.text
            xMsg_ = self.gds_validate_string(xMsg_, node, 'xMsg')
            self.xMsg = xMsg_
            # validate type xMsgType
            self.validate_xMsgType(self.xMsg)
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe.append(obj_)
            obj_.original_tagname_ = 'protNFe'
# end class TRetConsReciNFe


class TNfeProc(GeneratedsSuper):
    """Tipo da NF-e processada"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, NFe=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.NFe = NFe
        self.protNFe = protNFe

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNfeProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNfeProc.subclass:
            return TNfeProc.subclass(*args_, **kwargs_)
        else:
            return TNfeProc(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_NFe(self): return self.NFe

    def set_NFe(self, NFe): self.NFe = NFe

    def get_protNFe(self): return self.protNFe

    def set_protNFe(self, protNFe): self.protNFe = protNFe

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.NFe is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TNfeProc',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNfeProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TNfeProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TNfeProc',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TNfeProc'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TNfeProc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NFe is not None:
            self.NFe.export(
                outfile,
                level,
                namespace_,
                name_='NFe',
                pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(
                outfile,
                level,
                namespace_,
                name_='protNFe',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NFe':
            obj_ = TNFe.factory()
            obj_.build(child_)
            self.NFe = obj_
            obj_.original_tagname_ = 'NFe'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TNfeProc


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço // 24/10/08 - tamanho mínimo"""
    subclass = None
    superclass = None

    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None,
                 xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType(self.xLgr)
        self.nro = nro
        self.validate_nroType(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType53(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.CEP = CEP
        self.validate_CEPType(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType54(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType(self.xPais)
        self.fone = fone
        self.validate_foneType55(self.fone)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xLgr(self): return self.xLgr

    def set_xLgr(self, xLgr): self.xLgr = xLgr

    def get_nro(self): return self.nro

    def set_nro(self, nro): self.nro = nro

    def get_xCpl(self): return self.xCpl

    def set_xCpl(self, xCpl): self.xCpl = xCpl

    def get_xBairro(self): return self.xBairro

    def set_xBairro(self, xBairro): self.xBairro = xBairro

    def get_cMun(self): return self.cMun

    def set_cMun(self, cMun): self.cMun = cMun

    def get_xMun(self): return self.xMun

    def set_xMun(self, xMun): self.xMun = xMun

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def get_CEP(self): return self.CEP

    def set_CEP(self, CEP): self.CEP = CEP

    def get_cPais(self): return self.cPais

    def set_cPais(self, cPais): self.cPais = cPais

    def get_xPais(self): return self.xPais

    def set_xPais(self, xPais): self.xPais = xPais

    def get_fone(self): return self.fone

    def set_fone(self, fone): self.fone = fone

    def validate_xLgrType(self, value):
        # Validate type xLgrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLgrType' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLgrType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLgrType_patterns_, ))
    validate_xLgrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nroType(self, value):
        # Validate type nroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nroType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nroType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nroType_patterns_, ))
    validate_nroType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xCplType(self, value):
        # Validate type xCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xCplType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xCplType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xCplType_patterns_, ))
    validate_xCplType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xBairroType(self, value):
        # Validate type xBairroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xBairroType' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xBairroType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xBairroType_patterns_, ))
    validate_xBairroType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def validate_xMunType53(self, value):
        # Validate type xMunType53, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xMunType53' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xMunType53' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType53_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xMunType53_patterns_, ))
    validate_xMunType53_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def validate_CEPType(self, value):
        # Validate type CEPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CEPType_patterns_, ))
    validate_CEPType_patterns_ = [['^[0-9]{8}$']]

    def validate_cPaisType54(self, value):
        # Validate type cPaisType54, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType54_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cPaisType54_patterns_, ))
    validate_cPaisType54_patterns_ = [['^[0-9]{1,4}$']]

    def validate_xPaisType(self, value):
        # Validate type xPaisType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xPaisType' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xPaisType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xPaisType_patterns_, ))
    validate_xPaisType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_foneType55(self, value):
        # Validate type foneType55, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType55_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_foneType55_patterns_, ))
    validate_foneType55_patterns_ = [['^[0-9]{6,14}$']]

    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TEndereco',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TEndereco',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TEndereco'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLgr>%s</%sxLgr>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLgr),
            input_name='xLgr')),
                    namespace_,
                    eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snro>%s</%snro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nro),
            input_name='nro')),
                    namespace_,
                    eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxCpl>%s</%sxCpl>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xCpl),
            input_name='xCpl')),
                    namespace_,
                    eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxBairro>%s</%sxBairro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xBairro),
            input_name='xBairro')),
                    namespace_,
                    eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMun>%s</%scMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMun),
            input_name='cMun')),
                    namespace_,
                    eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMun>%s</%sxMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMun),
            input_name='xMun')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCEP>%s</%sCEP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CEP),
            input_name='CEP')),
                    namespace_,
                    eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scPais>%s</%scPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cPais),
            input_name='cPais')),
                    namespace_,
                    eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxPais>%s</%sxPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xPais),
            input_name='xPais')),
                    namespace_,
                    eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sfone>%s</%sfone>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.fone),
            input_name='fone')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType
            self.validate_xLgrType(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType
            self.validate_nroType(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType
            self.validate_xCplType(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType
            self.validate_xBairroType(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType53
            self.validate_xMunType53(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType
            self.validate_CEPType(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType54
            self.validate_cPaisType54(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType
            self.validate_xPaisType(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType55
            self.validate_foneType55(self.fone)
# end class TEndereco


class TEnderEmi(GeneratedsSuper):
    """Tipo Dados do Endereço do Emitente // 24/10/08 - desmembrado /
    tamanho mínimo"""
    subclass = None
    superclass = None

    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None,
                 xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType56(self.xLgr)
        self.nro = nro
        self.validate_nroType57(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType58(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType59(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType60(self.xMun)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.CEP = CEP
        self.validate_CEPType61(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType62(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType63(self.xPais)
        self.fone = fone
        self.validate_foneType64(self.fone)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnderEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnderEmi.subclass:
            return TEnderEmi.subclass(*args_, **kwargs_)
        else:
            return TEnderEmi(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xLgr(self): return self.xLgr

    def set_xLgr(self, xLgr): self.xLgr = xLgr

    def get_nro(self): return self.nro

    def set_nro(self, nro): self.nro = nro

    def get_xCpl(self): return self.xCpl

    def set_xCpl(self, xCpl): self.xCpl = xCpl

    def get_xBairro(self): return self.xBairro

    def set_xBairro(self, xBairro): self.xBairro = xBairro

    def get_cMun(self): return self.cMun

    def set_cMun(self, cMun): self.cMun = cMun

    def get_xMun(self): return self.xMun

    def set_xMun(self, xMun): self.xMun = xMun

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def get_CEP(self): return self.CEP

    def set_CEP(self, CEP): self.CEP = CEP

    def get_cPais(self): return self.cPais

    def set_cPais(self, cPais): self.cPais = cPais

    def get_xPais(self): return self.xPais

    def set_xPais(self, xPais): self.xPais = xPais

    def get_fone(self): return self.fone

    def set_fone(self, fone): self.fone = fone

    def validate_xLgrType56(self, value):
        # Validate type xLgrType56, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLgrType56' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLgrType56' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType56_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLgrType56_patterns_, ))
    validate_xLgrType56_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nroType57(self, value):
        # Validate type nroType57, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nroType57' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nroType57' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType57_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nroType57_patterns_, ))
    validate_nroType57_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xCplType58(self, value):
        # Validate type xCplType58, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xCplType58' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xCplType58' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType58_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xCplType58_patterns_, ))
    validate_xCplType58_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xBairroType59(self, value):
        # Validate type xBairroType59, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xBairroType59' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xBairroType59' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType59_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xBairroType59_patterns_, ))
    validate_xBairroType59_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def validate_xMunType60(self, value):
        # Validate type xMunType60, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xMunType60' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xMunType60' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType60_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xMunType60_patterns_, ))
    validate_xMunType60_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {
        "value": value.encode("utf-8")})

    def validate_CEPType61(self, value):
        # Validate type CEPType61, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType61_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CEPType61_patterns_, ))
    validate_CEPType61_patterns_ = [['^[0-9]{8}$']]

    def validate_cPaisType62(self, value):
        # Validate type cPaisType62, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1058']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on cPaisType62' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType62_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cPaisType62_patterns_, ))
    validate_cPaisType62_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xPaisType63(self, value):
        # Validate type xPaisType63, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Brasil', 'BRASIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on xPaisType63' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType63_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xPaisType63_patterns_, ))
    validate_xPaisType63_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_foneType64(self, value):
        # Validate type foneType64, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType64_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_foneType64_patterns_, ))
    validate_foneType64_patterns_ = [['^[0-9]{6,14}$']]

    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TEnderEmi',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnderEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TEnderEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TEnderEmi',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TEnderEmi'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TEnderEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLgr>%s</%sxLgr>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLgr),
            input_name='xLgr')),
                    namespace_,
                    eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snro>%s</%snro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nro),
            input_name='nro')),
                    namespace_,
                    eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxCpl>%s</%sxCpl>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xCpl),
            input_name='xCpl')),
                    namespace_,
                    eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxBairro>%s</%sxBairro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xBairro),
            input_name='xBairro')),
                    namespace_,
                    eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMun>%s</%scMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMun),
            input_name='cMun')),
                    namespace_,
                    eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMun>%s</%sxMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMun),
            input_name='xMun')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCEP>%s</%sCEP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CEP),
            input_name='CEP')),
                    namespace_,
                    eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scPais>%s</%scPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cPais),
            input_name='cPais')),
                    namespace_,
                    eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxPais>%s</%sxPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xPais),
            input_name='xPais')),
                    namespace_,
                    eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sfone>%s</%sfone>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.fone),
            input_name='fone')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType56
            self.validate_xLgrType56(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType57
            self.validate_nroType57(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType58
            self.validate_xCplType58(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType59
            self.validate_xBairroType59(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType60
            self.validate_xMunType60(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType61
            self.validate_CEPType61(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType62
            self.validate_cPaisType62(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType63
            self.validate_xPaisType63(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType64
            self.validate_foneType64(self.fone)
# end class TEnderEmi


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega // 24/10/08 - tamanho
    mínimo // v2.0"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, CPF=None, xLgr=None, nro=None,
                 xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xLgr = xLgr
        self.validate_xLgrType65(self.xLgr)
        self.nro = nro
        self.validate_nroType66(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType67(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType68(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType69(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def get_xLgr(self): return self.xLgr

    def set_xLgr(self, xLgr): self.xLgr = xLgr

    def get_nro(self): return self.nro

    def set_nro(self, nro): self.nro = nro

    def get_xCpl(self): return self.xCpl

    def set_xCpl(self, xCpl): self.xCpl = xCpl

    def get_xBairro(self): return self.xBairro

    def set_xBairro(self, xBairro): self.xBairro = xBairro

    def get_cMun(self): return self.cMun

    def set_cMun(self, cMun): self.cMun = cMun

    def get_xMun(self): return self.xMun

    def set_xMun(self, xMun): self.xMun = xMun

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpjOpc' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [['^[0-9]{0}$|^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def validate_xLgrType65(self, value):
        # Validate type xLgrType65, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLgrType65' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLgrType65' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType65_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLgrType65_patterns_, ))
    validate_xLgrType65_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nroType66(self, value):
        # Validate type nroType66, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nroType66' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nroType66' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType66_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nroType66_patterns_, ))
    validate_nroType66_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xCplType67(self, value):
        # Validate type xCplType67, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xCplType67' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xCplType67' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType67_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xCplType67_patterns_, ))
    validate_xCplType67_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xBairroType68(self, value):
        # Validate type xBairroType68, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xBairroType68' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xBairroType68' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType68_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xBairroType68_patterns_, ))
    validate_xBairroType68_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def validate_xMunType69(self, value):
        # Validate type xMunType69, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xMunType69' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xMunType69' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType69_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xMunType69_patterns_, ))
    validate_xMunType69_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TLocal',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TLocal',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TLocal'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLgr>%s</%sxLgr>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLgr),
            input_name='xLgr')),
                    namespace_,
                    eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snro>%s</%snro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nro),
            input_name='nro')),
                    namespace_,
                    eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxCpl>%s</%sxCpl>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xCpl),
            input_name='xCpl')),
                    namespace_,
                    eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxBairro>%s</%sxBairro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xBairro),
            input_name='xBairro')),
                    namespace_,
                    eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMun>%s</%scMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMun),
            input_name='cMun')),
                    namespace_,
                    eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMun>%s</%sxMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMun),
            input_name='xMun')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType65
            self.validate_xLgrType65(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType66
            self.validate_nroType66(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType67
            self.validate_xCplType67(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType68
            self.validate_xBairroType68(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType69
            self.validate_xMunType69(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TLocal


class TVeiculo(GeneratedsSuper):
    """Tipo Dados do Veículo"""
    subclass = None
    superclass = None

    def __init__(self, placa=None, UF=None, RNTC=None):
        self.original_tagname_ = None
        self.placa = placa
        self.validate_placaType(self.placa)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.RNTC = RNTC
        self.validate_RNTCType(self.RNTC)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TVeiculo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TVeiculo.subclass:
            return TVeiculo.subclass(*args_, **kwargs_)
        else:
            return TVeiculo(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_placa(self): return self.placa

    def set_placa(self, placa): self.placa = placa

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def get_RNTC(self): return self.RNTC

    def set_RNTC(self, RNTC): self.RNTC = RNTC

    def validate_placaType(self, value):
        # Validate type placaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_placaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_placaType_patterns_, ))
    validate_placaType_patterns_ = [
        ['^[A-Z]{2,3}[0-9]{4}$|^[A-Z]{3,4}[0-9]{3}$']]

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def validate_RNTCType(self, value):
        # Validate type RNTCType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on RNTCType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on RNTCType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_RNTCType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_RNTCType_patterns_, ))
    validate_RNTCType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.placa is not None or
            self.UF is not None or
            self.RNTC is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TVeiculo',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TVeiculo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TVeiculo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TVeiculo',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TVeiculo'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TVeiculo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%splaca>%s</%splaca>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.placa),
            input_name='placa')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))
        if self.RNTC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sRNTC>%s</%sRNTC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.RNTC),
            input_name='RNTC')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placa':
            placa_ = child_.text
            placa_ = self.gds_validate_string(placa_, node, 'placa')
            self.placa = placa_
            # validate type placaType
            self.validate_placaType(self.placa)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'RNTC':
            RNTC_ = child_.text
            RNTC_ = self.gds_validate_string(RNTC_, node, 'RNTC')
            self.RNTC = RNTC_
            # validate type RNTCType
            self.validate_RNTCType(self.RNTC)
# end class TVeiculo


class TIpi(GeneratedsSuper):
    """Tipo: Dados do IPI"""
    subclass = None
    superclass = None

    def __init__(self, clEnq=None, CNPJProd=None, cSelo=None,
                 qSelo=None, cEnq=None, IPITrib=None, IPINT=None):
        self.original_tagname_ = None
        self.clEnq = clEnq
        self.validate_clEnqType(self.clEnq)
        self.CNPJProd = CNPJProd
        self.validate_TCnpj(self.CNPJProd)
        self.cSelo = cSelo
        self.validate_cSeloType(self.cSelo)
        self.qSelo = qSelo
        self.validate_qSeloType(self.qSelo)
        self.cEnq = cEnq
        self.validate_cEnqType(self.cEnq)
        self.IPITrib = IPITrib
        self.IPINT = IPINT

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIpi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIpi.subclass:
            return TIpi.subclass(*args_, **kwargs_)
        else:
            return TIpi(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_clEnq(self): return self.clEnq

    def set_clEnq(self, clEnq): self.clEnq = clEnq

    def get_CNPJProd(self): return self.CNPJProd

    def set_CNPJProd(self, CNPJProd): self.CNPJProd = CNPJProd

    def get_cSelo(self): return self.cSelo

    def set_cSelo(self, cSelo): self.cSelo = cSelo

    def get_qSelo(self): return self.qSelo

    def set_qSelo(self, qSelo): self.qSelo = qSelo

    def get_cEnq(self): return self.cEnq

    def set_cEnq(self, cEnq): self.cEnq = cEnq

    def get_IPITrib(self): return self.IPITrib

    def set_IPITrib(self, IPITrib): self.IPITrib = IPITrib

    def get_IPINT(self): return self.IPINT

    def set_IPINT(self, IPINT): self.IPINT = IPINT

    def validate_clEnqType(self, value):
        # Validate type clEnqType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 5:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on clEnqType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on clEnqType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_clEnqType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_clEnqType_patterns_, ))
    validate_clEnqType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_cSeloType(self, value):
        # Validate type cSeloType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cSeloType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cSeloType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cSeloType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cSeloType_patterns_, ))
    validate_cSeloType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_qSeloType(self, value):
        # Validate type qSeloType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qSeloType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_qSeloType_patterns_, ))
    validate_qSeloType_patterns_ = [['^[0-9]{1,12}$']]

    def validate_cEnqType(self, value):
        # Validate type cEnqType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 3:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cEnqType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cEnqType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cEnqType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cEnqType_patterns_, ))
    validate_cEnqType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.clEnq is not None or
            self.CNPJProd is not None or
            self.cSelo is not None or
            self.qSelo is not None or
            self.cEnq is not None or
            self.IPITrib is not None or
            self.IPINT is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TIpi',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIpi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TIpi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TIpi',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TIpi'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TIpi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clEnq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sclEnq>%s</%sclEnq>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.clEnq),
            input_name='clEnq')),
                    namespace_,
                    eol_))
        if self.CNPJProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJProd>%s</%sCNPJProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJProd),
            input_name='CNPJProd')),
                    namespace_,
                    eol_))
        if self.cSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scSelo>%s</%scSelo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cSelo),
            input_name='cSelo')),
                    namespace_,
                    eol_))
        if self.qSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqSelo>%s</%sqSelo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qSelo),
            input_name='qSelo')),
                    namespace_,
                    eol_))
        if self.cEnq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scEnq>%s</%scEnq>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cEnq),
            input_name='cEnq')),
                    namespace_,
                    eol_))
        if self.IPITrib is not None:
            self.IPITrib.export(
                outfile,
                level,
                namespace_,
                name_='IPITrib',
                pretty_print=pretty_print)
        if self.IPINT is not None:
            self.IPINT.export(
                outfile,
                level,
                namespace_,
                name_='IPINT',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clEnq':
            clEnq_ = child_.text
            clEnq_ = self.gds_validate_string(clEnq_, node, 'clEnq')
            self.clEnq = clEnq_
            # validate type clEnqType
            self.validate_clEnqType(self.clEnq)
        elif nodeName_ == 'CNPJProd':
            CNPJProd_ = child_.text
            CNPJProd_ = self.gds_validate_string(CNPJProd_, node, 'CNPJProd')
            self.CNPJProd = CNPJProd_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJProd)
        elif nodeName_ == 'cSelo':
            cSelo_ = child_.text
            cSelo_ = self.gds_validate_string(cSelo_, node, 'cSelo')
            self.cSelo = cSelo_
            # validate type cSeloType
            self.validate_cSeloType(self.cSelo)
        elif nodeName_ == 'qSelo':
            qSelo_ = child_.text
            qSelo_ = self.gds_validate_string(qSelo_, node, 'qSelo')
            self.qSelo = qSelo_
            # validate type qSeloType
            self.validate_qSeloType(self.qSelo)
        elif nodeName_ == 'cEnq':
            cEnq_ = child_.text
            cEnq_ = self.gds_validate_string(cEnq_, node, 'cEnq')
            self.cEnq = cEnq_
            # validate type cEnqType
            self.validate_cEnqType(self.cEnq)
        elif nodeName_ == 'IPITrib':
            obj_ = IPITribType.factory()
            obj_.build(child_)
            self.IPITrib = obj_
            obj_.original_tagname_ = 'IPITrib'
        elif nodeName_ == 'IPINT':
            obj_ = IPINTType.factory()
            obj_.build(child_)
            self.IPINT = obj_
            obj_.original_tagname_ = 'IPINT'
# end class TIpi


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Id=None, SignedInfo=None,
                 SignatureValue=None, KeyInfo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_SignedInfo(self): return self.SignedInfo

    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo

    def get_SignatureValue(self): return self.SignatureValue

    def set_SignatureValue(
        self, SignatureValue): self.SignatureValue = SignatureValue

    def get_KeyInfo(self): return self.KeyInfo

    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='SignatureType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='SignatureType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(
                outfile,
                level,
                namespace_,
                name_='SignedInfo',
                pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(
                outfile,
                level,
                namespace_,
                name_='SignatureValue',
                pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(
                outfile,
                level,
                namespace_,
                name_='KeyInfo',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def get_valueOf_(self): return self.valueOf_

    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int, float] else self.valueOf_
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='SignatureValueType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='SignatureValueType',
                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Id=None, CanonicalizationMethod=None,
                 SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod

    def set_CanonicalizationMethod(
        self,
        CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod

    def get_SignatureMethod(self): return self.SignatureMethod

    def set_SignatureMethod(
        self, SignatureMethod): self.SignatureMethod = SignatureMethod

    def get_Reference(self): return self.Reference

    def set_Reference(self, Reference): self.Reference = Reference

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='SignedInfoType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='SignedInfoType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(
                outfile,
                level,
                namespace_,
                name_='CanonicalizationMethod',
                pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(
                outfile,
                level,
                namespace_,
                name_='SignatureMethod',
                pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(
                outfile,
                level,
                namespace_,
                name_='Reference',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Id=None, URI=None, Type=None,
                 Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Transforms(self): return self.Transforms

    def set_Transforms(self, Transforms): self.Transforms = Transforms

    def get_DigestMethod(self): return self.DigestMethod

    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod

    def get_DigestValue(self): return self.DigestValue

    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def get_URI(self): return self.URI

    def set_URI(self, URI): self.URI = URI

    def get_Type(self): return self.Type

    def set_Type(self, Type): self.Type = Type

    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass

    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ReferenceType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ReferenceType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(
                outfile,
                level,
                namespace_,
                name_='Transforms',
                pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(
                outfile,
                level,
                namespace_,
                name_='DigestMethod',
                pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sDigestValue>%s</%sDigestValue>%s' %
                (namespace_,
                 self.gds_format_base64(
                     self.DigestValue,
                     input_name='DigestValue'),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(
                        child_,
                        'requires base64 encoded string: %s' %
                        exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Transform(self): return self.Transform

    def set_Transform(self, Transform): self.Transform = Transform

    def add_Transform(self, value): self.Transform.append(value)

    def insert_Transform_at(
        self,
        index,
        value): self.Transform.insert(
        index,
        value)

    def replace_Transform_at(self, index, value): self.Transform[index] = value

    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TransformsType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TransformsType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TransformsType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(
                outfile,
                level,
                namespace_,
                name_='Transform',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Algorithm=None, XPath=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_XPath(self): return self.XPath

    def set_XPath(self, XPath): self.XPath = XPath

    def add_XPath(self, value): self.XPath.append(value)

    def insert_XPath_at(self, index, value): self.XPath.insert(index, value)

    def replace_XPath_at(self, index, value): self.XPath[index] = value

    def get_Algorithm(self): return self.Algorithm

    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm

    def hasContent_(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='TransformType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='TransformType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sXPath>%s</%sXPath>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(XPath_),
            input_name='XPath')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XPath':
            XPath_ = child_.text
            XPath_ = self.gds_validate_string(XPath_, node, 'XPath')
            self.XPath.append(XPath_)
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Id=None, X509Data=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.X509Data = X509Data

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_X509Data(self): return self.X509Data

    def set_X509Data(self, X509Data): self.X509Data = X509Data

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def hasContent_(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='KeyInfoType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='KeyInfoType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            self.X509Data.export(
                outfile,
                level,
                namespace_,
                name_='X509Data',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, X509Certificate=None):
        self.original_tagname_ = None
        self.X509Certificate = X509Certificate

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_X509Certificate(self): return self.X509Certificate

    def set_X509Certificate(
        self, X509Certificate): self.X509Certificate = X509Certificate

    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='X509DataType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='X509DataType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='X509DataType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sX509Certificate>%s</%sX509Certificate>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.X509Certificate),
            input_name='X509Certificate')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(
                X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


class infNFeType(GeneratedsSuper):
    """Informações da Nota Fiscal eletrônica"""
    subclass = None
    superclass = None

    def __init__(self, versao=None, Id=None, ide=None, emit=None, avulsa=None, dest=None, retirada=None, entrega=None,
                 autXML=None, det=None, total=None, transp=None, cobr=None, pag=None, infAdic=None, exporta=None, compra=None, cana=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.emit = emit
        self.avulsa = avulsa
        self.dest = dest
        self.retirada = retirada
        self.entrega = entrega
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        if det is None:
            self.det = []
        else:
            self.det = det
        self.total = total
        self.transp = transp
        self.cobr = cobr
        self.pag = pag
        self.infAdic = infAdic
        self.exporta = exporta
        self.compra = compra
        self.cana = cana

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType.subclass:
            return infNFeType.subclass(*args_, **kwargs_)
        else:
            return infNFeType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_ide(self): return self.ide

    def set_ide(self, ide): self.ide = ide

    def get_emit(self): return self.emit

    def set_emit(self, emit): self.emit = emit

    def get_avulsa(self): return self.avulsa

    def set_avulsa(self, avulsa): self.avulsa = avulsa

    def get_dest(self): return self.dest

    def set_dest(self, dest): self.dest = dest

    def get_retirada(self): return self.retirada

    def set_retirada(self, retirada): self.retirada = retirada

    def get_entrega(self): return self.entrega

    def set_entrega(self, entrega): self.entrega = entrega

    def get_autXML(self): return self.autXML

    def set_autXML(self, autXML): self.autXML = autXML

    def add_autXML(self, value): self.autXML.append(value)

    def insert_autXML_at(self, index, value): self.autXML.insert(index, value)

    def replace_autXML_at(self, index, value): self.autXML[index] = value

    def get_det(self): return self.det

    def set_det(self, det): self.det = det

    def add_det(self, value): self.det.append(value)

    def insert_det_at(self, index, value): self.det.insert(index, value)

    def replace_det_at(self, index, value): self.det[index] = value

    def get_total(self): return self.total

    def set_total(self, total): self.total = total

    def get_transp(self): return self.transp

    def set_transp(self, transp): self.transp = transp

    def get_cobr(self): return self.cobr

    def set_cobr(self, cobr): self.cobr = cobr

    def get_pag(self): return self.pag

    def set_pag(self, pag): self.pag = pag

    def get_infAdic(self): return self.infAdic

    def set_infAdic(self, infAdic): self.infAdic = infAdic

    def get_exporta(self): return self.exporta

    def set_exporta(self, exporta): self.exporta = exporta

    def get_compra(self): return self.compra

    def set_compra(self, compra): self.compra = compra

    def get_cana(self): return self.cana

    def set_cana(self, cana): self.cana = cana

    def get_versao(self): return self.versao

    def set_versao(self, versao): self.versao = versao

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]

    def hasContent_(self):
        if (
            self.ide is not None or
            self.emit is not None or
            self.avulsa is not None or
            self.dest is not None or
            self.retirada is not None or
            self.entrega is not None or
            self.autXML or
            self.det or
            self.total is not None or
            self.transp is not None or
            self.cobr is not None or
            self.pag is not None or
            self.infAdic is not None or
            self.exporta is not None or
            self.compra is not None or
            self.cana is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='infNFeType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='infNFeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='infNFeType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='infNFeType'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(
                ' Id=%s' %
                (self.gds_encode(
                    self.gds_format_string(
                        quote_attrib(
                self.Id),
                        input_name='Id')),
                ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='infNFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(
                outfile,
                level,
                namespace_,
                name_='ide',
                pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(
                outfile,
                level,
                namespace_,
                name_='emit',
                pretty_print=pretty_print)
        if self.avulsa is not None:
            self.avulsa.export(
                outfile,
                level,
                namespace_,
                name_='avulsa',
                pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(
                outfile,
                level,
                namespace_,
                name_='dest',
                pretty_print=pretty_print)
        if self.retirada is not None:
            self.retirada.export(
                outfile,
                level,
                namespace_,
                name_='retirada',
                pretty_print=pretty_print)
        if self.entrega is not None:
            self.entrega.export(
                outfile,
                level,
                namespace_,
                name_='entrega',
                pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(
                outfile,
                level,
                namespace_,
                name_='autXML',
                pretty_print=pretty_print)
        for det_ in self.det:
            det_.export(
                outfile,
                level,
                namespace_,
                name_='det',
                pretty_print=pretty_print)
        if self.total is not None:
            self.total.export(
                outfile,
                level,
                namespace_,
                name_='total',
                pretty_print=pretty_print)
        if self.transp is not None:
            self.transp.export(
                outfile,
                level,
                namespace_,
                name_='transp',
                pretty_print=pretty_print)
        if self.cobr is not None:
            self.cobr.export(
                outfile,
                level,
                namespace_,
                name_='cobr',
                pretty_print=pretty_print)
        if self.pag is not None:
            self.pag.export(
                outfile,
                level,
                namespace_,
                name_='pag',
                pretty_print=pretty_print)
        if self.infAdic is not None:
            self.infAdic.export(
                outfile,
                level,
                namespace_,
                name_='infAdic',
                pretty_print=pretty_print)
        if self.exporta is not None:
            self.exporta.export(
                outfile,
                level,
                namespace_,
                name_='exporta',
                pretty_print=pretty_print)
        if self.compra is not None:
            self.compra.export(
                outfile,
                level,
                namespace_,
                name_='compra',
                pretty_print=pretty_print)
        if self.cana is not None:
            self.cana.export(
                outfile,
                level,
                namespace_,
                name_='cana',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ideType.factory()
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'emit':
            obj_ = emitType.factory()
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'avulsa':
            obj_ = avulsaType.factory()
            obj_.build(child_)
            self.avulsa = obj_
            obj_.original_tagname_ = 'avulsa'
        elif nodeName_ == 'dest':
            obj_ = destType.factory()
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'retirada':
            obj_ = TLocal.factory()
            obj_.build(child_)
            self.retirada = obj_
            obj_.original_tagname_ = 'retirada'
        elif nodeName_ == 'entrega':
            obj_ = TLocal.factory()
            obj_.build(child_)
            self.entrega = obj_
            obj_.original_tagname_ = 'entrega'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType.factory()
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'det':
            obj_ = detType.factory()
            obj_.build(child_)
            self.det.append(obj_)
            obj_.original_tagname_ = 'det'
        elif nodeName_ == 'total':
            obj_ = totalType.factory()
            obj_.build(child_)
            self.total = obj_
            obj_.original_tagname_ = 'total'
        elif nodeName_ == 'transp':
            obj_ = transpType.factory()
            obj_.build(child_)
            self.transp = obj_
            obj_.original_tagname_ = 'transp'
        elif nodeName_ == 'cobr':
            obj_ = cobrType.factory()
            obj_.build(child_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'pag':
            obj_ = pagType.factory()
            obj_.build(child_)
            self.pag = obj_
            obj_.original_tagname_ = 'pag'
        elif nodeName_ == 'infAdic':
            obj_ = infAdicType.factory()
            obj_.build(child_)
            self.infAdic = obj_
            obj_.original_tagname_ = 'infAdic'
        elif nodeName_ == 'exporta':
            obj_ = exportaType.factory()
            obj_.build(child_)
            self.exporta = obj_
            obj_.original_tagname_ = 'exporta'
        elif nodeName_ == 'compra':
            obj_ = compraType.factory()
            obj_.build(child_)
            self.compra = obj_
            obj_.original_tagname_ = 'compra'
        elif nodeName_ == 'cana':
            obj_ = canaType.factory()
            obj_.build(child_)
            self.cana = obj_
            obj_.original_tagname_ = 'cana'
# end class infNFeType


class ideType(GeneratedsSuper):
    """identificação da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, cUF=None, cNF=None, natOp=None, mod=None, serie=None, nNF=None, dhEmi=None, dhSaiEnt=None, tpNF=None, idDest=None, cMunFG=None, tpImp=None,
                 tpEmis=None, cDV=None, tpAmb=None, finNFe=None, indFinal=None, indPres=None, procEmi=None, verProc=None, dhCont=None, xJust=None, NFref=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cNF = cNF
        self.validate_cNFType(self.cNF)
        self.natOp = natOp
        self.validate_natOpType(self.natOp)
        self.mod = mod
        self.validate_TMod(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
        self.dhEmi = dhEmi
        self.validate_TDateTimeUTC(self.dhEmi)
        self.dhSaiEnt = dhSaiEnt
        self.validate_TDateTimeUTC(self.dhSaiEnt)
        self.tpNF = tpNF
        self.validate_tpNFType(self.tpNF)
        self.idDest = idDest
        self.validate_idDestType(self.idDest)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.tpImp = tpImp
        self.validate_tpImpType(self.tpImp)
        self.tpEmis = tpEmis
        self.validate_tpEmisType(self.tpEmis)
        self.cDV = cDV
        self.validate_cDVType(self.cDV)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.finNFe = finNFe
        self.validate_TFinNFe(self.finNFe)
        self.indFinal = indFinal
        self.validate_indFinalType(self.indFinal)
        self.indPres = indPres
        self.validate_indPresType(self.indPres)
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.verProc = verProc
        self.validate_verProcType(self.verProc)
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.xJust = xJust
        self.validate_xJustType(self.xJust)
        if NFref is None:
            self.NFref = []
        else:
            self.NFref = NFref

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType.subclass:
            return ideType.subclass(*args_, **kwargs_)
        else:
            return ideType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cUF(self): return self.cUF

    def set_cUF(self, cUF): self.cUF = cUF

    def get_cNF(self): return self.cNF

    def set_cNF(self, cNF): self.cNF = cNF

    def get_natOp(self): return self.natOp

    def set_natOp(self, natOp): self.natOp = natOp

    def get_mod(self): return self.mod

    def set_mod(self, mod): self.mod = mod

    def get_serie(self): return self.serie

    def set_serie(self, serie): self.serie = serie

    def get_nNF(self): return self.nNF

    def set_nNF(self, nNF): self.nNF = nNF

    def get_dhEmi(self): return self.dhEmi

    def set_dhEmi(self, dhEmi): self.dhEmi = dhEmi

    def get_dhSaiEnt(self): return self.dhSaiEnt

    def set_dhSaiEnt(self, dhSaiEnt): self.dhSaiEnt = dhSaiEnt

    def get_tpNF(self): return self.tpNF

    def set_tpNF(self, tpNF): self.tpNF = tpNF

    def get_idDest(self): return self.idDest

    def set_idDest(self, idDest): self.idDest = idDest

    def get_cMunFG(self): return self.cMunFG

    def set_cMunFG(self, cMunFG): self.cMunFG = cMunFG

    def get_tpImp(self): return self.tpImp

    def set_tpImp(self, tpImp): self.tpImp = tpImp

    def get_tpEmis(self): return self.tpEmis

    def set_tpEmis(self, tpEmis): self.tpEmis = tpEmis

    def get_cDV(self): return self.cDV

    def set_cDV(self, cDV): self.cDV = cDV

    def get_tpAmb(self): return self.tpAmb

    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb

    def get_finNFe(self): return self.finNFe

    def set_finNFe(self, finNFe): self.finNFe = finNFe

    def get_indFinal(self): return self.indFinal

    def set_indFinal(self, indFinal): self.indFinal = indFinal

    def get_indPres(self): return self.indPres

    def set_indPres(self, indPres): self.indPres = indPres

    def get_procEmi(self): return self.procEmi

    def set_procEmi(self, procEmi): self.procEmi = procEmi

    def get_verProc(self): return self.verProc

    def set_verProc(self, verProc): self.verProc = verProc

    def get_dhCont(self): return self.dhCont

    def set_dhCont(self, dhCont): self.dhCont = dhCont

    def get_xJust(self): return self.xJust

    def set_xJust(self, xJust): self.xJust = xJust

    def get_NFref(self): return self.NFref

    def set_NFref(self, NFref): self.NFref = NFref

    def add_NFref(self, value): self.NFref.append(value)

    def insert_NFref_at(self, index, value): self.NFref.insert(index, value)

    def replace_NFref_at(self, index, value): self.NFref[index] = value

    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '11',
                '12',
                '13',
                '14',
                '15',
                '16',
                '17',
                '21',
                '22',
                '23',
                '24',
                '25',
                '26',
                '27',
                '28',
                '29',
                '31',
                '32',
                '33',
                '35',
                '41',
                '42',
                '43',
                '50',
                '51',
                '52',
                '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {
        "value": value.encode("utf-8")})

    def validate_cNFType(self, value):
        # Validate type cNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cNFType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cNFType_patterns_, ))
    validate_cNFType_patterns_ = [['^[0-9]{8}$']]

    def validate_natOpType(self, value):
        # Validate type natOpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on natOpType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on natOpType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_natOpType_patterns_, ))
    validate_natOpType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TMod(self, value):
        # Validate type TMod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['55', '65']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TMod' % {
        "value": value.encode("utf-8")})

    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]

    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]

    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]

    def validate_tpNFType(self, value):
        # Validate type tpNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpNFType' % {
        "value": value.encode("utf-8")})

    def validate_idDestType(self, value):
        # Validate type idDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on idDestType' % {
        "value": value.encode("utf-8")})

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def validate_tpImpType(self, value):
        # Validate type tpImpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpImpType' % {
        "value": value.encode("utf-8")})

    def validate_tpEmisType(self, value):
        # Validate type tpEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpEmisType' % {
        "value": value.encode("utf-8")})

    def validate_cDVType(self, value):
        # Validate type cDVType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cDVType_patterns_, ))
    validate_cDVType_patterns_ = [['^[0-9]{1}$']]

    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {
        "value": value.encode("utf-8")})

    def validate_TFinNFe(self, value):
        # Validate type TFinNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TFinNFe' % {
        "value": value.encode("utf-8")})

    def validate_indFinalType(self, value):
        # Validate type indFinalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indFinalType' % {
        "value": value.encode("utf-8")})

    def validate_indPresType(self, value):
        # Validate type indPresType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indPresType' % {
        "value": value.encode("utf-8")})

    def validate_TProcEmi(self, value):
        # Validate type TProcEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TProcEmi' % {
        "value": value.encode("utf-8")})

    def validate_verProcType(self, value):
        # Validate type verProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on verProcType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on verProcType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_verProcType_patterns_, ))
    validate_verProcType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xJustType(self, value):
        # Validate type xJustType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xJustType' % {
        "value": value})
            if len(str(value)) < 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xJustType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xJustType_patterns_, ))
    validate_xJustType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.cUF is not None or
            self.cNF is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None or
            self.dhEmi is not None or
            self.dhSaiEnt is not None or
            self.tpNF is not None or
            self.idDest is not None or
            self.cMunFG is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.finNFe is not None or
            self.indFinal is not None or
            self.indPres is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.dhCont is not None or
            self.xJust is not None or
            self.NFref
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ideType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ideType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ideType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scUF>%s</%scUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cUF),
            input_name='cUF')),
                    namespace_,
                    eol_))
        if self.cNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scNF>%s</%scNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cNF),
            input_name='cNF')),
                    namespace_,
                    eol_))
        if self.natOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snatOp>%s</%snatOp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.natOp),
            input_name='natOp')),
                    namespace_,
                    eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smod>%s</%smod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.mod),
            input_name='mod')),
                    namespace_,
                    eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sserie>%s</%sserie>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.serie),
            input_name='serie')),
                    namespace_,
                    eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snNF>%s</%snNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nNF),
            input_name='nNF')),
                    namespace_,
                    eol_))
        if self.dhEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhEmi>%s</%sdhEmi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhEmi),
            input_name='dhEmi')),
                    namespace_,
                    eol_))
        if self.dhSaiEnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhSaiEnt>%s</%sdhSaiEnt>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhSaiEnt),
            input_name='dhSaiEnt')),
                    namespace_,
                    eol_))
        if self.tpNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpNF>%s</%stpNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpNF),
            input_name='tpNF')),
                    namespace_,
                    eol_))
        if self.idDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sidDest>%s</%sidDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.idDest),
            input_name='idDest')),
                    namespace_,
                    eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMunFG>%s</%scMunFG>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMunFG),
            input_name='cMunFG')),
                    namespace_,
                    eol_))
        if self.tpImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpImp>%s</%stpImp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpImp),
            input_name='tpImp')),
                    namespace_,
                    eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpEmis>%s</%stpEmis>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpEmis),
            input_name='tpEmis')),
                    namespace_,
                    eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scDV>%s</%scDV>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cDV),
            input_name='cDV')),
                    namespace_,
                    eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpAmb>%s</%stpAmb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpAmb),
            input_name='tpAmb')),
                    namespace_,
                    eol_))
        if self.finNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sfinNFe>%s</%sfinNFe>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.finNFe),
            input_name='finNFe')),
                    namespace_,
                    eol_))
        if self.indFinal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindFinal>%s</%sindFinal>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indFinal),
            input_name='indFinal')),
                    namespace_,
                    eol_))
        if self.indPres is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindPres>%s</%sindPres>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indPres),
            input_name='indPres')),
                    namespace_,
                    eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sprocEmi>%s</%sprocEmi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.procEmi),
            input_name='procEmi')),
                    namespace_,
                    eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sverProc>%s</%sverProc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.verProc),
            input_name='verProc')),
                    namespace_,
                    eol_))
        if self.dhCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhCont>%s</%sdhCont>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhCont),
            input_name='dhCont')),
                    namespace_,
                    eol_))
        if self.xJust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxJust>%s</%sxJust>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xJust),
            input_name='xJust')),
                    namespace_,
                    eol_))
        for NFref_ in self.NFref:
            NFref_.export(
                outfile,
                level,
                namespace_,
                name_='NFref',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cNF':
            cNF_ = child_.text
            cNF_ = self.gds_validate_string(cNF_, node, 'cNF')
            self.cNF = cNF_
            # validate type cNFType
            self.validate_cNFType(self.cNF)
        elif nodeName_ == 'natOp':
            natOp_ = child_.text
            natOp_ = self.gds_validate_string(natOp_, node, 'natOp')
            self.natOp = natOp_
            # validate type natOpType
            self.validate_natOpType(self.natOp)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type TMod
            self.validate_TMod(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
        elif nodeName_ == 'dhEmi':
            dhEmi_ = child_.text
            dhEmi_ = self.gds_validate_string(dhEmi_, node, 'dhEmi')
            self.dhEmi = dhEmi_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhEmi)
        elif nodeName_ == 'dhSaiEnt':
            dhSaiEnt_ = child_.text
            dhSaiEnt_ = self.gds_validate_string(dhSaiEnt_, node, 'dhSaiEnt')
            self.dhSaiEnt = dhSaiEnt_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhSaiEnt)
        elif nodeName_ == 'tpNF':
            tpNF_ = child_.text
            tpNF_ = self.gds_validate_string(tpNF_, node, 'tpNF')
            self.tpNF = tpNF_
            # validate type tpNFType
            self.validate_tpNFType(self.tpNF)
        elif nodeName_ == 'idDest':
            idDest_ = child_.text
            idDest_ = self.gds_validate_string(idDest_, node, 'idDest')
            self.idDest = idDest_
            # validate type idDestType
            self.validate_idDestType(self.idDest)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'tpImp':
            tpImp_ = child_.text
            tpImp_ = self.gds_validate_string(tpImp_, node, 'tpImp')
            self.tpImp = tpImp_
            # validate type tpImpType
            self.validate_tpImpType(self.tpImp)
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
            # validate type tpEmisType
            self.validate_tpEmisType(self.tpEmis)
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
            # validate type cDVType
            self.validate_cDVType(self.cDV)
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'finNFe':
            finNFe_ = child_.text
            finNFe_ = self.gds_validate_string(finNFe_, node, 'finNFe')
            self.finNFe = finNFe_
            # validate type TFinNFe
            self.validate_TFinNFe(self.finNFe)
        elif nodeName_ == 'indFinal':
            indFinal_ = child_.text
            indFinal_ = self.gds_validate_string(indFinal_, node, 'indFinal')
            self.indFinal = indFinal_
            # validate type indFinalType
            self.validate_indFinalType(self.indFinal)
        elif nodeName_ == 'indPres':
            indPres_ = child_.text
            indPres_ = self.gds_validate_string(indPres_, node, 'indPres')
            self.indPres = indPres_
            # validate type indPresType
            self.validate_indPresType(self.indPres)
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
            # validate type verProcType
            self.validate_verProcType(self.verProc)
        elif nodeName_ == 'dhCont':
            dhCont_ = child_.text
            dhCont_ = self.gds_validate_string(dhCont_, node, 'dhCont')
            self.dhCont = dhCont_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            xJust_ = child_.text
            xJust_ = self.gds_validate_string(xJust_, node, 'xJust')
            self.xJust = xJust_
            # validate type xJustType
            self.validate_xJustType(self.xJust)
        elif nodeName_ == 'NFref':
            obj_ = NFrefType.factory()
            obj_.build(child_)
            self.NFref.append(obj_)
            obj_.original_tagname_ = 'NFref'
# end class ideType


class NFrefType(GeneratedsSuper):
    """Grupo de infromações da NF referenciada"""
    subclass = None
    superclass = None

    def __init__(self, refNFe=None, refNF=None,
                 refNFP=None, refCTe=None, refECF=None):
        self.original_tagname_ = None
        self.refNFe = refNFe
        self.validate_TChNFe(self.refNFe)
        self.refNF = refNF
        self.refNFP = refNFP
        self.refCTe = refCTe
        self.validate_TChNFe(self.refCTe)
        self.refECF = refECF

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NFrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NFrefType.subclass:
            return NFrefType.subclass(*args_, **kwargs_)
        else:
            return NFrefType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_refNFe(self): return self.refNFe

    def set_refNFe(self, refNFe): self.refNFe = refNFe

    def get_refNF(self): return self.refNF

    def set_refNF(self, refNF): self.refNF = refNF

    def get_refNFP(self): return self.refNFP

    def set_refNFP(self, refNFP): self.refNFP = refNFP

    def get_refCTe(self): return self.refCTe

    def set_refCTe(self, refCTe): self.refCTe = refCTe

    def get_refECF(self): return self.refECF

    def set_refECF(self, refECF): self.refECF = refECF

    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]

    def hasContent_(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refNFP is not None or
            self.refCTe is not None or
            self.refECF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='NFrefType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NFrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='NFrefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='NFrefType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='NFrefType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='NFrefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%srefNFe>%s</%srefNFe>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.refNFe),
            input_name='refNFe')),
                    namespace_,
                    eol_))
        if self.refNF is not None:
            self.refNF.export(
                outfile,
                level,
                namespace_,
                name_='refNF',
                pretty_print=pretty_print)
        if self.refNFP is not None:
            self.refNFP.export(
                outfile,
                level,
                namespace_,
                name_='refNFP',
                pretty_print=pretty_print)
        if self.refCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%srefCTe>%s</%srefCTe>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.refCTe),
            input_name='refCTe')),
                    namespace_,
                    eol_))
        if self.refECF is not None:
            self.refECF.export(
                outfile,
                level,
                namespace_,
                name_='refECF',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refNFe':
            refNFe_ = child_.text
            refNFe_ = self.gds_validate_string(refNFe_, node, 'refNFe')
            self.refNFe = refNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.refNFe)
        elif nodeName_ == 'refNF':
            obj_ = refNFType.factory()
            obj_.build(child_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refNFP':
            obj_ = refNFPType.factory()
            obj_.build(child_)
            self.refNFP = obj_
            obj_.original_tagname_ = 'refNFP'
        elif nodeName_ == 'refCTe':
            refCTe_ = child_.text
            refCTe_ = self.gds_validate_string(refCTe_, node, 'refCTe')
            self.refCTe = refCTe_
            # validate type TChNFe
            self.validate_TChNFe(self.refCTe)
        elif nodeName_ == 'refECF':
            obj_ = refECFType.factory()
            obj_.build(child_)
            self.refECF = obj_
            obj_.original_tagname_ = 'refECF'
# end class NFrefType


class refNFType(GeneratedsSuper):
    """Dados da NF modelo 1/1A referenciada ou NF modelo 2 referenciada"""
    subclass = None
    superclass = None

    def __init__(self, cUF=None, AAMM=None, CNPJ=None,
                 mod=None, serie=None, nNF=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.mod = mod
        self.validate_modType(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFType.subclass:
            return refNFType.subclass(*args_, **kwargs_)
        else:
            return refNFType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cUF(self): return self.cUF

    def set_cUF(self, cUF): self.cUF = cUF

    def get_AAMM(self): return self.AAMM

    def set_AAMM(self, AAMM): self.AAMM = AAMM

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_mod(self): return self.mod

    def set_mod(self, mod): self.mod = mod

    def get_serie(self): return self.serie

    def set_serie(self, serie): self.serie = serie

    def get_nNF(self): return self.nNF

    def set_nNF(self, nNF): self.nNF = nNF

    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '11',
                '12',
                '13',
                '14',
                '15',
                '16',
                '17',
                '21',
                '22',
                '23',
                '24',
                '25',
                '26',
                '27',
                '28',
                '29',
                '31',
                '32',
                '33',
                '35',
                '41',
                '42',
                '43',
                '50',
                '51',
                '52',
                '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {
        "value": value.encode("utf-8")})

    def validate_AAMMType(self, value):
        # Validate type AAMMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_AAMMType_patterns_, ))
    validate_AAMMType_patterns_ = [
        ['^[0-9]{2}[0]{1}[1-9]{1}$|^[0-9]{2}[1]{1}[0-2]{1}$']]

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_modType(self, value):
        # Validate type modType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modType' % {
        "value": value.encode("utf-8")})

    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]

    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]

    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='refNFType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='refNFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='refNFType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='refNFType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='refNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scUF>%s</%scUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cUF),
            input_name='cUF')),
                    namespace_,
                    eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sAAMM>%s</%sAAMM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.AAMM),
            input_name='AAMM')),
                    namespace_,
                    eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smod>%s</%smod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.mod),
            input_name='mod')),
                    namespace_,
                    eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sserie>%s</%sserie>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.serie),
            input_name='serie')),
                    namespace_,
                    eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snNF>%s</%snNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nNF),
            input_name='nNF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType
            self.validate_AAMMType(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType
            self.validate_modType(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFType


class refNFPType(GeneratedsSuper):
    """Grupo com as informações NF de produtor referenciada"""
    subclass = None
    superclass = None

    def __init__(self, cUF=None, AAMM=None, CNPJ=None, CPF=None,
                 IE=None, mod=None, serie=None, nNF=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType1(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.mod = mod
        self.validate_modType2(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFPType.subclass:
            return refNFPType.subclass(*args_, **kwargs_)
        else:
            return refNFPType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cUF(self): return self.cUF

    def set_cUF(self, cUF): self.cUF = cUF

    def get_AAMM(self): return self.AAMM

    def set_AAMM(self, AAMM): self.AAMM = AAMM

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def get_IE(self): return self.IE

    def set_IE(self, IE): self.IE = IE

    def get_mod(self): return self.mod

    def set_mod(self, mod): self.mod = mod

    def get_serie(self): return self.serie

    def set_serie(self, serie): self.serie = serie

    def get_nNF(self): return self.nNF

    def set_nNF(self, nNF): self.nNF = nNF

    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '11',
                '12',
                '13',
                '14',
                '15',
                '16',
                '17',
                '21',
                '22',
                '23',
                '24',
                '25',
                '26',
                '27',
                '28',
                '29',
                '31',
                '32',
                '33',
                '35',
                '41',
                '42',
                '43',
                '50',
                '51',
                '52',
                '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {
        "value": value.encode("utf-8")})

    def validate_AAMMType1(self, value):
        # Validate type AAMMType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType1_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_AAMMType1_patterns_, ))
    validate_AAMMType1_patterns_ = [
        ['^[0-9]{2}[0]{1}[1-9]{1}$|^[0-9]{2}[1]{1}[0-2]{1}$']]

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [['^ISENTO$|^[0-9]{2,14}$']]

    def validate_modType2(self, value):
        # Validate type modType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '04']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modType2' % {
        "value": value.encode("utf-8")})

    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]

    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]

    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='refNFPType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='refNFPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='refNFPType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='refNFPType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='refNFPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scUF>%s</%scUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cUF),
            input_name='cUF')),
                    namespace_,
                    eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sAAMM>%s</%sAAMM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.AAMM),
            input_name='AAMM')),
                    namespace_,
                    eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIE>%s</%sIE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IE),
            input_name='IE')),
                    namespace_,
                    eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smod>%s</%smod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.mod),
            input_name='mod')),
                    namespace_,
                    eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sserie>%s</%sserie>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.serie),
            input_name='serie')),
                    namespace_,
                    eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snNF>%s</%snNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nNF),
            input_name='nNF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType1
            self.validate_AAMMType1(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType2
            self.validate_modType2(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFPType


class refECFType(GeneratedsSuper):
    """Grupo do Cupom Fiscal vinculado à NF-e"""
    subclass = None
    superclass = None

    def __init__(self, mod=None, nECF=None, nCOO=None):
        self.original_tagname_ = None
        self.mod = mod
        self.validate_modType3(self.mod)
        self.nECF = nECF
        self.validate_nECFType(self.nECF)
        self.nCOO = nCOO
        self.validate_nCOOType(self.nCOO)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refECFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refECFType.subclass:
            return refECFType.subclass(*args_, **kwargs_)
        else:
            return refECFType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_mod(self): return self.mod

    def set_mod(self, mod): self.mod = mod

    def get_nECF(self): return self.nECF

    def set_nECF(self, nECF): self.nECF = nECF

    def get_nCOO(self): return self.nCOO

    def set_nCOO(self, nCOO): self.nCOO = nCOO

    def validate_modType3(self, value):
        # Validate type modType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2B', '2C', '2D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modType3' % {
        "value": value.encode("utf-8")})

    def validate_nECFType(self, value):
        # Validate type nECFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nECFType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nECFType_patterns_, ))
    validate_nECFType_patterns_ = [['^[0-9]{1,3}$']]

    def validate_nCOOType(self, value):
        # Validate type nCOOType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nCOOType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nCOOType_patterns_, ))
    validate_nCOOType_patterns_ = [['^[0-9]{1,6}$']]

    def hasContent_(self):
        if (
            self.mod is not None or
            self.nECF is not None or
            self.nCOO is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='refECFType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refECFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='refECFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='refECFType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='refECFType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='refECFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smod>%s</%smod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.mod),
            input_name='mod')),
                    namespace_,
                    eol_))
        if self.nECF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snECF>%s</%snECF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nECF),
            input_name='nECF')),
                    namespace_,
                    eol_))
        if self.nCOO is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snCOO>%s</%snCOO>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nCOO),
            input_name='nCOO')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType3
            self.validate_modType3(self.mod)
        elif nodeName_ == 'nECF':
            nECF_ = child_.text
            nECF_ = self.gds_validate_string(nECF_, node, 'nECF')
            self.nECF = nECF_
            # validate type nECFType
            self.validate_nECFType(self.nECF)
        elif nodeName_ == 'nCOO':
            nCOO_ = child_.text
            nCOO_ = self.gds_validate_string(nCOO_, node, 'nCOO')
            self.nCOO = nCOO_
            # validate type nCOOType
            self.validate_nCOOType(self.nCOO)
# end class refECFType


class emitType(GeneratedsSuper):
    """Identificação do emitente"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, CPF=None, xNome=None, xFant=None,
                 enderEmit=None, IE=None, IEST=None, IM=None, CNAE=None, CRT=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType(self.xNome)
        self.xFant = xFant
        self.validate_xFantType(self.xFant)
        self.enderEmit = enderEmit
        self.IE = IE
        self.validate_TIe(self.IE)
        self.IEST = IEST
        self.validate_TIeST(self.IEST)
        self.IM = IM
        self.validate_IMType(self.IM)
        self.CNAE = CNAE
        self.validate_CNAEType(self.CNAE)
        self.CRT = CRT
        self.validate_CRTType(self.CRT)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType.subclass:
            return emitType.subclass(*args_, **kwargs_)
        else:
            return emitType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def get_xNome(self): return self.xNome

    def set_xNome(self, xNome): self.xNome = xNome

    def get_xFant(self): return self.xFant

    def set_xFant(self, xFant): self.xFant = xFant

    def get_enderEmit(self): return self.enderEmit

    def set_enderEmit(self, enderEmit): self.enderEmit = enderEmit

    def get_IE(self): return self.IE

    def set_IE(self, IE): self.IE = IE

    def get_IEST(self): return self.IEST

    def set_IEST(self, IEST): self.IEST = IEST

    def get_IM(self): return self.IM

    def set_IM(self, IM): self.IM = IM

    def get_CNAE(self): return self.CNAE

    def set_CNAE(self, CNAE): self.CNAE = CNAE

    def get_CRT(self): return self.CRT

    def set_CRT(self, CRT): self.CRT = CRT

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def validate_xNomeType(self, value):
        # Validate type xNomeType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xNomeType' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xNomeType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xNomeType_patterns_, ))
    validate_xNomeType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xFantType(self, value):
        # Validate type xFantType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xFantType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xFantType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xFantType_patterns_, ))
    validate_xFantType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TIe(self, value):
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TIe' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIe_patterns_, ))
    validate_TIe_patterns_ = [['^[0-9]{2,14}$|^ISENTO$']]

    def validate_TIeST(self, value):
        # Validate type TIeST, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TIeST' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeST_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIeST_patterns_, ))
    validate_TIeST_patterns_ = [['^[0-9]{2,14}$']]

    def validate_IMType(self, value):
        # Validate type IMType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on IMType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on IMType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_IMType_patterns_, ))
    validate_IMType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_CNAEType(self, value):
        # Validate type CNAEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CNAEType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CNAEType_patterns_, ))
    validate_CNAEType_patterns_ = [['^[0-9]{7}$']]

    def validate_CRTType(self, value):
        # Validate type CRTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CRTType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None or
            self.IE is not None or
            self.IEST is not None or
            self.IM is not None or
            self.CNAE is not None or
            self.CRT is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='emitType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='emitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='emitType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='emitType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='emitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxNome>%s</%sxNome>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xNome),
            input_name='xNome')),
                    namespace_,
                    eol_))
        if self.xFant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxFant>%s</%sxFant>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xFant),
            input_name='xFant')),
                    namespace_,
                    eol_))
        if self.enderEmit is not None:
            self.enderEmit.export(
                outfile,
                level,
                namespace_,
                name_='enderEmit',
                pretty_print=pretty_print)
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIE>%s</%sIE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IE),
            input_name='IE')),
                    namespace_,
                    eol_))
        if self.IEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIEST>%s</%sIEST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IEST),
            input_name='IEST')),
                    namespace_,
                    eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIM>%s</%sIM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IM),
            input_name='IM')),
                    namespace_,
                    eol_))
        if self.CNAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNAE>%s</%sCNAE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNAE),
            input_name='CNAE')),
                    namespace_,
                    eol_))
        if self.CRT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCRT>%s</%sCRT>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CRT),
            input_name='CRT')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType
            self.validate_xNomeType(self.xNome)
        elif nodeName_ == 'xFant':
            xFant_ = child_.text
            xFant_ = self.gds_validate_string(xFant_, node, 'xFant')
            self.xFant = xFant_
            # validate type xFantType
            self.validate_xFantType(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEnderEmi.factory()
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIe
            self.validate_TIe(self.IE)
        elif nodeName_ == 'IEST':
            IEST_ = child_.text
            IEST_ = self.gds_validate_string(IEST_, node, 'IEST')
            self.IEST = IEST_
            # validate type TIeST
            self.validate_TIeST(self.IEST)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType
            self.validate_IMType(self.IM)
        elif nodeName_ == 'CNAE':
            CNAE_ = child_.text
            CNAE_ = self.gds_validate_string(CNAE_, node, 'CNAE')
            self.CNAE = CNAE_
            # validate type CNAEType
            self.validate_CNAEType(self.CNAE)
        elif nodeName_ == 'CRT':
            CRT_ = child_.text
            CRT_ = self.gds_validate_string(CRT_, node, 'CRT')
            self.CRT = CRT_
            # validate type CRTType
            self.validate_CRTType(self.CRT)
# end class emitType


class avulsaType(GeneratedsSuper):
    """Emissão de avulsa, informar os dados do Fisco emitente"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, xOrgao=None, matr=None, xAgente=None, fone=None,
                 UF=None, nDAR=None, dEmi=None, vDAR=None, repEmi=None, dPag=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.xOrgao = xOrgao
        self.validate_xOrgaoType(self.xOrgao)
        self.matr = matr
        self.validate_matrType(self.matr)
        self.xAgente = xAgente
        self.validate_xAgenteType(self.xAgente)
        self.fone = fone
        self.validate_foneType(self.fone)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.nDAR = nDAR
        self.validate_nDARType(self.nDAR)
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.vDAR = vDAR
        self.validate_TDec_1302(self.vDAR)
        self.repEmi = repEmi
        self.validate_repEmiType(self.repEmi)
        self.dPag = dPag
        self.validate_TData(self.dPag)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, avulsaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if avulsaType.subclass:
            return avulsaType.subclass(*args_, **kwargs_)
        else:
            return avulsaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_xOrgao(self): return self.xOrgao

    def set_xOrgao(self, xOrgao): self.xOrgao = xOrgao

    def get_matr(self): return self.matr

    def set_matr(self, matr): self.matr = matr

    def get_xAgente(self): return self.xAgente

    def set_xAgente(self, xAgente): self.xAgente = xAgente

    def get_fone(self): return self.fone

    def set_fone(self, fone): self.fone = fone

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def get_nDAR(self): return self.nDAR

    def set_nDAR(self, nDAR): self.nDAR = nDAR

    def get_dEmi(self): return self.dEmi

    def set_dEmi(self, dEmi): self.dEmi = dEmi

    def get_vDAR(self): return self.vDAR

    def set_vDAR(self, vDAR): self.vDAR = vDAR

    def get_repEmi(self): return self.repEmi

    def set_repEmi(self, repEmi): self.repEmi = repEmi

    def get_dPag(self): return self.dPag

    def set_dPag(self, dPag): self.dPag = dPag

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_xOrgaoType(self, value):
        # Validate type xOrgaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xOrgaoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xOrgaoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xOrgaoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xOrgaoType_patterns_, ))
    validate_xOrgaoType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_matrType(self, value):
        # Validate type matrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on matrType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on matrType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_matrType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_matrType_patterns_, ))
    validate_matrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xAgenteType(self, value):
        # Validate type xAgenteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xAgenteType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xAgenteType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xAgenteType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xAgenteType_patterns_, ))
    validate_xAgenteType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_foneType(self, value):
        # Validate type foneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_foneType_patterns_, ))
    validate_foneType_patterns_ = [['^[0-9]{6,14}$']]

    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {
        "value": value.encode("utf-8")})

    def validate_nDARType(self, value):
        # Validate type nDARType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nDARType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nDARType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nDARType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nDARType_patterns_, ))
    validate_nDARType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_repEmiType(self, value):
        # Validate type repEmiType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on repEmiType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on repEmiType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_repEmiType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_repEmiType_patterns_, ))
    validate_repEmiType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xOrgao is not None or
            self.matr is not None or
            self.xAgente is not None or
            self.fone is not None or
            self.UF is not None or
            self.nDAR is not None or
            self.dEmi is not None or
            self.vDAR is not None or
            self.repEmi is not None or
            self.dPag is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='avulsaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('avulsaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='avulsaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='avulsaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='avulsaType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='avulsaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.xOrgao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxOrgao>%s</%sxOrgao>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xOrgao),
            input_name='xOrgao')),
                    namespace_,
                    eol_))
        if self.matr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smatr>%s</%smatr>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.matr),
            input_name='matr')),
                    namespace_,
                    eol_))
        if self.xAgente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxAgente>%s</%sxAgente>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xAgente),
            input_name='xAgente')),
                    namespace_,
                    eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sfone>%s</%sfone>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.fone),
            input_name='fone')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))
        if self.nDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snDAR>%s</%snDAR>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nDAR),
            input_name='nDAR')),
                    namespace_,
                    eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdEmi>%s</%sdEmi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dEmi),
            input_name='dEmi')),
                    namespace_,
                    eol_))
        if self.vDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDAR>%s</%svDAR>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDAR),
            input_name='vDAR')),
                    namespace_,
                    eol_))
        if self.repEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%srepEmi>%s</%srepEmi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.repEmi),
            input_name='repEmi')),
                    namespace_,
                    eol_))
        if self.dPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdPag>%s</%sdPag>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dPag),
            input_name='dPag')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'xOrgao':
            xOrgao_ = child_.text
            xOrgao_ = self.gds_validate_string(xOrgao_, node, 'xOrgao')
            self.xOrgao = xOrgao_
            # validate type xOrgaoType
            self.validate_xOrgaoType(self.xOrgao)
        elif nodeName_ == 'matr':
            matr_ = child_.text
            matr_ = self.gds_validate_string(matr_, node, 'matr')
            self.matr = matr_
            # validate type matrType
            self.validate_matrType(self.matr)
        elif nodeName_ == 'xAgente':
            xAgente_ = child_.text
            xAgente_ = self.gds_validate_string(xAgente_, node, 'xAgente')
            self.xAgente = xAgente_
            # validate type xAgenteType
            self.validate_xAgenteType(self.xAgente)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType
            self.validate_foneType(self.fone)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'nDAR':
            nDAR_ = child_.text
            nDAR_ = self.gds_validate_string(nDAR_, node, 'nDAR')
            self.nDAR = nDAR_
            # validate type nDARType
            self.validate_nDARType(self.nDAR)
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vDAR':
            vDAR_ = child_.text
            vDAR_ = self.gds_validate_string(vDAR_, node, 'vDAR')
            self.vDAR = vDAR_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDAR)
        elif nodeName_ == 'repEmi':
            repEmi_ = child_.text
            repEmi_ = self.gds_validate_string(repEmi_, node, 'repEmi')
            self.repEmi = repEmi_
            # validate type repEmiType
            self.validate_repEmiType(self.repEmi)
        elif nodeName_ == 'dPag':
            dPag_ = child_.text
            dPag_ = self.gds_validate_string(dPag_, node, 'dPag')
            self.dPag = dPag_
            # validate type TData
            self.validate_TData(self.dPag)
# end class avulsaType


class destType(GeneratedsSuper):
    """Identificação do Destinatário"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, CPF=None, idEstrangeiro=None, xNome=None,
                 enderDest=None, indIEDest=None, IE=None, ISUF=None, IM=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.idEstrangeiro = idEstrangeiro
        self.validate_idEstrangeiroType(self.idEstrangeiro)
        self.xNome = xNome
        self.validate_xNomeType4(self.xNome)
        self.enderDest = enderDest
        self.indIEDest = indIEDest
        self.validate_indIEDestType(self.indIEDest)
        self.IE = IE
        self.validate_TIeDestNaoIsento(self.IE)
        self.ISUF = ISUF
        self.validate_ISUFType(self.ISUF)
        self.IM = IM
        self.validate_IMType5(self.IM)
        self.email = email
        self.validate_emailType(self.email)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType.subclass:
            return destType.subclass(*args_, **kwargs_)
        else:
            return destType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def get_idEstrangeiro(self): return self.idEstrangeiro

    def set_idEstrangeiro(
        self, idEstrangeiro): self.idEstrangeiro = idEstrangeiro

    def get_xNome(self): return self.xNome

    def set_xNome(self, xNome): self.xNome = xNome

    def get_enderDest(self): return self.enderDest

    def set_enderDest(self, enderDest): self.enderDest = enderDest

    def get_indIEDest(self): return self.indIEDest

    def set_indIEDest(self, indIEDest): self.indIEDest = indIEDest

    def get_IE(self): return self.IE

    def set_IE(self, IE): self.IE = IE

    def get_ISUF(self): return self.ISUF

    def set_ISUF(self, ISUF): self.ISUF = ISUF

    def get_IM(self): return self.IM

    def set_IM(self, IM): self.IM = IM

    def get_email(self): return self.email

    def set_email(self, email): self.email = email

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def validate_idEstrangeiroType(self, value):
        # Validate type idEstrangeiroType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_idEstrangeiroType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_idEstrangeiroType_patterns_, ))
    validate_idEstrangeiroType_patterns_ = [['^([!-ÿ]{0}$|^[!-ÿ]{5,20})?$']]

    def validate_xNomeType4(self, value):
        # Validate type xNomeType4, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xNomeType4' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xNomeType4' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType4_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xNomeType4_patterns_, ))
    validate_xNomeType4_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_indIEDestType(self, value):
        # Validate type indIEDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indIEDestType' % {
        "value": value.encode("utf-8")})

    def validate_TIeDestNaoIsento(self, value):
        # Validate type TIeDestNaoIsento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TIeDestNaoIsento' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDestNaoIsento_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIeDestNaoIsento_patterns_, ))
    validate_TIeDestNaoIsento_patterns_ = [['^[0-9]{2,14}$']]

    def validate_ISUFType(self, value):
        # Validate type ISUFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ISUFType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_ISUFType_patterns_, ))
    validate_ISUFType_patterns_ = [['^[0-9]{8,9}$']]

    def validate_IMType5(self, value):
        # Validate type IMType5, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on IMType5' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on IMType5' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType5_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_IMType5_patterns_, ))
    validate_IMType5_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_emailType(self, value):
        # Validate type emailType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on emailType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on emailType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_emailType_patterns_, ))
    validate_emailType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.idEstrangeiro is not None or
            self.xNome is not None or
            self.enderDest is not None or
            self.indIEDest is not None or
            self.IE is not None or
            self.ISUF is not None or
            self.IM is not None or
            self.email is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='destType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='destType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='destType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='destType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='destType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))
        if self.idEstrangeiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sidEstrangeiro>%s</%sidEstrangeiro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.idEstrangeiro),
            input_name='idEstrangeiro')),
                    namespace_,
                    eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxNome>%s</%sxNome>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xNome),
            input_name='xNome')),
                    namespace_,
                    eol_))
        if self.enderDest is not None:
            self.enderDest.export(
                outfile,
                level,
                namespace_,
                name_='enderDest',
                pretty_print=pretty_print)
        if self.indIEDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindIEDest>%s</%sindIEDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indIEDest),
            input_name='indIEDest')),
                    namespace_,
                    eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIE>%s</%sIE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IE),
            input_name='IE')),
                    namespace_,
                    eol_))
        if self.ISUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sISUF>%s</%sISUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.ISUF),
            input_name='ISUF')),
                    namespace_,
                    eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIM>%s</%sIM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IM),
            input_name='IM')),
                    namespace_,
                    eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%semail>%s</%semail>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.email),
            input_name='email')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'idEstrangeiro':
            idEstrangeiro_ = child_.text
            idEstrangeiro_ = self.gds_validate_string(
                idEstrangeiro_, node, 'idEstrangeiro')
            self.idEstrangeiro = idEstrangeiro_
            # validate type idEstrangeiroType
            self.validate_idEstrangeiroType(self.idEstrangeiro)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType4
            self.validate_xNomeType4(self.xNome)
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'indIEDest':
            indIEDest_ = child_.text
            indIEDest_ = self.gds_validate_string(
                indIEDest_, node, 'indIEDest')
            self.indIEDest = indIEDest_
            # validate type indIEDestType
            self.validate_indIEDestType(self.indIEDest)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDestNaoIsento
            self.validate_TIeDestNaoIsento(self.IE)
        elif nodeName_ == 'ISUF':
            ISUF_ = child_.text
            ISUF_ = self.gds_validate_string(ISUF_, node, 'ISUF')
            self.ISUF = ISUF_
            # validate type ISUFType
            self.validate_ISUFType(self.ISUF)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType5
            self.validate_IMType5(self.IM)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type emailType
            self.validate_emailType(self.email)
# end class destType


class autXMLType(GeneratedsSuper):
    """Pessoas autorizadas para o download do XML da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType.subclass:
            return autXMLType.subclass(*args_, **kwargs_)
        else:
            return autXMLType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='autXMLType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='autXMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='autXMLType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='autXMLType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='autXMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType


class detType(GeneratedsSuper):
    """Dados dos detalhes da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, nItem=None, prod=None, imposto=None,
                 impostoDevol=None, infAdProd=None):
        self.original_tagname_ = None
        self.nItem = _cast(None, nItem)
        self.prod = prod
        self.imposto = imposto
        self.impostoDevol = impostoDevol
        self.infAdProd = infAdProd
        self.validate_infAdProdType(self.infAdProd)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detType.subclass:
            return detType.subclass(*args_, **kwargs_)
        else:
            return detType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_prod(self): return self.prod

    def set_prod(self, prod): self.prod = prod

    def get_imposto(self): return self.imposto

    def set_imposto(self, imposto): self.imposto = imposto

    def get_impostoDevol(self): return self.impostoDevol

    def set_impostoDevol(self, impostoDevol): self.impostoDevol = impostoDevol

    def get_infAdProd(self): return self.infAdProd

    def set_infAdProd(self, infAdProd): self.infAdProd = infAdProd

    def get_nItem(self): return self.nItem

    def set_nItem(self, nItem): self.nItem = nItem

    def validate_infAdProdType(self, value):
        # Validate type infAdProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 500:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on infAdProdType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on infAdProdType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdProdType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_infAdProdType_patterns_, ))
    validate_infAdProdType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.prod is not None or
            self.imposto is not None or
            self.impostoDevol is not None or
            self.infAdProd is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='detType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='detType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='detType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='detType'):
        if self.nItem is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            outfile.write(
                ' nItem=%s' %
                (self.gds_encode(
                    self.gds_format_string(
                        quote_attrib(
                self.nItem),
                        input_name='nItem')),
                ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='detType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prod is not None:
            self.prod.export(
                outfile,
                level,
                namespace_,
                name_='prod',
                pretty_print=pretty_print)
        if self.imposto is not None:
            self.imposto.export(
                outfile,
                level,
                namespace_,
                name_='imposto',
                pretty_print=pretty_print)
        if self.impostoDevol is not None:
            self.impostoDevol.export(
                outfile,
                level,
                namespace_,
                name_='impostoDevol',
                pretty_print=pretty_print)
        if self.infAdProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sinfAdProd>%s</%sinfAdProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.infAdProd),
            input_name='infAdProd')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nItem', node)
        if value is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            self.nItem = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prod':
            obj_ = prodType.factory()
            obj_.build(child_)
            self.prod = obj_
            obj_.original_tagname_ = 'prod'
        elif nodeName_ == 'imposto':
            obj_ = impostoType.factory()
            obj_.build(child_)
            self.imposto = obj_
            obj_.original_tagname_ = 'imposto'
        elif nodeName_ == 'impostoDevol':
            obj_ = impostoDevolType.factory()
            obj_.build(child_)
            self.impostoDevol = obj_
            obj_.original_tagname_ = 'impostoDevol'
        elif nodeName_ == 'infAdProd':
            infAdProd_ = child_.text
            infAdProd_ = self.gds_validate_string(
                infAdProd_, node, 'infAdProd')
            self.infAdProd = infAdProd_
            # validate type infAdProdType
            self.validate_infAdProdType(self.infAdProd)
# end class detType


class prodType(GeneratedsSuper):
    """Dados dos produtos e serviços da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, cProd=None, cEAN=None, xProd=None, NCM=None, NVE=None, CEST=None, indEscala=None, CNPJFab=None, cBenef=None, EXTIPI=None, CFOP=None, uCom=None, qCom=None, vUnCom=None, vProd=None, cEANTrib=None, uTrib=None,
                 qTrib=None, vUnTrib=None, vFrete=None, vSeg=None, vDesc=None, vOutro=None, indTot=None, DI=None, detExport=None, xPed=None, nItemPed=None, nFCI=None, rastro=None, veicProd=None, med=None, arma=None, comb=None, nRECOPI=None):
        self.original_tagname_ = None
        self.cProd = cProd
        self.validate_cProdType(self.cProd)
        self.cEAN = cEAN
        self.validate_cEANType(self.cEAN)
        self.xProd = xProd
        self.validate_xProdType(self.xProd)
        self.NCM = NCM
        self.validate_NCMType(self.NCM)
        if NVE is None:
            self.NVE = []
        else:
            self.NVE = NVE
        self.CEST = CEST
        self.validate_CESTType(self.CEST)
        self.indEscala = indEscala
        self.validate_indEscalaType(self.indEscala)
        self.CNPJFab = CNPJFab
        self.validate_TCnpj(self.CNPJFab)
        self.cBenef = cBenef
        self.validate_cBenefType(self.cBenef)
        self.EXTIPI = EXTIPI
        self.validate_EXTIPIType(self.EXTIPI)
        self.CFOP = CFOP
        self.validate_CFOPType(self.CFOP)
        self.uCom = uCom
        self.validate_uComType(self.uCom)
        self.qCom = qCom
        self.validate_TDec_1104v(self.qCom)
        self.vUnCom = vUnCom
        self.validate_TDec_1110v(self.vUnCom)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.cEANTrib = cEANTrib
        self.validate_cEANTribType(self.cEANTrib)
        self.uTrib = uTrib
        self.validate_uTribType(self.uTrib)
        self.qTrib = qTrib
        self.validate_TDec_1104v(self.qTrib)
        self.vUnTrib = vUnTrib
        self.validate_TDec_1110v(self.vUnTrib)
        self.vFrete = vFrete
        self.validate_TDec_1302Opc(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302Opc(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.indTot = indTot
        self.validate_indTotType(self.indTot)
        if DI is None:
            self.DI = []
        else:
            self.DI = DI
        if detExport is None:
            self.detExport = []
        else:
            self.detExport = detExport
        self.xPed = xPed
        self.validate_xPedType(self.xPed)
        self.nItemPed = nItemPed
        self.validate_nItemPedType(self.nItemPed)
        self.nFCI = nFCI
        self.validate_TGuid(self.nFCI)
        if rastro is None:
            self.rastro = []
        else:
            self.rastro = rastro
        self.veicProd = veicProd
        self.med = med
        if arma is None:
            self.arma = []
        else:
            self.arma = arma
        self.comb = comb
        self.nRECOPI = nRECOPI
        self.validate_nRECOPIType(self.nRECOPI)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, prodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if prodType.subclass:
            return prodType.subclass(*args_, **kwargs_)
        else:
            return prodType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cProd(self): return self.cProd

    def set_cProd(self, cProd): self.cProd = cProd

    def get_cEAN(self): return self.cEAN

    def set_cEAN(self, cEAN): self.cEAN = cEAN

    def get_xProd(self): return self.xProd

    def set_xProd(self, xProd): self.xProd = xProd

    def get_NCM(self): return self.NCM

    def set_NCM(self, NCM): self.NCM = NCM

    def get_NVE(self): return self.NVE

    def set_NVE(self, NVE): self.NVE = NVE

    def add_NVE(self, value): self.NVE.append(value)

    def insert_NVE_at(self, index, value): self.NVE.insert(index, value)

    def replace_NVE_at(self, index, value): self.NVE[index] = value

    def get_CEST(self): return self.CEST

    def set_CEST(self, CEST): self.CEST = CEST

    def get_indEscala(self): return self.indEscala

    def set_indEscala(self, indEscala): self.indEscala = indEscala

    def get_CNPJFab(self): return self.CNPJFab

    def set_CNPJFab(self, CNPJFab): self.CNPJFab = CNPJFab

    def get_cBenef(self): return self.cBenef

    def set_cBenef(self, cBenef): self.cBenef = cBenef

    def get_EXTIPI(self): return self.EXTIPI

    def set_EXTIPI(self, EXTIPI): self.EXTIPI = EXTIPI

    def get_CFOP(self): return self.CFOP

    def set_CFOP(self, CFOP): self.CFOP = CFOP

    def get_uCom(self): return self.uCom

    def set_uCom(self, uCom): self.uCom = uCom

    def get_qCom(self): return self.qCom

    def set_qCom(self, qCom): self.qCom = qCom

    def get_vUnCom(self): return self.vUnCom

    def set_vUnCom(self, vUnCom): self.vUnCom = vUnCom

    def get_vProd(self): return self.vProd

    def set_vProd(self, vProd): self.vProd = vProd

    def get_cEANTrib(self): return self.cEANTrib

    def set_cEANTrib(self, cEANTrib): self.cEANTrib = cEANTrib

    def get_uTrib(self): return self.uTrib

    def set_uTrib(self, uTrib): self.uTrib = uTrib

    def get_qTrib(self): return self.qTrib

    def set_qTrib(self, qTrib): self.qTrib = qTrib

    def get_vUnTrib(self): return self.vUnTrib

    def set_vUnTrib(self, vUnTrib): self.vUnTrib = vUnTrib

    def get_vFrete(self): return self.vFrete

    def set_vFrete(self, vFrete): self.vFrete = vFrete

    def get_vSeg(self): return self.vSeg

    def set_vSeg(self, vSeg): self.vSeg = vSeg

    def get_vDesc(self): return self.vDesc

    def set_vDesc(self, vDesc): self.vDesc = vDesc

    def get_vOutro(self): return self.vOutro

    def set_vOutro(self, vOutro): self.vOutro = vOutro

    def get_indTot(self): return self.indTot

    def set_indTot(self, indTot): self.indTot = indTot

    def get_DI(self): return self.DI

    def set_DI(self, DI): self.DI = DI

    def add_DI(self, value): self.DI.append(value)

    def insert_DI_at(self, index, value): self.DI.insert(index, value)

    def replace_DI_at(self, index, value): self.DI[index] = value

    def get_detExport(self): return self.detExport

    def set_detExport(self, detExport): self.detExport = detExport

    def add_detExport(self, value): self.detExport.append(value)

    def insert_detExport_at(
        self,
        index,
        value): self.detExport.insert(
        index,
        value)

    def replace_detExport_at(self, index, value): self.detExport[index] = value

    def get_xPed(self): return self.xPed

    def set_xPed(self, xPed): self.xPed = xPed

    def get_nItemPed(self): return self.nItemPed

    def set_nItemPed(self, nItemPed): self.nItemPed = nItemPed

    def get_nFCI(self): return self.nFCI

    def set_nFCI(self, nFCI): self.nFCI = nFCI

    def get_rastro(self): return self.rastro

    def set_rastro(self, rastro): self.rastro = rastro

    def add_rastro(self, value): self.rastro.append(value)

    def insert_rastro_at(self, index, value): self.rastro.insert(index, value)

    def replace_rastro_at(self, index, value): self.rastro[index] = value

    def get_veicProd(self): return self.veicProd

    def set_veicProd(self, veicProd): self.veicProd = veicProd

    def get_med(self): return self.med

    def set_med(self, med): self.med = med

    def get_arma(self): return self.arma

    def set_arma(self, arma): self.arma = arma

    def add_arma(self, value): self.arma.append(value)

    def insert_arma_at(self, index, value): self.arma.insert(index, value)

    def replace_arma_at(self, index, value): self.arma[index] = value

    def get_comb(self): return self.comb

    def set_comb(self, comb): self.comb = comb

    def get_nRECOPI(self): return self.nRECOPI

    def set_nRECOPI(self, nRECOPI): self.nRECOPI = nRECOPI

    def validate_cProdType(self, value):
        # Validate type cProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cProdType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cProdType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cProdType_patterns_, ))
    validate_cProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_cEANType(self, value):
        # Validate type cEANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cEANType_patterns_, ))
    validate_cEANType_patterns_ = [['^[0-9]{0}$|^[0-9]{8}$|^[0-9]{12,14}$']]

    def validate_xProdType(self, value):
        # Validate type xProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 120:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xProdType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xProdType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xProdType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xProdType_patterns_, ))
    validate_xProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_NCMType(self, value):
        # Validate type NCMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NCMType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_NCMType_patterns_, ))
    validate_NCMType_patterns_ = [['^[0-9]{2}$|^[0-9]{8}$']]

    def validate_NVEType(self, value):
        # Validate type NVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NVEType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_NVEType_patterns_, ))
    validate_NVEType_patterns_ = [['^[A-Z]{2}[0-9]{4}$']]

    def validate_CESTType(self, value):
        # Validate type CESTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CESTType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CESTType_patterns_, ))
    validate_CESTType_patterns_ = [['^[0-9]{7}$']]

    def validate_indEscalaType(self, value):
        # Validate type indEscalaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indEscalaType' % {
        "value": value.encode("utf-8")})

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_cBenefType(self, value):
        # Validate type cBenefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 10:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd length restriction on cBenefType' % {
        "value": value.encode("utf-8")})

    def validate_EXTIPIType(self, value):
        # Validate type EXTIPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_EXTIPIType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_EXTIPIType_patterns_, ))
    validate_EXTIPIType_patterns_ = [['^[0-9]{2,3}$']]

    def validate_CFOPType(self, value):
        # Validate type CFOPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CFOPType_patterns_, ))
    validate_CFOPType_patterns_ = [['^[1,2,3,5,6,7]{1}[0-9]{3}$']]

    def validate_uComType(self, value):
        # Validate type uComType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on uComType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on uComType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_uComType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_uComType_patterns_, ))
    validate_uComType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_cEANTribType(self, value):
        # Validate type cEANTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANTribType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cEANTribType_patterns_, ))
    validate_cEANTribType_patterns_ = [
        ['^[0-9]{0}$|^[0-9]{8}$|^[0-9]{12,14}$']]

    def validate_uTribType(self, value):
        # Validate type uTribType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on uTribType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on uTribType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_uTribType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_uTribType_patterns_, ))
    validate_uTribType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_indTotType(self, value):
        # Validate type indTotType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indTotType' % {
        "value": value.encode("utf-8")})

    def validate_xPedType(self, value):
        # Validate type xPedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xPedType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xPedType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xPedType_patterns_, ))
    validate_xPedType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nItemPedType(self, value):
        # Validate type nItemPedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nItemPedType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nItemPedType_patterns_, ))
    validate_nItemPedType_patterns_ = [['^[0-9]{1,6}$']]

    def validate_TGuid(self, value):
        # Validate type TGuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TGuid_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TGuid_patterns_, ))
    validate_TGuid_patterns_ = [
        ['^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$']]

    def validate_nRECOPIType(self, value):
        # Validate type nRECOPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nRECOPIType' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_nRECOPIType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nRECOPIType_patterns_, ))
    validate_nRECOPIType_patterns_ = [['^[0-9]{20}$']]

    def hasContent_(self):
        if (
            self.cProd is not None or
            self.cEAN is not None or
            self.xProd is not None or
            self.NCM is not None or
            self.NVE or
            self.CEST is not None or
            self.indEscala is not None or
            self.CNPJFab is not None or
            self.cBenef is not None or
            self.EXTIPI is not None or
            self.CFOP is not None or
            self.uCom is not None or
            self.qCom is not None or
            self.vUnCom is not None or
            self.vProd is not None or
            self.cEANTrib is not None or
            self.uTrib is not None or
            self.qTrib is not None or
            self.vUnTrib is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vOutro is not None or
            self.indTot is not None or
            self.DI or
            self.detExport or
            self.xPed is not None or
            self.nItemPed is not None or
            self.nFCI is not None or
            self.rastro or
            self.veicProd is not None or
            self.med is not None or
            self.arma or
            self.comb is not None or
            self.nRECOPI is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='prodType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('prodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='prodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='prodType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='prodType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='prodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scProd>%s</%scProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cProd),
            input_name='cProd')),
                    namespace_,
                    eol_))
        if self.cEAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scEAN>%s</%scEAN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cEAN),
            input_name='cEAN')),
                    namespace_,
                    eol_))
        if self.xProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxProd>%s</%sxProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xProd),
            input_name='xProd')),
                    namespace_,
                    eol_))
        if self.NCM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sNCM>%s</%sNCM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.NCM),
            input_name='NCM')),
                    namespace_,
                    eol_))
        for NVE_ in self.NVE:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sNVE>%s</%sNVE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(NVE_),
            input_name='NVE')),
                    namespace_,
                    eol_))
        if self.CEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCEST>%s</%sCEST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CEST),
            input_name='CEST')),
                    namespace_,
                    eol_))
        if self.indEscala is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindEscala>%s</%sindEscala>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indEscala),
            input_name='indEscala')),
                    namespace_,
                    eol_))
        if self.CNPJFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJFab>%s</%sCNPJFab>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJFab),
            input_name='CNPJFab')),
                    namespace_,
                    eol_))
        if self.cBenef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scBenef>%s</%scBenef>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cBenef),
            input_name='cBenef')),
                    namespace_,
                    eol_))
        if self.EXTIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sEXTIPI>%s</%sEXTIPI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.EXTIPI),
            input_name='EXTIPI')),
                    namespace_,
                    eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCFOP>%s</%sCFOP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CFOP),
            input_name='CFOP')),
                    namespace_,
                    eol_))
        if self.uCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%suCom>%s</%suCom>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.uCom),
            input_name='uCom')),
                    namespace_,
                    eol_))
        if self.qCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqCom>%s</%sqCom>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qCom),
            input_name='qCom')),
                    namespace_,
                    eol_))
        if self.vUnCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svUnCom>%s</%svUnCom>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vUnCom),
            input_name='vUnCom')),
                    namespace_,
                    eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svProd>%s</%svProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vProd),
            input_name='vProd')),
                    namespace_,
                    eol_))
        if self.cEANTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scEANTrib>%s</%scEANTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cEANTrib),
            input_name='cEANTrib')),
                    namespace_,
                    eol_))
        if self.uTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%suTrib>%s</%suTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.uTrib),
            input_name='uTrib')),
                    namespace_,
                    eol_))
        if self.qTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqTrib>%s</%sqTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qTrib),
            input_name='qTrib')),
                    namespace_,
                    eol_))
        if self.vUnTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svUnTrib>%s</%svUnTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vUnTrib),
            input_name='vUnTrib')),
                    namespace_,
                    eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFrete>%s</%svFrete>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFrete),
            input_name='vFrete')),
                    namespace_,
                    eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svSeg>%s</%svSeg>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vSeg),
            input_name='vSeg')),
                    namespace_,
                    eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDesc>%s</%svDesc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDesc),
            input_name='vDesc')),
                    namespace_,
                    eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svOutro>%s</%svOutro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vOutro),
            input_name='vOutro')),
                    namespace_,
                    eol_))
        if self.indTot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindTot>%s</%sindTot>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indTot),
            input_name='indTot')),
                    namespace_,
                    eol_))
        for DI_ in self.DI:
            DI_.export(
                outfile,
                level,
                namespace_,
                name_='DI',
                pretty_print=pretty_print)
        for detExport_ in self.detExport:
            detExport_.export(
                outfile,
                level,
                namespace_,
                name_='detExport',
                pretty_print=pretty_print)
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxPed>%s</%sxPed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xPed),
            input_name='xPed')),
                    namespace_,
                    eol_))
        if self.nItemPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snItemPed>%s</%snItemPed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nItemPed),
            input_name='nItemPed')),
                    namespace_,
                    eol_))
        if self.nFCI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snFCI>%s</%snFCI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nFCI),
            input_name='nFCI')),
                    namespace_,
                    eol_))
        for rastro_ in self.rastro:
            rastro_.export(
                outfile,
                level,
                namespace_,
                name_='rastro',
                pretty_print=pretty_print)
        if self.veicProd is not None:
            self.veicProd.export(
                outfile,
                level,
                namespace_,
                name_='veicProd',
                pretty_print=pretty_print)
        if self.med is not None:
            self.med.export(
                outfile,
                level,
                namespace_,
                name_='med',
                pretty_print=pretty_print)
        for arma_ in self.arma:
            arma_.export(
                outfile,
                level,
                namespace_,
                name_='arma',
                pretty_print=pretty_print)
        if self.comb is not None:
            self.comb.export(
                outfile,
                level,
                namespace_,
                name_='comb',
                pretty_print=pretty_print)
        if self.nRECOPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snRECOPI>%s</%snRECOPI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nRECOPI),
            input_name='nRECOPI')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProd':
            cProd_ = child_.text
            cProd_ = self.gds_validate_string(cProd_, node, 'cProd')
            self.cProd = cProd_
            # validate type cProdType
            self.validate_cProdType(self.cProd)
        elif nodeName_ == 'cEAN':
            cEAN_ = child_.text
            cEAN_ = self.gds_validate_string(cEAN_, node, 'cEAN')
            self.cEAN = cEAN_
            # validate type cEANType
            self.validate_cEANType(self.cEAN)
        elif nodeName_ == 'xProd':
            xProd_ = child_.text
            xProd_ = self.gds_validate_string(xProd_, node, 'xProd')
            self.xProd = xProd_
            # validate type xProdType
            self.validate_xProdType(self.xProd)
        elif nodeName_ == 'NCM':
            NCM_ = child_.text
            NCM_ = self.gds_validate_string(NCM_, node, 'NCM')
            self.NCM = NCM_
            # validate type NCMType
            self.validate_NCMType(self.NCM)
        elif nodeName_ == 'NVE':
            NVE_ = child_.text
            NVE_ = self.gds_validate_string(NVE_, node, 'NVE')
            self.NVE.append(NVE_)
            # validate type NVEType
            self.validate_NVEType(self.NVE[-1])
        elif nodeName_ == 'CEST':
            CEST_ = child_.text
            CEST_ = self.gds_validate_string(CEST_, node, 'CEST')
            self.CEST = CEST_
            # validate type CESTType
            self.validate_CESTType(self.CEST)
        elif nodeName_ == 'indEscala':
            indEscala_ = child_.text
            indEscala_ = self.gds_validate_string(
                indEscala_, node, 'indEscala')
            self.indEscala = indEscala_
            # validate type indEscalaType
            self.validate_indEscalaType(self.indEscala)
        elif nodeName_ == 'CNPJFab':
            CNPJFab_ = child_.text
            CNPJFab_ = self.gds_validate_string(CNPJFab_, node, 'CNPJFab')
            self.CNPJFab = CNPJFab_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJFab)
        elif nodeName_ == 'cBenef':
            cBenef_ = child_.text
            cBenef_ = self.gds_validate_string(cBenef_, node, 'cBenef')
            self.cBenef = cBenef_
            # validate type cBenefType
            self.validate_cBenefType(self.cBenef)
        elif nodeName_ == 'EXTIPI':
            EXTIPI_ = child_.text
            EXTIPI_ = self.gds_validate_string(EXTIPI_, node, 'EXTIPI')
            self.EXTIPI = EXTIPI_
            # validate type EXTIPIType
            self.validate_EXTIPIType(self.EXTIPI)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType
            self.validate_CFOPType(self.CFOP)
        elif nodeName_ == 'uCom':
            uCom_ = child_.text
            uCom_ = self.gds_validate_string(uCom_, node, 'uCom')
            self.uCom = uCom_
            # validate type uComType
            self.validate_uComType(self.uCom)
        elif nodeName_ == 'qCom':
            qCom_ = child_.text
            qCom_ = self.gds_validate_string(qCom_, node, 'qCom')
            self.qCom = qCom_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qCom)
        elif nodeName_ == 'vUnCom':
            vUnCom_ = child_.text
            vUnCom_ = self.gds_validate_string(vUnCom_, node, 'vUnCom')
            self.vUnCom = vUnCom_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnCom)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'cEANTrib':
            cEANTrib_ = child_.text
            cEANTrib_ = self.gds_validate_string(cEANTrib_, node, 'cEANTrib')
            self.cEANTrib = cEANTrib_
            # validate type cEANTribType
            self.validate_cEANTribType(self.cEANTrib)
        elif nodeName_ == 'uTrib':
            uTrib_ = child_.text
            uTrib_ = self.gds_validate_string(uTrib_, node, 'uTrib')
            self.uTrib = uTrib_
            # validate type uTribType
            self.validate_uTribType(self.uTrib)
        elif nodeName_ == 'qTrib':
            qTrib_ = child_.text
            qTrib_ = self.gds_validate_string(qTrib_, node, 'qTrib')
            self.qTrib = qTrib_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qTrib)
        elif nodeName_ == 'vUnTrib':
            vUnTrib_ = child_.text
            vUnTrib_ = self.gds_validate_string(vUnTrib_, node, 'vUnTrib')
            self.vUnTrib = vUnTrib_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnTrib)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'indTot':
            indTot_ = child_.text
            indTot_ = self.gds_validate_string(indTot_, node, 'indTot')
            self.indTot = indTot_
            # validate type indTotType
            self.validate_indTotType(self.indTot)
        elif nodeName_ == 'DI':
            obj_ = DIType.factory()
            obj_.build(child_)
            self.DI.append(obj_)
            obj_.original_tagname_ = 'DI'
        elif nodeName_ == 'detExport':
            obj_ = detExportType.factory()
            obj_.build(child_)
            self.detExport.append(obj_)
            obj_.original_tagname_ = 'detExport'
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType
            self.validate_xPedType(self.xPed)
        elif nodeName_ == 'nItemPed':
            nItemPed_ = child_.text
            nItemPed_ = self.gds_validate_string(nItemPed_, node, 'nItemPed')
            self.nItemPed = nItemPed_
            # validate type nItemPedType
            self.validate_nItemPedType(self.nItemPed)
        elif nodeName_ == 'nFCI':
            nFCI_ = child_.text
            nFCI_ = self.gds_validate_string(nFCI_, node, 'nFCI')
            self.nFCI = nFCI_
            # validate type TGuid
            self.validate_TGuid(self.nFCI)
        elif nodeName_ == 'rastro':
            obj_ = rastroType.factory()
            obj_.build(child_)
            self.rastro.append(obj_)
            obj_.original_tagname_ = 'rastro'
        elif nodeName_ == 'veicProd':
            obj_ = veicProdType.factory()
            obj_.build(child_)
            self.veicProd = obj_
            obj_.original_tagname_ = 'veicProd'
        elif nodeName_ == 'med':
            obj_ = medType.factory()
            obj_.build(child_)
            self.med = obj_
            obj_.original_tagname_ = 'med'
        elif nodeName_ == 'arma':
            obj_ = armaType.factory()
            obj_.build(child_)
            self.arma.append(obj_)
            obj_.original_tagname_ = 'arma'
        elif nodeName_ == 'comb':
            obj_ = combType.factory()
            obj_.build(child_)
            self.comb = obj_
            obj_.original_tagname_ = 'comb'
        elif nodeName_ == 'nRECOPI':
            nRECOPI_ = child_.text
            nRECOPI_ = self.gds_validate_string(nRECOPI_, node, 'nRECOPI')
            self.nRECOPI = nRECOPI_
            # validate type nRECOPIType
            self.validate_nRECOPIType(self.nRECOPI)
# end class prodType


class DIType(GeneratedsSuper):
    """Delcaração de Importação
(NT 2011/004)"""
    subclass = None
    superclass = None

    def __init__(self, nDI=None, dDI=None, xLocDesemb=None, UFDesemb=None, dDesemb=None, tpViaTransp=None,
                 vAFRMM=None, tpIntermedio=None, CNPJ=None, UFTerceiro=None, cExportador=None, adi=None):
        self.original_tagname_ = None
        self.nDI = nDI
        self.validate_nDIType(self.nDI)
        self.dDI = dDI
        self.validate_TData(self.dDI)
        self.xLocDesemb = xLocDesemb
        self.validate_xLocDesembType(self.xLocDesemb)
        self.UFDesemb = UFDesemb
        self.validate_TUfEmi(self.UFDesemb)
        self.dDesemb = dDesemb
        self.validate_TData(self.dDesemb)
        self.tpViaTransp = tpViaTransp
        self.validate_tpViaTranspType(self.tpViaTransp)
        self.vAFRMM = vAFRMM
        self.validate_TDec_1302(self.vAFRMM)
        self.tpIntermedio = tpIntermedio
        self.validate_tpIntermedioType(self.tpIntermedio)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.UFTerceiro = UFTerceiro
        self.validate_TUfEmi(self.UFTerceiro)
        self.cExportador = cExportador
        self.validate_cExportadorType(self.cExportador)
        if adi is None:
            self.adi = []
        else:
            self.adi = adi

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DIType.subclass:
            return DIType.subclass(*args_, **kwargs_)
        else:
            return DIType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nDI(self): return self.nDI

    def set_nDI(self, nDI): self.nDI = nDI

    def get_dDI(self): return self.dDI

    def set_dDI(self, dDI): self.dDI = dDI

    def get_xLocDesemb(self): return self.xLocDesemb

    def set_xLocDesemb(self, xLocDesemb): self.xLocDesemb = xLocDesemb

    def get_UFDesemb(self): return self.UFDesemb

    def set_UFDesemb(self, UFDesemb): self.UFDesemb = UFDesemb

    def get_dDesemb(self): return self.dDesemb

    def set_dDesemb(self, dDesemb): self.dDesemb = dDesemb

    def get_tpViaTransp(self): return self.tpViaTransp

    def set_tpViaTransp(self, tpViaTransp): self.tpViaTransp = tpViaTransp

    def get_vAFRMM(self): return self.vAFRMM

    def set_vAFRMM(self, vAFRMM): self.vAFRMM = vAFRMM

    def get_tpIntermedio(self): return self.tpIntermedio

    def set_tpIntermedio(self, tpIntermedio): self.tpIntermedio = tpIntermedio

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_UFTerceiro(self): return self.UFTerceiro

    def set_UFTerceiro(self, UFTerceiro): self.UFTerceiro = UFTerceiro

    def get_cExportador(self): return self.cExportador

    def set_cExportador(self, cExportador): self.cExportador = cExportador

    def get_adi(self): return self.adi

    def set_adi(self, adi): self.adi = adi

    def add_adi(self, value): self.adi.append(value)

    def insert_adi_at(self, index, value): self.adi.insert(index, value)

    def replace_adi_at(self, index, value): self.adi[index] = value

    def validate_nDIType(self, value):
        # Validate type nDIType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 12:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nDIType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nDIType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nDIType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nDIType_patterns_, ))
    validate_nDIType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]

    def validate_xLocDesembType(self, value):
        # Validate type xLocDesembType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLocDesembType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLocDesembType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDesembType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLocDesembType_patterns_, ))
    validate_xLocDesembType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {
        "value": value.encode("utf-8")})

    def validate_tpViaTranspType(self, value):
        # Validate type tpViaTranspType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5',
                            '6', '7', '8', '9', '10', '11', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpViaTranspType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_tpIntermedioType(self, value):
        # Validate type tpIntermedioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpIntermedioType' % {
        "value": value.encode("utf-8")})

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_cExportadorType(self, value):
        # Validate type cExportadorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cExportadorType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cExportadorType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cExportadorType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cExportadorType_patterns_, ))
    validate_cExportadorType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.nDI is not None or
            self.dDI is not None or
            self.xLocDesemb is not None or
            self.UFDesemb is not None or
            self.dDesemb is not None or
            self.tpViaTransp is not None or
            self.vAFRMM is not None or
            self.tpIntermedio is not None or
            self.CNPJ is not None or
            self.UFTerceiro is not None or
            self.cExportador is not None or
            self.adi
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='DIType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='DIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='DIType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='DIType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='DIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snDI>%s</%snDI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nDI),
            input_name='nDI')),
                    namespace_,
                    eol_))
        if self.dDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdDI>%s</%sdDI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dDI),
            input_name='dDI')),
                    namespace_,
                    eol_))
        if self.xLocDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLocDesemb>%s</%sxLocDesemb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLocDesemb),
            input_name='xLocDesemb')),
                    namespace_,
                    eol_))
        if self.UFDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUFDesemb>%s</%sUFDesemb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UFDesemb),
            input_name='UFDesemb')),
                    namespace_,
                    eol_))
        if self.dDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdDesemb>%s</%sdDesemb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dDesemb),
            input_name='dDesemb')),
                    namespace_,
                    eol_))
        if self.tpViaTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpViaTransp>%s</%stpViaTransp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpViaTransp),
            input_name='tpViaTransp')),
                    namespace_,
                    eol_))
        if self.vAFRMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAFRMM>%s</%svAFRMM>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAFRMM),
            input_name='vAFRMM')),
                    namespace_,
                    eol_))
        if self.tpIntermedio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpIntermedio>%s</%stpIntermedio>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpIntermedio),
            input_name='tpIntermedio')),
                    namespace_,
                    eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.UFTerceiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUFTerceiro>%s</%sUFTerceiro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UFTerceiro),
            input_name='UFTerceiro')),
                    namespace_,
                    eol_))
        if self.cExportador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scExportador>%s</%scExportador>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cExportador),
            input_name='cExportador')),
                    namespace_,
                    eol_))
        for adi_ in self.adi:
            adi_.export(
                outfile,
                level,
                namespace_,
                name_='adi',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDI':
            nDI_ = child_.text
            nDI_ = self.gds_validate_string(nDI_, node, 'nDI')
            self.nDI = nDI_
            # validate type nDIType
            self.validate_nDIType(self.nDI)
        elif nodeName_ == 'dDI':
            dDI_ = child_.text
            dDI_ = self.gds_validate_string(dDI_, node, 'dDI')
            self.dDI = dDI_
            # validate type TData
            self.validate_TData(self.dDI)
        elif nodeName_ == 'xLocDesemb':
            xLocDesemb_ = child_.text
            xLocDesemb_ = self.gds_validate_string(
                xLocDesemb_, node, 'xLocDesemb')
            self.xLocDesemb = xLocDesemb_
            # validate type xLocDesembType
            self.validate_xLocDesembType(self.xLocDesemb)
        elif nodeName_ == 'UFDesemb':
            UFDesemb_ = child_.text
            UFDesemb_ = self.gds_validate_string(UFDesemb_, node, 'UFDesemb')
            self.UFDesemb = UFDesemb_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFDesemb)
        elif nodeName_ == 'dDesemb':
            dDesemb_ = child_.text
            dDesemb_ = self.gds_validate_string(dDesemb_, node, 'dDesemb')
            self.dDesemb = dDesemb_
            # validate type TData
            self.validate_TData(self.dDesemb)
        elif nodeName_ == 'tpViaTransp':
            tpViaTransp_ = child_.text
            tpViaTransp_ = self.gds_validate_string(
                tpViaTransp_, node, 'tpViaTransp')
            self.tpViaTransp = tpViaTransp_
            # validate type tpViaTranspType
            self.validate_tpViaTranspType(self.tpViaTransp)
        elif nodeName_ == 'vAFRMM':
            vAFRMM_ = child_.text
            vAFRMM_ = self.gds_validate_string(vAFRMM_, node, 'vAFRMM')
            self.vAFRMM = vAFRMM_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vAFRMM)
        elif nodeName_ == 'tpIntermedio':
            tpIntermedio_ = child_.text
            tpIntermedio_ = self.gds_validate_string(
                tpIntermedio_, node, 'tpIntermedio')
            self.tpIntermedio = tpIntermedio_
            # validate type tpIntermedioType
            self.validate_tpIntermedioType(self.tpIntermedio)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'UFTerceiro':
            UFTerceiro_ = child_.text
            UFTerceiro_ = self.gds_validate_string(
                UFTerceiro_, node, 'UFTerceiro')
            self.UFTerceiro = UFTerceiro_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFTerceiro)
        elif nodeName_ == 'cExportador':
            cExportador_ = child_.text
            cExportador_ = self.gds_validate_string(
                cExportador_, node, 'cExportador')
            self.cExportador = cExportador_
            # validate type cExportadorType
            self.validate_cExportadorType(self.cExportador)
        elif nodeName_ == 'adi':
            obj_ = adiType.factory()
            obj_.build(child_)
            self.adi.append(obj_)
            obj_.original_tagname_ = 'adi'
# end class DIType


class adiType(GeneratedsSuper):
    """Adições (NT 2011/004)"""
    subclass = None
    superclass = None

    def __init__(self, nAdicao=None, nSeqAdic=None,
                 cFabricante=None, vDescDI=None, nDraw=None):
        self.original_tagname_ = None
        self.nAdicao = nAdicao
        self.validate_nAdicaoType(self.nAdicao)
        self.nSeqAdic = nSeqAdic
        self.validate_nSeqAdicType(self.nSeqAdic)
        self.cFabricante = cFabricante
        self.validate_cFabricanteType(self.cFabricante)
        self.vDescDI = vDescDI
        self.validate_TDec_1302Opc(self.vDescDI)
        self.nDraw = nDraw
        self.validate_nDrawType(self.nDraw)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adiType.subclass:
            return adiType.subclass(*args_, **kwargs_)
        else:
            return adiType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nAdicao(self): return self.nAdicao

    def set_nAdicao(self, nAdicao): self.nAdicao = nAdicao

    def get_nSeqAdic(self): return self.nSeqAdic

    def set_nSeqAdic(self, nSeqAdic): self.nSeqAdic = nSeqAdic

    def get_cFabricante(self): return self.cFabricante

    def set_cFabricante(self, cFabricante): self.cFabricante = cFabricante

    def get_vDescDI(self): return self.vDescDI

    def set_vDescDI(self, vDescDI): self.vDescDI = vDescDI

    def get_nDraw(self): return self.nDraw

    def set_nDraw(self, nDraw): self.nDraw = nDraw

    def validate_nAdicaoType(self, value):
        # Validate type nAdicaoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nAdicaoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nAdicaoType_patterns_, ))
    validate_nAdicaoType_patterns_ = [['^[1-9]{1}[0-9]{0,2}$']]

    def validate_nSeqAdicType(self, value):
        # Validate type nSeqAdicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nSeqAdicType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nSeqAdicType_patterns_, ))
    validate_nSeqAdicType_patterns_ = [['^[1-9]{1}[0-9]{0,2}$']]

    def validate_cFabricanteType(self, value):
        # Validate type cFabricanteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cFabricanteType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cFabricanteType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cFabricanteType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cFabricanteType_patterns_, ))
    validate_cFabricanteType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_nDrawType(self, value):
        # Validate type nDrawType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nDrawType_patterns_, ))
    validate_nDrawType_patterns_ = [['^[0-9]{0,11}$']]

    def hasContent_(self):
        if (
            self.nAdicao is not None or
            self.nSeqAdic is not None or
            self.cFabricante is not None or
            self.vDescDI is not None or
            self.nDraw is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='adiType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='adiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='adiType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='adiType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='adiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nAdicao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snAdicao>%s</%snAdicao>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nAdicao),
            input_name='nAdicao')),
                    namespace_,
                    eol_))
        if self.nSeqAdic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snSeqAdic>%s</%snSeqAdic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nSeqAdic),
            input_name='nSeqAdic')),
                    namespace_,
                    eol_))
        if self.cFabricante is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scFabricante>%s</%scFabricante>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cFabricante),
            input_name='cFabricante')),
                    namespace_,
                    eol_))
        if self.vDescDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDescDI>%s</%svDescDI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDescDI),
            input_name='vDescDI')),
                    namespace_,
                    eol_))
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snDraw>%s</%snDraw>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nDraw),
            input_name='nDraw')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nAdicao':
            nAdicao_ = child_.text
            nAdicao_ = self.gds_validate_string(nAdicao_, node, 'nAdicao')
            self.nAdicao = nAdicao_
            # validate type nAdicaoType
            self.validate_nAdicaoType(self.nAdicao)
        elif nodeName_ == 'nSeqAdic':
            nSeqAdic_ = child_.text
            nSeqAdic_ = self.gds_validate_string(nSeqAdic_, node, 'nSeqAdic')
            self.nSeqAdic = nSeqAdic_
            # validate type nSeqAdicType
            self.validate_nSeqAdicType(self.nSeqAdic)
        elif nodeName_ == 'cFabricante':
            cFabricante_ = child_.text
            cFabricante_ = self.gds_validate_string(
                cFabricante_, node, 'cFabricante')
            self.cFabricante = cFabricante_
            # validate type cFabricanteType
            self.validate_cFabricanteType(self.cFabricante)
        elif nodeName_ == 'vDescDI':
            vDescDI_ = child_.text
            vDescDI_ = self.gds_validate_string(vDescDI_, node, 'vDescDI')
            self.vDescDI = vDescDI_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescDI)
        elif nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType
            self.validate_nDrawType(self.nDraw)
# end class adiType


class detExportType(GeneratedsSuper):
    """Detalhe da exportação"""
    subclass = None
    superclass = None

    def __init__(self, nDraw=None, exportInd=None):
        self.original_tagname_ = None
        self.nDraw = nDraw
        self.validate_nDrawType6(self.nDraw)
        self.exportInd = exportInd

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detExportType.subclass:
            return detExportType.subclass(*args_, **kwargs_)
        else:
            return detExportType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nDraw(self): return self.nDraw

    def set_nDraw(self, nDraw): self.nDraw = nDraw

    def get_exportInd(self): return self.exportInd

    def set_exportInd(self, exportInd): self.exportInd = exportInd

    def validate_nDrawType6(self, value):
        # Validate type nDrawType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType6_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nDrawType6_patterns_, ))
    validate_nDrawType6_patterns_ = [['^[0-9]{0,11}$']]

    def hasContent_(self):
        if (
            self.nDraw is not None or
            self.exportInd is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='detExportType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='detExportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='detExportType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='detExportType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='detExportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snDraw>%s</%snDraw>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nDraw),
            input_name='nDraw')),
                    namespace_,
                    eol_))
        if self.exportInd is not None:
            self.exportInd.export(
                outfile,
                level,
                namespace_,
                name_='exportInd',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType6
            self.validate_nDrawType6(self.nDraw)
        elif nodeName_ == 'exportInd':
            obj_ = exportIndType.factory()
            obj_.build(child_)
            self.exportInd = obj_
            obj_.original_tagname_ = 'exportInd'
# end class detExportType


class exportIndType(GeneratedsSuper):
    """Exportação indireta"""
    subclass = None
    superclass = None

    def __init__(self, nRE=None, chNFe=None, qExport=None):
        self.original_tagname_ = None
        self.nRE = nRE
        self.validate_nREType(self.nRE)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.qExport = qExport
        self.validate_TDec_1104v(self.qExport)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportIndType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportIndType.subclass:
            return exportIndType.subclass(*args_, **kwargs_)
        else:
            return exportIndType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nRE(self): return self.nRE

    def set_nRE(self, nRE): self.nRE = nRE

    def get_chNFe(self): return self.chNFe

    def set_chNFe(self, chNFe): self.chNFe = chNFe

    def get_qExport(self): return self.qExport

    def set_qExport(self, qExport): self.qExport = qExport

    def validate_nREType(self, value):
        # Validate type nREType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nREType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nREType_patterns_, ))
    validate_nREType_patterns_ = [['^[0-9]{0,12}$']]

    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def hasContent_(self):
        if (
            self.nRE is not None or
            self.chNFe is not None or
            self.qExport is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='exportIndType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportIndType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='exportIndType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='exportIndType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='exportIndType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='exportIndType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snRE>%s</%snRE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nRE),
            input_name='nRE')),
                    namespace_,
                    eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%schNFe>%s</%schNFe>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.chNFe),
            input_name='chNFe')),
                    namespace_,
                    eol_))
        if self.qExport is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqExport>%s</%sqExport>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qExport),
            input_name='qExport')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRE':
            nRE_ = child_.text
            nRE_ = self.gds_validate_string(nRE_, node, 'nRE')
            self.nRE = nRE_
            # validate type nREType
            self.validate_nREType(self.nRE)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'qExport':
            qExport_ = child_.text
            qExport_ = self.gds_validate_string(qExport_, node, 'qExport')
            self.qExport = qExport_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qExport)
# end class exportIndType


class rastroType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, nLote=None, qLote=None,
                 dFab=None, dVal=None, cAgreg=None):
        self.original_tagname_ = None
        self.nLote = nLote
        self.validate_nLoteType(self.nLote)
        self.qLote = qLote
        self.validate_TDec_0803v(self.qLote)
        self.dFab = dFab
        self.validate_TData(self.dFab)
        self.dVal = dVal
        self.validate_TData(self.dVal)
        self.cAgreg = cAgreg
        self.validate_cAgregType(self.cAgreg)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rastroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rastroType.subclass:
            return rastroType.subclass(*args_, **kwargs_)
        else:
            return rastroType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nLote(self): return self.nLote

    def set_nLote(self, nLote): self.nLote = nLote

    def get_qLote(self): return self.qLote

    def set_qLote(self, qLote): self.qLote = qLote

    def get_dFab(self): return self.dFab

    def set_dFab(self, dFab): self.dFab = dFab

    def get_dVal(self): return self.dVal

    def set_dVal(self, dVal): self.dVal = dVal

    def get_cAgreg(self): return self.cAgreg

    def set_cAgreg(self, cAgreg): self.cAgreg = cAgreg

    def validate_nLoteType(self, value):
        # Validate type nLoteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nLoteType' % {
        "value": value.encode("utf-8")})
            if len(value) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nLoteType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0803v(self, value):
        # Validate type TDec_0803v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0803v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0803v_patterns_, ))
    validate_TDec_0803v_patterns_ = [
        ['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,7}(\\.[0-9]{1,3})?$']]

    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]

    def validate_cAgregType(self, value):
        # Validate type cAgregType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cAgregType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.nLote is not None or
            self.qLote is not None or
            self.dFab is not None or
            self.dVal is not None or
            self.cAgreg is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='rastroType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rastroType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='rastroType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='rastroType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='rastroType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='rastroType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snLote>%s</%snLote>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nLote),
            input_name='nLote')),
                    namespace_,
                    eol_))
        if self.qLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqLote>%s</%sqLote>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qLote),
            input_name='qLote')),
                    namespace_,
                    eol_))
        if self.dFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdFab>%s</%sdFab>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dFab),
            input_name='dFab')),
                    namespace_,
                    eol_))
        if self.dVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdVal>%s</%sdVal>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dVal),
            input_name='dVal')),
                    namespace_,
                    eol_))
        if self.cAgreg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scAgreg>%s</%scAgreg>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cAgreg),
            input_name='cAgreg')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLote':
            nLote_ = child_.text
            nLote_ = self.gds_validate_string(nLote_, node, 'nLote')
            self.nLote = nLote_
            # validate type nLoteType
            self.validate_nLoteType(self.nLote)
        elif nodeName_ == 'qLote':
            qLote_ = child_.text
            qLote_ = self.gds_validate_string(qLote_, node, 'qLote')
            self.qLote = qLote_
            # validate type TDec_0803v
            self.validate_TDec_0803v(self.qLote)
        elif nodeName_ == 'dFab':
            dFab_ = child_.text
            dFab_ = self.gds_validate_string(dFab_, node, 'dFab')
            self.dFab = dFab_
            # validate type TData
            self.validate_TData(self.dFab)
        elif nodeName_ == 'dVal':
            dVal_ = child_.text
            dVal_ = self.gds_validate_string(dVal_, node, 'dVal')
            self.dVal = dVal_
            # validate type TData
            self.validate_TData(self.dVal)
        elif nodeName_ == 'cAgreg':
            cAgreg_ = child_.text
            cAgreg_ = self.gds_validate_string(cAgreg_, node, 'cAgreg')
            self.cAgreg = cAgreg_
            # validate type cAgregType
            self.validate_cAgregType(self.cAgreg)
# end class rastroType


class veicProdType(GeneratedsSuper):
    """Veículos novos"""
    subclass = None
    superclass = None

    def __init__(self, tpOp=None, chassi=None, cCor=None, xCor=None, pot=None, cilin=None, pesoL=None, pesoB=None, nSerie=None, tpComb=None, nMotor=None, CMT=None,
                 dist=None, anoMod=None, anoFab=None, tpPint=None, tpVeic=None, espVeic=None, VIN=None, condVeic=None, cMod=None, cCorDENATRAN=None, lota=None, tpRest=None):
        self.original_tagname_ = None
        self.tpOp = tpOp
        self.validate_tpOpType(self.tpOp)
        self.chassi = chassi
        self.validate_chassiType(self.chassi)
        self.cCor = cCor
        self.validate_cCorType(self.cCor)
        self.xCor = xCor
        self.validate_xCorType(self.xCor)
        self.pot = pot
        self.validate_potType(self.pot)
        self.cilin = cilin
        self.validate_cilinType(self.cilin)
        self.pesoL = pesoL
        self.validate_pesoLType(self.pesoL)
        self.pesoB = pesoB
        self.validate_pesoBType(self.pesoB)
        self.nSerie = nSerie
        self.validate_nSerieType(self.nSerie)
        self.tpComb = tpComb
        self.validate_tpCombType(self.tpComb)
        self.nMotor = nMotor
        self.validate_nMotorType(self.nMotor)
        self.CMT = CMT
        self.validate_CMTType(self.CMT)
        self.dist = dist
        self.validate_distType(self.dist)
        self.anoMod = anoMod
        self.validate_anoModType(self.anoMod)
        self.anoFab = anoFab
        self.validate_anoFabType(self.anoFab)
        self.tpPint = tpPint
        self.validate_tpPintType(self.tpPint)
        self.tpVeic = tpVeic
        self.validate_tpVeicType(self.tpVeic)
        self.espVeic = espVeic
        self.validate_espVeicType(self.espVeic)
        self.VIN = VIN
        self.validate_VINType(self.VIN)
        self.condVeic = condVeic
        self.validate_condVeicType(self.condVeic)
        self.cMod = cMod
        self.validate_cModType(self.cMod)
        self.cCorDENATRAN = cCorDENATRAN
        self.validate_cCorDENATRANType(self.cCorDENATRAN)
        self.lota = lota
        self.validate_lotaType(self.lota)
        self.tpRest = tpRest
        self.validate_tpRestType(self.tpRest)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, veicProdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if veicProdType.subclass:
            return veicProdType.subclass(*args_, **kwargs_)
        else:
            return veicProdType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpOp(self): return self.tpOp

    def set_tpOp(self, tpOp): self.tpOp = tpOp

    def get_chassi(self): return self.chassi

    def set_chassi(self, chassi): self.chassi = chassi

    def get_cCor(self): return self.cCor

    def set_cCor(self, cCor): self.cCor = cCor

    def get_xCor(self): return self.xCor

    def set_xCor(self, xCor): self.xCor = xCor

    def get_pot(self): return self.pot

    def set_pot(self, pot): self.pot = pot

    def get_cilin(self): return self.cilin

    def set_cilin(self, cilin): self.cilin = cilin

    def get_pesoL(self): return self.pesoL

    def set_pesoL(self, pesoL): self.pesoL = pesoL

    def get_pesoB(self): return self.pesoB

    def set_pesoB(self, pesoB): self.pesoB = pesoB

    def get_nSerie(self): return self.nSerie

    def set_nSerie(self, nSerie): self.nSerie = nSerie

    def get_tpComb(self): return self.tpComb

    def set_tpComb(self, tpComb): self.tpComb = tpComb

    def get_nMotor(self): return self.nMotor

    def set_nMotor(self, nMotor): self.nMotor = nMotor

    def get_CMT(self): return self.CMT

    def set_CMT(self, CMT): self.CMT = CMT

    def get_dist(self): return self.dist

    def set_dist(self, dist): self.dist = dist

    def get_anoMod(self): return self.anoMod

    def set_anoMod(self, anoMod): self.anoMod = anoMod

    def get_anoFab(self): return self.anoFab

    def set_anoFab(self, anoFab): self.anoFab = anoFab

    def get_tpPint(self): return self.tpPint

    def set_tpPint(self, tpPint): self.tpPint = tpPint

    def get_tpVeic(self): return self.tpVeic

    def set_tpVeic(self, tpVeic): self.tpVeic = tpVeic

    def get_espVeic(self): return self.espVeic

    def set_espVeic(self, espVeic): self.espVeic = espVeic

    def get_VIN(self): return self.VIN

    def set_VIN(self, VIN): self.VIN = VIN

    def get_condVeic(self): return self.condVeic

    def set_condVeic(self, condVeic): self.condVeic = condVeic

    def get_cMod(self): return self.cMod

    def set_cMod(self, cMod): self.cMod = cMod

    def get_cCorDENATRAN(self): return self.cCorDENATRAN

    def set_cCorDENATRAN(self, cCorDENATRAN): self.cCorDENATRAN = cCorDENATRAN

    def get_lota(self): return self.lota

    def set_lota(self, lota): self.lota = lota

    def get_tpRest(self): return self.tpRest

    def set_tpRest(self, tpRest): self.tpRest = tpRest

    def validate_tpOpType(self, value):
        # Validate type tpOpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpOpType' % {
        "value": value.encode("utf-8")})

    def validate_chassiType(self, value):
        # Validate type chassiType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 17:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd length restriction on chassiType' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_chassiType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_chassiType_patterns_, ))
    validate_chassiType_patterns_ = [['^[A-Z0-9]+$']]

    def validate_cCorType(self, value):
        # Validate type cCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cCorType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cCorType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cCorType_patterns_, ))
    validate_cCorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xCorType(self, value):
        # Validate type xCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xCorType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xCorType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xCorType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xCorType_patterns_, ))
    validate_xCorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_potType(self, value):
        # Validate type potType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on potType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on potType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_potType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_potType_patterns_, ))
    validate_potType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_cilinType(self, value):
        # Validate type cilinType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cilinType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cilinType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cilinType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cilinType_patterns_, ))
    validate_cilinType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_pesoLType(self, value):
        # Validate type pesoLType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on pesoLType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on pesoLType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoLType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_pesoLType_patterns_, ))
    validate_pesoLType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_pesoBType(self, value):
        # Validate type pesoBType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on pesoBType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on pesoBType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoBType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_pesoBType_patterns_, ))
    validate_pesoBType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nSerieType(self, value):
        # Validate type nSerieType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nSerieType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nSerieType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nSerieType_patterns_, ))
    validate_nSerieType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_tpCombType(self, value):
        # Validate type tpCombType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on tpCombType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on tpCombType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCombType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_tpCombType_patterns_, ))
    validate_tpCombType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nMotorType(self, value):
        # Validate type nMotorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 21:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nMotorType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nMotorType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nMotorType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nMotorType_patterns_, ))
    validate_nMotorType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_CMTType(self, value):
        # Validate type CMTType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on CMTType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on CMTType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_CMTType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CMTType_patterns_, ))
    validate_CMTType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_distType(self, value):
        # Validate type distType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on distType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on distType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_distType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_distType_patterns_, ))
    validate_distType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_anoModType(self, value):
        # Validate type anoModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoModType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_anoModType_patterns_, ))
    validate_anoModType_patterns_ = [['^[0-9]{4}$']]

    def validate_anoFabType(self, value):
        # Validate type anoFabType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoFabType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_anoFabType_patterns_, ))
    validate_anoFabType_patterns_ = [['^[0-9]{4}$']]

    def validate_tpPintType(self, value):
        # Validate type tpPintType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd length restriction on tpPintType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_tpPintType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_tpPintType_patterns_, ))
    validate_tpPintType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_tpVeicType(self, value):
        # Validate type tpVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpVeicType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_tpVeicType_patterns_, ))
    validate_tpVeicType_patterns_ = [['^[0-9]{1,2}$']]

    def validate_espVeicType(self, value):
        # Validate type espVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_espVeicType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_espVeicType_patterns_, ))
    validate_espVeicType_patterns_ = [['^[0-9]{1}$']]

    def validate_VINType(self, value):
        # Validate type VINType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['R', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on VINType' % {
        "value": value.encode("utf-8")})
            if len(str(value)) != 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd length restriction on VINType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_VINType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_VINType_patterns_, ))
    validate_VINType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_condVeicType(self, value):
        # Validate type condVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on condVeicType' % {
        "value": value.encode("utf-8")})

    def validate_cModType(self, value):
        # Validate type cModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cModType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cModType_patterns_, ))
    validate_cModType_patterns_ = [['^[0-9]{1,6}$']]

    def validate_cCorDENATRANType(self, value):
        # Validate type cCorDENATRANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cCorDENATRANType' % {
        "value": value.encode("utf-8")})
            if len(value) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cCorDENATRANType' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorDENATRANType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cCorDENATRANType_patterns_, ))
    validate_cCorDENATRANType_patterns_ = [['^[0-9]{1,2}$']]

    def validate_lotaType(self, value):
        # Validate type lotaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on lotaType' % {
        "value": value.encode("utf-8")})
            if len(value) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on lotaType' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_lotaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_lotaType_patterns_, ))
    validate_lotaType_patterns_ = [['^[0-9]{1,3}$']]

    def validate_tpRestType(self, value):
        # Validate type tpRestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpRestType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.tpOp is not None or
            self.chassi is not None or
            self.cCor is not None or
            self.xCor is not None or
            self.pot is not None or
            self.cilin is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.nSerie is not None or
            self.tpComb is not None or
            self.nMotor is not None or
            self.CMT is not None or
            self.dist is not None or
            self.anoMod is not None or
            self.anoFab is not None or
            self.tpPint is not None or
            self.tpVeic is not None or
            self.espVeic is not None or
            self.VIN is not None or
            self.condVeic is not None or
            self.cMod is not None or
            self.cCorDENATRAN is not None or
            self.lota is not None or
            self.tpRest is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='veicProdType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('veicProdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='veicProdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='veicProdType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='veicProdType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='veicProdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpOp>%s</%stpOp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpOp),
            input_name='tpOp')),
                    namespace_,
                    eol_))
        if self.chassi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%schassi>%s</%schassi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.chassi),
            input_name='chassi')),
                    namespace_,
                    eol_))
        if self.cCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scCor>%s</%scCor>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cCor),
            input_name='cCor')),
                    namespace_,
                    eol_))
        if self.xCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxCor>%s</%sxCor>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xCor),
            input_name='xCor')),
                    namespace_,
                    eol_))
        if self.pot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spot>%s</%spot>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pot),
            input_name='pot')),
                    namespace_,
                    eol_))
        if self.cilin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scilin>%s</%scilin>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cilin),
            input_name='cilin')),
                    namespace_,
                    eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spesoL>%s</%spesoL>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pesoL),
            input_name='pesoL')),
                    namespace_,
                    eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spesoB>%s</%spesoB>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pesoB),
            input_name='pesoB')),
                    namespace_,
                    eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snSerie>%s</%snSerie>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nSerie),
            input_name='nSerie')),
                    namespace_,
                    eol_))
        if self.tpComb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpComb>%s</%stpComb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpComb),
            input_name='tpComb')),
                    namespace_,
                    eol_))
        if self.nMotor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snMotor>%s</%snMotor>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nMotor),
            input_name='nMotor')),
                    namespace_,
                    eol_))
        if self.CMT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCMT>%s</%sCMT>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CMT),
            input_name='CMT')),
                    namespace_,
                    eol_))
        if self.dist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdist>%s</%sdist>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dist),
            input_name='dist')),
                    namespace_,
                    eol_))
        if self.anoMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sanoMod>%s</%sanoMod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.anoMod),
            input_name='anoMod')),
                    namespace_,
                    eol_))
        if self.anoFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sanoFab>%s</%sanoFab>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.anoFab),
            input_name='anoFab')),
                    namespace_,
                    eol_))
        if self.tpPint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpPint>%s</%stpPint>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpPint),
            input_name='tpPint')),
                    namespace_,
                    eol_))
        if self.tpVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpVeic>%s</%stpVeic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpVeic),
            input_name='tpVeic')),
                    namespace_,
                    eol_))
        if self.espVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sespVeic>%s</%sespVeic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.espVeic),
            input_name='espVeic')),
                    namespace_,
                    eol_))
        if self.VIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sVIN>%s</%sVIN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.VIN),
            input_name='VIN')),
                    namespace_,
                    eol_))
        if self.condVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scondVeic>%s</%scondVeic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.condVeic),
            input_name='condVeic')),
                    namespace_,
                    eol_))
        if self.cMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMod>%s</%scMod>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMod),
            input_name='cMod')),
                    namespace_,
                    eol_))
        if self.cCorDENATRAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scCorDENATRAN>%s</%scCorDENATRAN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cCorDENATRAN),
            input_name='cCorDENATRAN')),
                    namespace_,
                    eol_))
        if self.lota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%slota>%s</%slota>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.lota),
            input_name='lota')),
                    namespace_,
                    eol_))
        if self.tpRest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpRest>%s</%stpRest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpRest),
            input_name='tpRest')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpOp':
            tpOp_ = child_.text
            tpOp_ = self.gds_validate_string(tpOp_, node, 'tpOp')
            self.tpOp = tpOp_
            # validate type tpOpType
            self.validate_tpOpType(self.tpOp)
        elif nodeName_ == 'chassi':
            chassi_ = child_.text
            chassi_ = self.gds_validate_string(chassi_, node, 'chassi')
            self.chassi = chassi_
            # validate type chassiType
            self.validate_chassiType(self.chassi)
        elif nodeName_ == 'cCor':
            cCor_ = child_.text
            cCor_ = self.gds_validate_string(cCor_, node, 'cCor')
            self.cCor = cCor_
            # validate type cCorType
            self.validate_cCorType(self.cCor)
        elif nodeName_ == 'xCor':
            xCor_ = child_.text
            xCor_ = self.gds_validate_string(xCor_, node, 'xCor')
            self.xCor = xCor_
            # validate type xCorType
            self.validate_xCorType(self.xCor)
        elif nodeName_ == 'pot':
            pot_ = child_.text
            pot_ = self.gds_validate_string(pot_, node, 'pot')
            self.pot = pot_
            # validate type potType
            self.validate_potType(self.pot)
        elif nodeName_ == 'cilin':
            cilin_ = child_.text
            cilin_ = self.gds_validate_string(cilin_, node, 'cilin')
            self.cilin = cilin_
            # validate type cilinType
            self.validate_cilinType(self.cilin)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type pesoLType
            self.validate_pesoLType(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type pesoBType
            self.validate_pesoBType(self.pesoB)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType
            self.validate_nSerieType(self.nSerie)
        elif nodeName_ == 'tpComb':
            tpComb_ = child_.text
            tpComb_ = self.gds_validate_string(tpComb_, node, 'tpComb')
            self.tpComb = tpComb_
            # validate type tpCombType
            self.validate_tpCombType(self.tpComb)
        elif nodeName_ == 'nMotor':
            nMotor_ = child_.text
            nMotor_ = self.gds_validate_string(nMotor_, node, 'nMotor')
            self.nMotor = nMotor_
            # validate type nMotorType
            self.validate_nMotorType(self.nMotor)
        elif nodeName_ == 'CMT':
            CMT_ = child_.text
            CMT_ = self.gds_validate_string(CMT_, node, 'CMT')
            self.CMT = CMT_
            # validate type CMTType
            self.validate_CMTType(self.CMT)
        elif nodeName_ == 'dist':
            dist_ = child_.text
            dist_ = self.gds_validate_string(dist_, node, 'dist')
            self.dist = dist_
            # validate type distType
            self.validate_distType(self.dist)
        elif nodeName_ == 'anoMod':
            anoMod_ = child_.text
            anoMod_ = self.gds_validate_string(anoMod_, node, 'anoMod')
            self.anoMod = anoMod_
            # validate type anoModType
            self.validate_anoModType(self.anoMod)
        elif nodeName_ == 'anoFab':
            anoFab_ = child_.text
            anoFab_ = self.gds_validate_string(anoFab_, node, 'anoFab')
            self.anoFab = anoFab_
            # validate type anoFabType
            self.validate_anoFabType(self.anoFab)
        elif nodeName_ == 'tpPint':
            tpPint_ = child_.text
            tpPint_ = self.gds_validate_string(tpPint_, node, 'tpPint')
            self.tpPint = tpPint_
            # validate type tpPintType
            self.validate_tpPintType(self.tpPint)
        elif nodeName_ == 'tpVeic':
            tpVeic_ = child_.text
            tpVeic_ = self.gds_validate_string(tpVeic_, node, 'tpVeic')
            self.tpVeic = tpVeic_
            # validate type tpVeicType
            self.validate_tpVeicType(self.tpVeic)
        elif nodeName_ == 'espVeic':
            espVeic_ = child_.text
            espVeic_ = self.gds_validate_string(espVeic_, node, 'espVeic')
            self.espVeic = espVeic_
            # validate type espVeicType
            self.validate_espVeicType(self.espVeic)
        elif nodeName_ == 'VIN':
            VIN_ = child_.text
            VIN_ = self.gds_validate_string(VIN_, node, 'VIN')
            self.VIN = VIN_
            # validate type VINType
            self.validate_VINType(self.VIN)
        elif nodeName_ == 'condVeic':
            condVeic_ = child_.text
            condVeic_ = self.gds_validate_string(condVeic_, node, 'condVeic')
            self.condVeic = condVeic_
            # validate type condVeicType
            self.validate_condVeicType(self.condVeic)
        elif nodeName_ == 'cMod':
            cMod_ = child_.text
            cMod_ = self.gds_validate_string(cMod_, node, 'cMod')
            self.cMod = cMod_
            # validate type cModType
            self.validate_cModType(self.cMod)
        elif nodeName_ == 'cCorDENATRAN':
            cCorDENATRAN_ = child_.text
            cCorDENATRAN_ = self.gds_validate_string(
                cCorDENATRAN_, node, 'cCorDENATRAN')
            self.cCorDENATRAN = cCorDENATRAN_
            # validate type cCorDENATRANType
            self.validate_cCorDENATRANType(self.cCorDENATRAN)
        elif nodeName_ == 'lota':
            lota_ = child_.text
            lota_ = self.gds_validate_string(lota_, node, 'lota')
            self.lota = lota_
            # validate type lotaType
            self.validate_lotaType(self.lota)
        elif nodeName_ == 'tpRest':
            tpRest_ = child_.text
            tpRest_ = self.gds_validate_string(tpRest_, node, 'tpRest')
            self.tpRest = tpRest_
            # validate type tpRestType
            self.validate_tpRestType(self.tpRest)
# end class veicProdType


class medType(GeneratedsSuper):
    """grupo do detalhamento de Medicamentos e de matérias-primas farmacêuticas"""
    subclass = None
    superclass = None

    def __init__(self, cProdANVISA=None, vPMC=None):
        self.original_tagname_ = None
        self.cProdANVISA = cProdANVISA
        self.validate_cProdANVISAType(self.cProdANVISA)
        self.vPMC = vPMC
        self.validate_TDec_1302(self.vPMC)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medType.subclass:
            return medType.subclass(*args_, **kwargs_)
        else:
            return medType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cProdANVISA(self): return self.cProdANVISA

    def set_cProdANVISA(self, cProdANVISA): self.cProdANVISA = cProdANVISA

    def get_vPMC(self): return self.vPMC

    def set_vPMC(self, vPMC): self.vPMC = vPMC

    def validate_cProdANVISAType(self, value):
        # Validate type cProdANVISAType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 13:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd length restriction on cProdANVISAType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANVISAType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cProdANVISAType_patterns_, ))
    validate_cProdANVISAType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.cProdANVISA is not None or
            self.vPMC is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='medType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('medType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='medType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='medType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='medType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='medType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANVISA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scProdANVISA>%s</%scProdANVISA>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cProdANVISA),
            input_name='cProdANVISA')),
                    namespace_,
                    eol_))
        if self.vPMC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPMC>%s</%svPMC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPMC),
            input_name='vPMC')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANVISA':
            cProdANVISA_ = child_.text
            cProdANVISA_ = self.gds_validate_string(
                cProdANVISA_, node, 'cProdANVISA')
            self.cProdANVISA = cProdANVISA_
            # validate type cProdANVISAType
            self.validate_cProdANVISAType(self.cProdANVISA)
        elif nodeName_ == 'vPMC':
            vPMC_ = child_.text
            vPMC_ = self.gds_validate_string(vPMC_, node, 'vPMC')
            self.vPMC = vPMC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPMC)
# end class medType


class armaType(GeneratedsSuper):
    """Armamentos"""
    subclass = None
    superclass = None

    def __init__(self, tpArma=None, nSerie=None, nCano=None, descr=None):
        self.original_tagname_ = None
        self.tpArma = tpArma
        self.validate_tpArmaType(self.tpArma)
        self.nSerie = nSerie
        self.validate_nSerieType7(self.nSerie)
        self.nCano = nCano
        self.validate_nCanoType(self.nCano)
        self.descr = descr
        self.validate_descrType(self.descr)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, armaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if armaType.subclass:
            return armaType.subclass(*args_, **kwargs_)
        else:
            return armaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpArma(self): return self.tpArma

    def set_tpArma(self, tpArma): self.tpArma = tpArma

    def get_nSerie(self): return self.nSerie

    def set_nSerie(self, nSerie): self.nSerie = nSerie

    def get_nCano(self): return self.nCano

    def set_nCano(self, nCano): self.nCano = nCano

    def get_descr(self): return self.descr

    def set_descr(self, descr): self.descr = descr

    def validate_tpArmaType(self, value):
        # Validate type tpArmaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpArmaType' % {
        "value": value.encode("utf-8")})

    def validate_nSerieType7(self, value):
        # Validate type nSerieType7, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nSerieType7' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nSerieType7' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType7_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nSerieType7_patterns_, ))
    validate_nSerieType7_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nCanoType(self, value):
        # Validate type nCanoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nCanoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nCanoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nCanoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nCanoType_patterns_, ))
    validate_nCanoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_descrType(self, value):
        # Validate type descrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on descrType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on descrType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_descrType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_descrType_patterns_, ))
    validate_descrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.tpArma is not None or
            self.nSerie is not None or
            self.nCano is not None or
            self.descr is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='armaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('armaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='armaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='armaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='armaType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='armaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpArma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpArma>%s</%stpArma>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpArma),
            input_name='tpArma')),
                    namespace_,
                    eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snSerie>%s</%snSerie>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nSerie),
            input_name='nSerie')),
                    namespace_,
                    eol_))
        if self.nCano is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snCano>%s</%snCano>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nCano),
            input_name='nCano')),
                    namespace_,
                    eol_))
        if self.descr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdescr>%s</%sdescr>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.descr),
            input_name='descr')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpArma':
            tpArma_ = child_.text
            tpArma_ = self.gds_validate_string(tpArma_, node, 'tpArma')
            self.tpArma = tpArma_
            # validate type tpArmaType
            self.validate_tpArmaType(self.tpArma)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType7
            self.validate_nSerieType7(self.nSerie)
        elif nodeName_ == 'nCano':
            nCano_ = child_.text
            nCano_ = self.gds_validate_string(nCano_, node, 'nCano')
            self.nCano = nCano_
            # validate type nCanoType
            self.validate_nCanoType(self.nCano)
        elif nodeName_ == 'descr':
            descr_ = child_.text
            descr_ = self.gds_validate_string(descr_, node, 'descr')
            self.descr = descr_
            # validate type descrType
            self.validate_descrType(self.descr)
# end class armaType


class combType(GeneratedsSuper):
    """Informar apenas para operações com combustíveis líquidos"""
    subclass = None
    superclass = None

    def __init__(self, cProdANP=None, descANP=None, pGLP=None, pGNn=None, pGNi=None,
                 vPart=None, CODIF=None, qTemp=None, UFCons=None, CIDE=None, encerrante=None):
        self.original_tagname_ = None
        self.cProdANP = cProdANP
        self.validate_cProdANPType(self.cProdANP)
        self.descANP = descANP
        self.validate_descANPType(self.descANP)
        self.pGLP = pGLP
        self.validate_TDec_0302a04Max100(self.pGLP)
        self.pGNn = pGNn
        self.validate_TDec_0302a04Max100(self.pGNn)
        self.pGNi = pGNi
        self.validate_TDec_0302a04Max100(self.pGNi)
        self.vPart = vPart
        self.validate_TDec_1302(self.vPart)
        self.CODIF = CODIF
        self.validate_CODIFType(self.CODIF)
        self.qTemp = qTemp
        self.validate_TDec_1204temperatura(self.qTemp)
        self.UFCons = UFCons
        self.validate_TUf(self.UFCons)
        self.CIDE = CIDE
        self.encerrante = encerrante

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, combType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if combType.subclass:
            return combType.subclass(*args_, **kwargs_)
        else:
            return combType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_cProdANP(self): return self.cProdANP

    def set_cProdANP(self, cProdANP): self.cProdANP = cProdANP

    def get_descANP(self): return self.descANP

    def set_descANP(self, descANP): self.descANP = descANP

    def get_pGLP(self): return self.pGLP

    def set_pGLP(self, pGLP): self.pGLP = pGLP

    def get_pGNn(self): return self.pGNn

    def set_pGNn(self, pGNn): self.pGNn = pGNn

    def get_pGNi(self): return self.pGNi

    def set_pGNi(self, pGNi): self.pGNi = pGNi

    def get_vPart(self): return self.vPart

    def set_vPart(self, vPart): self.vPart = vPart

    def get_CODIF(self): return self.CODIF

    def set_CODIF(self, CODIF): self.CODIF = CODIF

    def get_qTemp(self): return self.qTemp

    def set_qTemp(self, qTemp): self.qTemp = qTemp

    def get_UFCons(self): return self.UFCons

    def set_UFCons(self, UFCons): self.UFCons = UFCons

    def get_CIDE(self): return self.CIDE

    def set_CIDE(self, CIDE): self.CIDE = CIDE

    def get_encerrante(self): return self.encerrante

    def set_encerrante(self, encerrante): self.encerrante = encerrante

    def validate_cProdANPType(self, value):
        # Validate type cProdANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANPType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cProdANPType_patterns_, ))
    validate_cProdANPType_patterns_ = [['^[0-9]{9}$']]

    def validate_descANPType(self, value):
        # Validate type descANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 95:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on descANPType' % {
        "value": value.encode("utf-8")})
            if len(value) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on descANPType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [
        ['^[1-9]{1}(\\.[0-9]{2,4})?$|^[1-9]{1}[0-9]{1}(\\.[0-9]{2,4})?$|^100(\\.0{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_CODIFType(self, value):
        # Validate type CODIFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CODIFType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CODIFType_patterns_, ))
    validate_CODIFType_patterns_ = [['^[0-9]{1,21}$']]

    def validate_TDec_1204temperatura(self, value):
        # Validate type TDec_1204temperatura, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204temperatura_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204temperatura_patterns_, ))
    validate_TDec_1204temperatura_patterns_ = [
        ['^0\\.[1-9]{1}[0-9]{3}$|^0\\.[0-9]{3}[1-9]{1}$|^0\\.[0-9]{2}[1-9]{1}[0-9]{1}$|^0\\.[0-9]{1}[1-9]{1}[0-9]{2}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.cProdANP is not None or
            self.descANP is not None or
            self.pGLP is not None or
            self.pGNn is not None or
            self.pGNi is not None or
            self.vPart is not None or
            self.CODIF is not None or
            self.qTemp is not None or
            self.UFCons is not None or
            self.CIDE is not None or
            self.encerrante is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='combType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('combType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='combType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='combType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='combType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='combType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scProdANP>%s</%scProdANP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cProdANP),
            input_name='cProdANP')),
                    namespace_,
                    eol_))
        if self.descANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdescANP>%s</%sdescANP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.descANP),
            input_name='descANP')),
                    namespace_,
                    eol_))
        if self.pGLP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spGLP>%s</%spGLP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pGLP),
            input_name='pGLP')),
                    namespace_,
                    eol_))
        if self.pGNn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spGNn>%s</%spGNn>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pGNn),
            input_name='pGNn')),
                    namespace_,
                    eol_))
        if self.pGNi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spGNi>%s</%spGNi>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pGNi),
            input_name='pGNi')),
                    namespace_,
                    eol_))
        if self.vPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPart>%s</%svPart>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPart),
            input_name='vPart')),
                    namespace_,
                    eol_))
        if self.CODIF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCODIF>%s</%sCODIF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CODIF),
            input_name='CODIF')),
                    namespace_,
                    eol_))
        if self.qTemp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqTemp>%s</%sqTemp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qTemp),
            input_name='qTemp')),
                    namespace_,
                    eol_))
        if self.UFCons is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUFCons>%s</%sUFCons>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UFCons),
            input_name='UFCons')),
                    namespace_,
                    eol_))
        if self.CIDE is not None:
            self.CIDE.export(
                outfile,
                level,
                namespace_,
                name_='CIDE',
                pretty_print=pretty_print)
        if self.encerrante is not None:
            self.encerrante.export(
                outfile,
                level,
                namespace_,
                name_='encerrante',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANP':
            cProdANP_ = child_.text
            cProdANP_ = self.gds_validate_string(cProdANP_, node, 'cProdANP')
            self.cProdANP = cProdANP_
            # validate type cProdANPType
            self.validate_cProdANPType(self.cProdANP)
        elif nodeName_ == 'descANP':
            descANP_ = child_.text
            descANP_ = self.gds_validate_string(descANP_, node, 'descANP')
            self.descANP = descANP_
            # validate type descANPType
            self.validate_descANPType(self.descANP)
        elif nodeName_ == 'pGLP':
            pGLP_ = child_.text
            pGLP_ = self.gds_validate_string(pGLP_, node, 'pGLP')
            self.pGLP = pGLP_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGLP)
        elif nodeName_ == 'pGNn':
            pGNn_ = child_.text
            pGNn_ = self.gds_validate_string(pGNn_, node, 'pGNn')
            self.pGNn = pGNn_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNn)
        elif nodeName_ == 'pGNi':
            pGNi_ = child_.text
            pGNi_ = self.gds_validate_string(pGNi_, node, 'pGNi')
            self.pGNi = pGNi_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNi)
        elif nodeName_ == 'vPart':
            vPart_ = child_.text
            vPart_ = self.gds_validate_string(vPart_, node, 'vPart')
            self.vPart = vPart_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPart)
        elif nodeName_ == 'CODIF':
            CODIF_ = child_.text
            CODIF_ = self.gds_validate_string(CODIF_, node, 'CODIF')
            self.CODIF = CODIF_
            # validate type CODIFType
            self.validate_CODIFType(self.CODIF)
        elif nodeName_ == 'qTemp':
            qTemp_ = child_.text
            qTemp_ = self.gds_validate_string(qTemp_, node, 'qTemp')
            self.qTemp = qTemp_
            # validate type TDec_1204temperatura
            self.validate_TDec_1204temperatura(self.qTemp)
        elif nodeName_ == 'UFCons':
            UFCons_ = child_.text
            UFCons_ = self.gds_validate_string(UFCons_, node, 'UFCons')
            self.UFCons = UFCons_
            # validate type TUf
            self.validate_TUf(self.UFCons)
        elif nodeName_ == 'CIDE':
            obj_ = CIDEType.factory()
            obj_.build(child_)
            self.CIDE = obj_
            obj_.original_tagname_ = 'CIDE'
        elif nodeName_ == 'encerrante':
            obj_ = encerranteType.factory()
            obj_.build(child_)
            self.encerrante = obj_
            obj_.original_tagname_ = 'encerrante'
# end class combType


class CIDEType(GeneratedsSuper):
    """CIDE Combustíveis"""
    subclass = None
    superclass = None

    def __init__(self, qBCProd=None, vAliqProd=None, vCIDE=None):
        self.original_tagname_ = None
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCIDE = vCIDE
        self.validate_TDec_1302(self.vCIDE)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CIDEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CIDEType.subclass:
            return CIDEType.subclass(*args_, **kwargs_)
        else:
            return CIDEType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vCIDE(self): return self.vCIDE

    def set_vCIDE(self, vCIDE): self.vCIDE = vCIDE

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [
        ['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCIDE is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='CIDEType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CIDEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='CIDEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='CIDEType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='CIDEType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='CIDEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vCIDE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCIDE>%s</%svCIDE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCIDE),
            input_name='vCIDE')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCIDE':
            vCIDE_ = child_.text
            vCIDE_ = self.gds_validate_string(vCIDE_, node, 'vCIDE')
            self.vCIDE = vCIDE_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCIDE)
# end class CIDEType


class encerranteType(GeneratedsSuper):
    """Informações do grupo de 'encerrante'"""
    subclass = None
    superclass = None

    def __init__(self, nBico=None, nBomba=None,
                 nTanque=None, vEncIni=None, vEncFin=None):
        self.original_tagname_ = None
        self.nBico = nBico
        self.validate_nBicoType(self.nBico)
        self.nBomba = nBomba
        self.validate_nBombaType(self.nBomba)
        self.nTanque = nTanque
        self.validate_nTanqueType(self.nTanque)
        self.vEncIni = vEncIni
        self.validate_TDec_1203(self.vEncIni)
        self.vEncFin = vEncFin
        self.validate_TDec_1203(self.vEncFin)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, encerranteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if encerranteType.subclass:
            return encerranteType.subclass(*args_, **kwargs_)
        else:
            return encerranteType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nBico(self): return self.nBico

    def set_nBico(self, nBico): self.nBico = nBico

    def get_nBomba(self): return self.nBomba

    def set_nBomba(self, nBomba): self.nBomba = nBomba

    def get_nTanque(self): return self.nTanque

    def set_nTanque(self, nTanque): self.nTanque = nTanque

    def get_vEncIni(self): return self.vEncIni

    def set_vEncIni(self, vEncIni): self.vEncIni = vEncIni

    def get_vEncFin(self): return self.vEncFin

    def set_vEncFin(self, vEncFin): self.vEncFin = vEncFin

    def validate_nBicoType(self, value):
        # Validate type nBicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBicoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nBicoType_patterns_, ))
    validate_nBicoType_patterns_ = [['^[0-9]{1,3}$']]

    def validate_nBombaType(self, value):
        # Validate type nBombaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBombaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nBombaType_patterns_, ))
    validate_nBombaType_patterns_ = [['^[0-9]{1,3}$']]

    def validate_nTanqueType(self, value):
        # Validate type nTanqueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nTanqueType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nTanqueType_patterns_, ))
    validate_nTanqueType_patterns_ = [['^[0-9]{1,3}$']]

    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [
        ['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]

    def hasContent_(self):
        if (
            self.nBico is not None or
            self.nBomba is not None or
            self.nTanque is not None or
            self.vEncIni is not None or
            self.vEncFin is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='encerranteType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('encerranteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='encerranteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='encerranteType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='encerranteType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='encerranteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nBico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snBico>%s</%snBico>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nBico),
            input_name='nBico')),
                    namespace_,
                    eol_))
        if self.nBomba is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snBomba>%s</%snBomba>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nBomba),
            input_name='nBomba')),
                    namespace_,
                    eol_))
        if self.nTanque is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snTanque>%s</%snTanque>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nTanque),
            input_name='nTanque')),
                    namespace_,
                    eol_))
        if self.vEncIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svEncIni>%s</%svEncIni>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vEncIni),
            input_name='vEncIni')),
                    namespace_,
                    eol_))
        if self.vEncFin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svEncFin>%s</%svEncFin>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vEncFin),
            input_name='vEncFin')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nBico':
            nBico_ = child_.text
            nBico_ = self.gds_validate_string(nBico_, node, 'nBico')
            self.nBico = nBico_
            # validate type nBicoType
            self.validate_nBicoType(self.nBico)
        elif nodeName_ == 'nBomba':
            nBomba_ = child_.text
            nBomba_ = self.gds_validate_string(nBomba_, node, 'nBomba')
            self.nBomba = nBomba_
            # validate type nBombaType
            self.validate_nBombaType(self.nBomba)
        elif nodeName_ == 'nTanque':
            nTanque_ = child_.text
            nTanque_ = self.gds_validate_string(nTanque_, node, 'nTanque')
            self.nTanque = nTanque_
            # validate type nTanqueType
            self.validate_nTanqueType(self.nTanque)
        elif nodeName_ == 'vEncIni':
            vEncIni_ = child_.text
            vEncIni_ = self.gds_validate_string(vEncIni_, node, 'vEncIni')
            self.vEncIni = vEncIni_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncIni)
        elif nodeName_ == 'vEncFin':
            vEncFin_ = child_.text
            vEncFin_ = self.gds_validate_string(vEncFin_, node, 'vEncFin')
            self.vEncFin = vEncFin_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncFin)
# end class encerranteType


class impostoType(GeneratedsSuper):
    """Tributos incidentes nos produtos ou serviços da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, vTotTrib=None, ICMS=None, II=None, IPI=None, ISSQN=None,
                 PIS=None, PISST=None, COFINS=None, COFINSST=None, ICMSUFDest=None):
        self.original_tagname_ = None
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
        self.ICMS = ICMS
        self.II = II
        self.IPI = IPI
        self.ISSQN = ISSQN
        self.PIS = PIS
        self.PISST = PISST
        self.COFINS = COFINS
        self.COFINSST = COFINSST
        self.ICMSUFDest = ICMSUFDest

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoType.subclass:
            return impostoType.subclass(*args_, **kwargs_)
        else:
            return impostoType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vTotTrib(self): return self.vTotTrib

    def set_vTotTrib(self, vTotTrib): self.vTotTrib = vTotTrib

    def get_ICMS(self): return self.ICMS

    def set_ICMS(self, ICMS): self.ICMS = ICMS

    def get_II(self): return self.II

    def set_II(self, II): self.II = II

    def get_IPI(self): return self.IPI

    def set_IPI(self, IPI): self.IPI = IPI

    def get_ISSQN(self): return self.ISSQN

    def set_ISSQN(self, ISSQN): self.ISSQN = ISSQN

    def get_PIS(self): return self.PIS

    def set_PIS(self, PIS): self.PIS = PIS

    def get_PISST(self): return self.PISST

    def set_PISST(self, PISST): self.PISST = PISST

    def get_COFINS(self): return self.COFINS

    def set_COFINS(self, COFINS): self.COFINS = COFINS

    def get_COFINSST(self): return self.COFINSST

    def set_COFINSST(self, COFINSST): self.COFINSST = COFINSST

    def get_ICMSUFDest(self): return self.ICMSUFDest

    def set_ICMSUFDest(self, ICMSUFDest): self.ICMSUFDest = ICMSUFDest

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vTotTrib is not None or
            self.ICMS is not None or
            self.II is not None or
            self.IPI is not None or
            self.ISSQN is not None or
            self.PIS is not None or
            self.PISST is not None or
            self.COFINS is not None or
            self.COFINSST is not None or
            self.ICMSUFDest is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='impostoType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='impostoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='impostoType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='impostoType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='impostoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svTotTrib>%s</%svTotTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vTotTrib),
            input_name='vTotTrib')),
                    namespace_,
                    eol_))
        if self.ICMS is not None:
            self.ICMS.export(
                outfile,
                level,
                namespace_,
                name_='ICMS',
                pretty_print=pretty_print)
        if self.II is not None:
            self.II.export(
                outfile,
                level,
                namespace_,
                name_='II',
                pretty_print=pretty_print)
        if self.IPI is not None:
            self.IPI.export(
                outfile,
                level,
                namespace_,
                name_='IPI',
                pretty_print=pretty_print)
        if self.ISSQN is not None:
            self.ISSQN.export(
                outfile,
                level,
                namespace_,
                name_='ISSQN',
                pretty_print=pretty_print)
        if self.PIS is not None:
            self.PIS.export(
                outfile,
                level,
                namespace_,
                name_='PIS',
                pretty_print=pretty_print)
        if self.PISST is not None:
            self.PISST.export(
                outfile,
                level,
                namespace_,
                name_='PISST',
                pretty_print=pretty_print)
        if self.COFINS is not None:
            self.COFINS.export(
                outfile,
                level,
                namespace_,
                name_='COFINS',
                pretty_print=pretty_print)
        if self.COFINSST is not None:
            self.COFINSST.export(
                outfile,
                level,
                namespace_,
                name_='COFINSST',
                pretty_print=pretty_print)
        if self.ICMSUFDest is not None:
            self.ICMSUFDest.export(
                outfile,
                level,
                namespace_,
                name_='ICMSUFDest',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
        elif nodeName_ == 'ICMS':
            obj_ = ICMSType.factory()
            obj_.build(child_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'II':
            obj_ = IIType.factory()
            obj_.build(child_)
            self.II = obj_
            obj_.original_tagname_ = 'II'
        elif nodeName_ == 'IPI':
            obj_ = TIpi.factory()
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
        elif nodeName_ == 'ISSQN':
            obj_ = ISSQNType.factory()
            obj_.build(child_)
            self.ISSQN = obj_
            obj_.original_tagname_ = 'ISSQN'
        elif nodeName_ == 'PIS':
            obj_ = PISType.factory()
            obj_.build(child_)
            self.PIS = obj_
            obj_.original_tagname_ = 'PIS'
        elif nodeName_ == 'PISST':
            obj_ = PISSTType.factory()
            obj_.build(child_)
            self.PISST = obj_
            obj_.original_tagname_ = 'PISST'
        elif nodeName_ == 'COFINS':
            obj_ = COFINSType.factory()
            obj_.build(child_)
            self.COFINS = obj_
            obj_.original_tagname_ = 'COFINS'
        elif nodeName_ == 'COFINSST':
            obj_ = COFINSSTType.factory()
            obj_.build(child_)
            self.COFINSST = obj_
            obj_.original_tagname_ = 'COFINSST'
        elif nodeName_ == 'ICMSUFDest':
            obj_ = ICMSUFDestType.factory()
            obj_.build(child_)
            self.ICMSUFDest = obj_
            obj_.original_tagname_ = 'ICMSUFDest'
# end class impostoType


class ICMSType(GeneratedsSuper):
    """Dados do ICMS Normal e ST"""
    subclass = None
    superclass = None

    def __init__(self, ICMS00=None, ICMS10=None, ICMS20=None, ICMS30=None, ICMS40=None, ICMS51=None, ICMS60=None, ICMS70=None, ICMS90=None,
                 ICMSPart=None, ICMSST=None, ICMSSN101=None, ICMSSN102=None, ICMSSN201=None, ICMSSN202=None, ICMSSN500=None, ICMSSN900=None):
        self.original_tagname_ = None
        self.ICMS00 = ICMS00
        self.ICMS10 = ICMS10
        self.ICMS20 = ICMS20
        self.ICMS30 = ICMS30
        self.ICMS40 = ICMS40
        self.ICMS51 = ICMS51
        self.ICMS60 = ICMS60
        self.ICMS70 = ICMS70
        self.ICMS90 = ICMS90
        self.ICMSPart = ICMSPart
        self.ICMSST = ICMSST
        self.ICMSSN101 = ICMSSN101
        self.ICMSSN102 = ICMSSN102
        self.ICMSSN201 = ICMSSN201
        self.ICMSSN202 = ICMSSN202
        self.ICMSSN500 = ICMSSN500
        self.ICMSSN900 = ICMSSN900

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSType.subclass:
            return ICMSType.subclass(*args_, **kwargs_)
        else:
            return ICMSType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_ICMS00(self): return self.ICMS00

    def set_ICMS00(self, ICMS00): self.ICMS00 = ICMS00

    def get_ICMS10(self): return self.ICMS10

    def set_ICMS10(self, ICMS10): self.ICMS10 = ICMS10

    def get_ICMS20(self): return self.ICMS20

    def set_ICMS20(self, ICMS20): self.ICMS20 = ICMS20

    def get_ICMS30(self): return self.ICMS30

    def set_ICMS30(self, ICMS30): self.ICMS30 = ICMS30

    def get_ICMS40(self): return self.ICMS40

    def set_ICMS40(self, ICMS40): self.ICMS40 = ICMS40

    def get_ICMS51(self): return self.ICMS51

    def set_ICMS51(self, ICMS51): self.ICMS51 = ICMS51

    def get_ICMS60(self): return self.ICMS60

    def set_ICMS60(self, ICMS60): self.ICMS60 = ICMS60

    def get_ICMS70(self): return self.ICMS70

    def set_ICMS70(self, ICMS70): self.ICMS70 = ICMS70

    def get_ICMS90(self): return self.ICMS90

    def set_ICMS90(self, ICMS90): self.ICMS90 = ICMS90

    def get_ICMSPart(self): return self.ICMSPart

    def set_ICMSPart(self, ICMSPart): self.ICMSPart = ICMSPart

    def get_ICMSST(self): return self.ICMSST

    def set_ICMSST(self, ICMSST): self.ICMSST = ICMSST

    def get_ICMSSN101(self): return self.ICMSSN101

    def set_ICMSSN101(self, ICMSSN101): self.ICMSSN101 = ICMSSN101

    def get_ICMSSN102(self): return self.ICMSSN102

    def set_ICMSSN102(self, ICMSSN102): self.ICMSSN102 = ICMSSN102

    def get_ICMSSN201(self): return self.ICMSSN201

    def set_ICMSSN201(self, ICMSSN201): self.ICMSSN201 = ICMSSN201

    def get_ICMSSN202(self): return self.ICMSSN202

    def set_ICMSSN202(self, ICMSSN202): self.ICMSSN202 = ICMSSN202

    def get_ICMSSN500(self): return self.ICMSSN500

    def set_ICMSSN500(self, ICMSSN500): self.ICMSSN500 = ICMSSN500

    def get_ICMSSN900(self): return self.ICMSSN900

    def set_ICMSSN900(self, ICMSSN900): self.ICMSSN900 = ICMSSN900

    def hasContent_(self):
        if (
            self.ICMS00 is not None or
            self.ICMS10 is not None or
            self.ICMS20 is not None or
            self.ICMS30 is not None or
            self.ICMS40 is not None or
            self.ICMS51 is not None or
            self.ICMS60 is not None or
            self.ICMS70 is not None or
            self.ICMS90 is not None or
            self.ICMSPart is not None or
            self.ICMSST is not None or
            self.ICMSSN101 is not None or
            self.ICMSSN102 is not None or
            self.ICMSSN201 is not None or
            self.ICMSSN202 is not None or
            self.ICMSSN500 is not None or
            self.ICMSSN900 is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            self.ICMS00.export(
                outfile,
                level,
                namespace_,
                name_='ICMS00',
                pretty_print=pretty_print)
        if self.ICMS10 is not None:
            self.ICMS10.export(
                outfile,
                level,
                namespace_,
                name_='ICMS10',
                pretty_print=pretty_print)
        if self.ICMS20 is not None:
            self.ICMS20.export(
                outfile,
                level,
                namespace_,
                name_='ICMS20',
                pretty_print=pretty_print)
        if self.ICMS30 is not None:
            self.ICMS30.export(
                outfile,
                level,
                namespace_,
                name_='ICMS30',
                pretty_print=pretty_print)
        if self.ICMS40 is not None:
            self.ICMS40.export(
                outfile,
                level,
                namespace_,
                name_='ICMS40',
                pretty_print=pretty_print)
        if self.ICMS51 is not None:
            self.ICMS51.export(
                outfile,
                level,
                namespace_,
                name_='ICMS51',
                pretty_print=pretty_print)
        if self.ICMS60 is not None:
            self.ICMS60.export(
                outfile,
                level,
                namespace_,
                name_='ICMS60',
                pretty_print=pretty_print)
        if self.ICMS70 is not None:
            self.ICMS70.export(
                outfile,
                level,
                namespace_,
                name_='ICMS70',
                pretty_print=pretty_print)
        if self.ICMS90 is not None:
            self.ICMS90.export(
                outfile,
                level,
                namespace_,
                name_='ICMS90',
                pretty_print=pretty_print)
        if self.ICMSPart is not None:
            self.ICMSPart.export(
                outfile,
                level,
                namespace_,
                name_='ICMSPart',
                pretty_print=pretty_print)
        if self.ICMSST is not None:
            self.ICMSST.export(
                outfile,
                level,
                namespace_,
                name_='ICMSST',
                pretty_print=pretty_print)
        if self.ICMSSN101 is not None:
            self.ICMSSN101.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN101',
                pretty_print=pretty_print)
        if self.ICMSSN102 is not None:
            self.ICMSSN102.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN102',
                pretty_print=pretty_print)
        if self.ICMSSN201 is not None:
            self.ICMSSN201.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN201',
                pretty_print=pretty_print)
        if self.ICMSSN202 is not None:
            self.ICMSSN202.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN202',
                pretty_print=pretty_print)
        if self.ICMSSN500 is not None:
            self.ICMSSN500.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN500',
                pretty_print=pretty_print)
        if self.ICMSSN900 is not None:
            self.ICMSSN900.export(
                outfile,
                level,
                namespace_,
                name_='ICMSSN900',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00Type.factory()
            obj_.build(child_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS10':
            obj_ = ICMS10Type.factory()
            obj_.build(child_)
            self.ICMS10 = obj_
            obj_.original_tagname_ = 'ICMS10'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20Type.factory()
            obj_.build(child_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS30':
            obj_ = ICMS30Type.factory()
            obj_.build(child_)
            self.ICMS30 = obj_
            obj_.original_tagname_ = 'ICMS30'
        elif nodeName_ == 'ICMS40':
            obj_ = ICMS40Type.factory()
            obj_.build(child_)
            self.ICMS40 = obj_
            obj_.original_tagname_ = 'ICMS40'
        elif nodeName_ == 'ICMS51':
            obj_ = ICMS51Type.factory()
            obj_.build(child_)
            self.ICMS51 = obj_
            obj_.original_tagname_ = 'ICMS51'
        elif nodeName_ == 'ICMS60':
            obj_ = ICMS60Type.factory()
            obj_.build(child_)
            self.ICMS60 = obj_
            obj_.original_tagname_ = 'ICMS60'
        elif nodeName_ == 'ICMS70':
            obj_ = ICMS70Type.factory()
            obj_.build(child_)
            self.ICMS70 = obj_
            obj_.original_tagname_ = 'ICMS70'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90Type.factory()
            obj_.build(child_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSPart':
            obj_ = ICMSPartType.factory()
            obj_.build(child_)
            self.ICMSPart = obj_
            obj_.original_tagname_ = 'ICMSPart'
        elif nodeName_ == 'ICMSST':
            obj_ = ICMSSTType.factory()
            obj_.build(child_)
            self.ICMSST = obj_
            obj_.original_tagname_ = 'ICMSST'
        elif nodeName_ == 'ICMSSN101':
            obj_ = ICMSSN101Type.factory()
            obj_.build(child_)
            self.ICMSSN101 = obj_
            obj_.original_tagname_ = 'ICMSSN101'
        elif nodeName_ == 'ICMSSN102':
            obj_ = ICMSSN102Type.factory()
            obj_.build(child_)
            self.ICMSSN102 = obj_
            obj_.original_tagname_ = 'ICMSSN102'
        elif nodeName_ == 'ICMSSN201':
            obj_ = ICMSSN201Type.factory()
            obj_.build(child_)
            self.ICMSSN201 = obj_
            obj_.original_tagname_ = 'ICMSSN201'
        elif nodeName_ == 'ICMSSN202':
            obj_ = ICMSSN202Type.factory()
            obj_.build(child_)
            self.ICMSSN202 = obj_
            obj_.original_tagname_ = 'ICMSSN202'
        elif nodeName_ == 'ICMSSN500':
            obj_ = ICMSSN500Type.factory()
            obj_.build(child_)
            self.ICMSSN500 = obj_
            obj_.original_tagname_ = 'ICMSSN500'
        elif nodeName_ == 'ICMSSN900':
            obj_ = ICMSSN900Type.factory()
            obj_.build(child_)
            self.ICMSSN900 = obj_
            obj_.original_tagname_ = 'ICMSSN900'
# end class ICMSType


class ICMS00Type(GeneratedsSuper):
    """Tributação pelo ICMS
00 - Tributada integralmente"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, vBC=None,
                 pICMS=None, vICMS=None, pFCP=None, vFCP=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType(self.CST)
        self.modBC = modBC
        self.validate_modBCType(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00Type.subclass:
            return ICMS00Type.subclass(*args_, **kwargs_)
        else:
            return ICMS00Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType(self, value):
        # Validate type CSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType' % {
        "value": value.encode("utf-8")})

    def validate_modBCType(self, value):
        # Validate type modBCType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS00Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS00Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS00Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS00Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS00Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType
            self.validate_CSTType(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType
            self.validate_modBCType(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS00Type


class ICMS10Type(GeneratedsSuper):
    """Tributação pelo ICMS
10 - Tributada e com cobrança do ICMS por substituição tributária"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None,
                 modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType8(self.CST)
        self.modBC = modBC
        self.validate_modBCType9(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS10Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS10Type.subclass:
            return ICMS10Type.subclass(*args_, **kwargs_)
        else:
            return ICMS10Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vBCFCP(self): return self.vBCFCP

    def set_vBCFCP(self, vBCFCP): self.vBCFCP = vBCFCP

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType8(self, value):
        # Validate type CSTType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType8' % {
        "value": value.encode("utf-8")})

    def validate_modBCType9(self, value):
        # Validate type modBCType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType9' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_modBCSTType(self, value):
        # Validate type modBCSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS10Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS10Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS10Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS10Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS10Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS10Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCP>%s</%svBCFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCP),
            input_name='vBCFCP')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType8
            self.validate_CSTType8(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType9
            self.validate_modBCType9(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType
            self.validate_modBCSTType(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMS10Type


class ICMS20Type(GeneratedsSuper):
    """Tributção pelo ICMS
20 - Com redução de base de cálculo"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None,
                 vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType10(self.CST)
        self.modBC = modBC
        self.validate_modBCType11(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType(self.motDesICMS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20Type.subclass:
            return ICMS20Type.subclass(*args_, **kwargs_)
        else:
            return ICMS20Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vBCFCP(self): return self.vBCFCP

    def set_vBCFCP(self, vBCFCP): self.vBCFCP = vBCFCP

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_motDesICMS(self): return self.motDesICMS

    def set_motDesICMS(self, motDesICMS): self.motDesICMS = motDesICMS

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType10(self, value):
        # Validate type CSTType10, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['20']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType10' % {
        "value": value.encode("utf-8")})

    def validate_modBCType11(self, value):
        # Validate type modBCType11, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType11' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_motDesICMSType(self, value):
        # Validate type motDesICMSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS20Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS20Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS20Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS20Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS20Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCP>%s</%svBCFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCP),
            input_name='vBCFCP')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smotDesICMS>%s</%smotDesICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.motDesICMS),
            input_name='motDesICMS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType10
            self.validate_CSTType10(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType11
            self.validate_modBCType11(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(
                motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType
            self.validate_motDesICMSType(self.motDesICMS)
# end class ICMS20Type


class ICMS30Type(GeneratedsSuper):
    """Tributação pelo ICMS
30 - Isenta ou não tributada e com cobrança do ICMS por substituição tributária"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None,
                 vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType12(self.CST)
        self.modBCST = modBCST
        self.validate_modBCSTType13(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType14(self.motDesICMS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS30Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS30Type.subclass:
            return ICMS30Type.subclass(*args_, **kwargs_)
        else:
            return ICMS30Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_motDesICMS(self): return self.motDesICMS

    def set_motDesICMS(self, motDesICMS): self.motDesICMS = motDesICMS

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType12(self, value):
        # Validate type CSTType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['30']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType12' % {
        "value": value.encode("utf-8")})

    def validate_modBCSTType13(self, value):
        # Validate type modBCSTType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType13' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_motDesICMSType14(self, value):
        # Validate type motDesICMSType14, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType14' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS30Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS30Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS30Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS30Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS30Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS30Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smotDesICMS>%s</%smotDesICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.motDesICMS),
            input_name='motDesICMS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType12
            self.validate_CSTType12(self.CST)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType13
            self.validate_modBCSTType13(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(
                motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType14
            self.validate_motDesICMSType14(self.motDesICMS)
# end class ICMS30Type


class ICMS40Type(GeneratedsSuper):
    """Tributação pelo ICMS
40 - Isenta
41 - Não tributada
50 - Suspensão"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType15(self.CST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType16(self.motDesICMS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS40Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS40Type.subclass:
            return ICMS40Type.subclass(*args_, **kwargs_)
        else:
            return ICMS40Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_motDesICMS(self): return self.motDesICMS

    def set_motDesICMS(self, motDesICMS): self.motDesICMS = motDesICMS

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType15(self, value):
        # Validate type CSTType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['40', '41', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType15' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_motDesICMSType16(self, value):
        # Validate type motDesICMSType16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '1',
                '3',
                '4',
                '5',
                '6',
                '7',
                '8',
                '9',
                '10',
                '11',
                '16']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType16' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS40Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS40Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS40Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS40Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS40Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS40Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smotDesICMS>%s</%smotDesICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.motDesICMS),
            input_name='motDesICMS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType15
            self.validate_CSTType15(self.CST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(
                motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType16
            self.validate_motDesICMSType16(self.motDesICMS)
# end class ICMS40Type


class ICMS51Type(GeneratedsSuper):
    """Tributção pelo ICMS
51 - Diferimento
A exigência do preenchimento das informações do ICMS diferido fica à critério de cada UF."""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None,
                 vICMSOp=None, pDif=None, vICMSDif=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType17(self.CST)
        self.modBC = modBC
        self.validate_modBCType18(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMSOp = vICMSOp
        self.validate_TDec_1302(self.vICMSOp)
        self.pDif = pDif
        self.validate_TDec_0302a04Max100(self.pDif)
        self.vICMSDif = vICMSDif
        self.validate_TDec_1302(self.vICMSDif)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS51Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS51Type.subclass:
            return ICMS51Type.subclass(*args_, **kwargs_)
        else:
            return ICMS51Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMSOp(self): return self.vICMSOp

    def set_vICMSOp(self, vICMSOp): self.vICMSOp = vICMSOp

    def get_pDif(self): return self.pDif

    def set_pDif(self, pDif): self.pDif = pDif

    def get_vICMSDif(self): return self.vICMSDif

    def set_vICMSDif(self, vICMSDif): self.vICMSDif = vICMSDif

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vBCFCP(self): return self.vBCFCP

    def set_vBCFCP(self, vBCFCP): self.vBCFCP = vBCFCP

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType17(self, value):
        # Validate type CSTType17, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['51']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType17' % {
        "value": value.encode("utf-8")})

    def validate_modBCType18(self, value):
        # Validate type modBCType18, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType18' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [
        ['^[1-9]{1}(\\.[0-9]{2,4})?$|^[1-9]{1}[0-9]{1}(\\.[0-9]{2,4})?$|^100(\\.0{2,4})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMSOp is not None or
            self.pDif is not None or
            self.vICMSDif is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS51Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS51Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS51Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS51Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS51Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS51Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMSOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSOp>%s</%svICMSOp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSOp),
            input_name='vICMSOp')),
                    namespace_,
                    eol_))
        if self.pDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spDif>%s</%spDif>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pDif),
            input_name='pDif')),
                    namespace_,
                    eol_))
        if self.vICMSDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDif>%s</%svICMSDif>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDif),
            input_name='vICMSDif')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCP>%s</%svBCFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCP),
            input_name='vBCFCP')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType17
            self.validate_CSTType17(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType18
            self.validate_modBCType18(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMSOp':
            vICMSOp_ = child_.text
            vICMSOp_ = self.gds_validate_string(vICMSOp_, node, 'vICMSOp')
            self.vICMSOp = vICMSOp_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSOp)
        elif nodeName_ == 'pDif':
            pDif_ = child_.text
            pDif_ = self.gds_validate_string(pDif_, node, 'pDif')
            self.pDif = pDif_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pDif)
        elif nodeName_ == 'vICMSDif':
            vICMSDif_ = child_.text
            vICMSDif_ = self.gds_validate_string(vICMSDif_, node, 'vICMSDif')
            self.vICMSDif = vICMSDif_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDif)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS51Type


class ICMS60Type(GeneratedsSuper):
    """Tributação pelo ICMS
60 - ICMS cobrado anteriormente por substituição tributária"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, vBCSTRet=None, pST=None,
                 vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType19(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS60Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS60Type.subclass:
            return ICMS60Type.subclass(*args_, **kwargs_)
        else:
            return ICMS60Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBCSTRet(self): return self.vBCSTRet

    def set_vBCSTRet(self, vBCSTRet): self.vBCSTRet = vBCSTRet

    def get_pST(self): return self.pST

    def set_pST(self, pST): self.pST = pST

    def get_vICMSSTRet(self): return self.vICMSSTRet

    def set_vICMSSTRet(self, vICMSSTRet): self.vICMSSTRet = vICMSSTRet

    def get_vBCFCPSTRet(self): return self.vBCFCPSTRet

    def set_vBCFCPSTRet(self, vBCFCPSTRet): self.vBCFCPSTRet = vBCFCPSTRet

    def get_pFCPSTRet(self): return self.pFCPSTRet

    def set_pFCPSTRet(self, pFCPSTRet): self.pFCPSTRet = pFCPSTRet

    def get_vFCPSTRet(self): return self.vFCPSTRet

    def set_vFCPSTRet(self, vFCPSTRet): self.vFCPSTRet = vFCPSTRet

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType19(self, value):
        # Validate type CSTType19, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType19' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS60Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS60Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS60Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS60Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS60Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS60Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCSTRet>%s</%svBCSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCSTRet),
            input_name='vBCSTRet')),
                    namespace_,
                    eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spST>%s</%spST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pST),
            input_name='pST')),
                    namespace_,
                    eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSSTRet>%s</%svICMSSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSSTRet),
            input_name='vICMSSTRet')),
                    namespace_,
                    eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPSTRet>%s</%svBCFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPSTRet),
            input_name='vBCFCPSTRet')),
                    namespace_,
                    eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPSTRet>%s</%spFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPSTRet),
            input_name='pFCPSTRet')),
                    namespace_,
                    eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPSTRet>%s</%svFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPSTRet),
            input_name='vFCPSTRet')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType19
            self.validate_CSTType19(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(
                vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(
                vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(
                pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(
                vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
# end class ICMS60Type


class ICMS70Type(GeneratedsSuper):
    """Tributação pelo ICMS
70 - Com redução de base de cálculo e cobrança do ICMS por substituição tributária"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None,
                 pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType20(self.CST)
        self.modBC = modBC
        self.validate_modBCType21(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType22(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType23(self.motDesICMS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS70Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS70Type.subclass:
            return ICMS70Type.subclass(*args_, **kwargs_)
        else:
            return ICMS70Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vBCFCP(self): return self.vBCFCP

    def set_vBCFCP(self, vBCFCP): self.vBCFCP = vBCFCP

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_motDesICMS(self): return self.motDesICMS

    def set_motDesICMS(self, motDesICMS): self.motDesICMS = motDesICMS

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType20(self, value):
        # Validate type CSTType20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['70']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType20' % {
        "value": value.encode("utf-8")})

    def validate_modBCType21(self, value):
        # Validate type modBCType21, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType21' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_modBCSTType22(self, value):
        # Validate type modBCSTType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType22' % {
        "value": value.encode("utf-8")})

    def validate_motDesICMSType23(self, value):
        # Validate type motDesICMSType23, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType23' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS70Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS70Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS70Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS70Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS70Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS70Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCP>%s</%svBCFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCP),
            input_name='vBCFCP')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smotDesICMS>%s</%smotDesICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.motDesICMS),
            input_name='motDesICMS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType20
            self.validate_CSTType20(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType21
            self.validate_modBCType21(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType22
            self.validate_modBCSTType22(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(
                motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType23
            self.validate_motDesICMSType23(self.motDesICMS)
# end class ICMS70Type


class ICMS90Type(GeneratedsSuper):
    """Tributação pelo ICMS
90 - Outras"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None,
                 pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType24(self.CST)
        self.modBC = modBC
        self.validate_modBCType25(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType26(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType27(self.motDesICMS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90Type.subclass:
            return ICMS90Type.subclass(*args_, **kwargs_)
        else:
            return ICMS90Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vBCFCP(self): return self.vBCFCP

    def set_vBCFCP(self, vBCFCP): self.vBCFCP = vBCFCP

    def get_pFCP(self): return self.pFCP

    def set_pFCP(self, pFCP): self.pFCP = pFCP

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_motDesICMS(self): return self.motDesICMS

    def set_motDesICMS(self, motDesICMS): self.motDesICMS = motDesICMS

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType24(self, value):
        # Validate type CSTType24, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType24' % {
        "value": value.encode("utf-8")})

    def validate_modBCType25(self, value):
        # Validate type modBCType25, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType25' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_modBCSTType26(self, value):
        # Validate type modBCSTType26, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType26' % {
        "value": value.encode("utf-8")})

    def validate_motDesICMSType27(self, value):
        # Validate type motDesICMSType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType27' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMS90Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMS90Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMS90Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMS90Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMS90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCP>%s</%svBCFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCP),
            input_name='vBCFCP')),
                    namespace_,
                    eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCP>%s</%spFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCP),
            input_name='pFCP')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smotDesICMS>%s</%smotDesICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.motDesICMS),
            input_name='motDesICMS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType24
            self.validate_CSTType24(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType25
            self.validate_modBCType25(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType26
            self.validate_modBCSTType26(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(
                motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType27
            self.validate_motDesICMSType27(self.motDesICMS)
# end class ICMS90Type


class ICMSPartType(GeneratedsSuper):
    """Partilha do ICMS entre a UF de origem e UF de destino ou a UF definida na legislação
Operação interestadual para consumidor final com partilha do ICMS  devido na operação entre a UF de origem e a UF do destinatário ou ou a UF definida na legislação. (Ex. UF da concessionária de entrega do  veículos)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None,
                 modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, pBCOp=None, UFST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType28(self.CST)
        self.modBC = modBC
        self.validate_modBCType29(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType30(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.pBCOp = pBCOp
        self.validate_TDec_0302a04Opc(self.pBCOp)
        self.UFST = UFST
        self.validate_TUf(self.UFST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSPartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSPartType.subclass:
            return ICMSPartType.subclass(*args_, **kwargs_)
        else:
            return ICMSPartType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_pBCOp(self): return self.pBCOp

    def set_pBCOp(self, pBCOp): self.pBCOp = pBCOp

    def get_UFST(self): return self.UFST

    def set_UFST(self, UFST): self.UFST = UFST

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType28(self, value):
        # Validate type CSTType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10', '90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType28' % {
        "value": value.encode("utf-8")})

    def validate_modBCType29(self, value):
        # Validate type modBCType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType29' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_modBCSTType30(self, value):
        # Validate type modBCSTType30, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType30' % {
        "value": value.encode("utf-8")})

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.pBCOp is not None or
            self.UFST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSPartType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSPartType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSPartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSPartType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSPartType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSPartType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.pBCOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spBCOp>%s</%spBCOp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pBCOp),
            input_name='pBCOp')),
                    namespace_,
                    eol_))
        if self.UFST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUFST>%s</%sUFST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UFST),
            input_name='UFST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType28
            self.validate_CSTType28(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType29
            self.validate_modBCType29(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType30
            self.validate_modBCSTType30(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'pBCOp':
            pBCOp_ = child_.text
            pBCOp_ = self.gds_validate_string(pBCOp_, node, 'pBCOp')
            self.pBCOp = pBCOp_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pBCOp)
        elif nodeName_ == 'UFST':
            UFST_ = child_.text
            UFST_ = self.gds_validate_string(UFST_, node, 'UFST')
            self.UFST = UFST_
            # validate type TUf
            self.validate_TUf(self.UFST)
# end class ICMSPartType


class ICMSSTType(GeneratedsSuper):
    """Grupo de informação do ICMSST devido para a UF de destino, nas operações interestaduais de produtos que tiveram retenção antecipada de ICMS por ST na UF do remetente. Repasse via Substituto Tributário."""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CST=None, vBCSTRet=None,
                 vICMSSTRet=None, vBCSTDest=None, vICMSSTDest=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType31(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCSTDest = vBCSTDest
        self.validate_TDec_1302(self.vBCSTDest)
        self.vICMSSTDest = vICMSSTDest
        self.validate_TDec_1302(self.vICMSSTDest)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSTType.subclass:
            return ICMSSTType.subclass(*args_, **kwargs_)
        else:
            return ICMSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBCSTRet(self): return self.vBCSTRet

    def set_vBCSTRet(self, vBCSTRet): self.vBCSTRet = vBCSTRet

    def get_vICMSSTRet(self): return self.vICMSSTRet

    def set_vICMSSTRet(self, vICMSSTRet): self.vICMSSTRet = vICMSSTRet

    def get_vBCSTDest(self): return self.vBCSTDest

    def set_vBCSTDest(self, vBCSTDest): self.vBCSTDest = vBCSTDest

    def get_vICMSSTDest(self): return self.vICMSSTDest

    def set_vICMSSTDest(self, vICMSSTDest): self.vICMSSTDest = vICMSSTDest

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSTType31(self, value):
        # Validate type CSTType31, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['41', '60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType31' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.vICMSSTRet is not None or
            self.vBCSTDest is not None or
            self.vICMSSTDest is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCSTRet>%s</%svBCSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCSTRet),
            input_name='vBCSTRet')),
                    namespace_,
                    eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSSTRet>%s</%svICMSSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSSTRet),
            input_name='vICMSSTRet')),
                    namespace_,
                    eol_))
        if self.vBCSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCSTDest>%s</%svBCSTDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCSTDest),
            input_name='vBCSTDest')),
                    namespace_,
                    eol_))
        if self.vICMSSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSSTDest>%s</%svICMSSTDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSSTDest),
            input_name='vICMSSTDest')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType31
            self.validate_CSTType31(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(
                vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCSTDest':
            vBCSTDest_ = child_.text
            vBCSTDest_ = self.gds_validate_string(
                vBCSTDest_, node, 'vBCSTDest')
            self.vBCSTDest = vBCSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTDest)
        elif nodeName_ == 'vICMSSTDest':
            vICMSSTDest_ = child_.text
            vICMSSTDest_ = self.gds_validate_string(
                vICMSSTDest_, node, 'vICMSSTDest')
            self.vICMSSTDest = vICMSSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTDest)
# end class ICMSSTType


class ICMSSN101Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=101 (v.2.0)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType(self.CSOSN)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN101Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN101Type.subclass:
            return ICMSSN101Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN101Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def get_pCredSN(self): return self.pCredSN

    def set_pCredSN(self, pCredSN): self.pCredSN = pCredSN

    def get_vCredICMSSN(self): return self.vCredICMSSN

    def set_vCredICMSSN(self, vCredICMSSN): self.vCredICMSSN = vCredICMSSN

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType(self, value):
        # Validate type CSOSNType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['101']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN101Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN101Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN101Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN101Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN101Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN101Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCredSN>%s</%spCredSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCredSN),
            input_name='pCredSN')),
                    namespace_,
                    eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCredICMSSN>%s</%svCredICMSSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCredICMSSN),
            input_name='vCredICMSSN')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType
            self.validate_CSOSNType(self.CSOSN)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(
                vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN101Type


class ICMSSN102Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=102, 103, 300 ou 400 (v.2.0))"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType32(self.CSOSN)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN102Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN102Type.subclass:
            return ICMSSN102Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN102Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType32(self, value):
        # Validate type CSOSNType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['102', '103', '300', '400']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType32' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN102Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN102Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN102Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN102Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN102Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN102Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType32
            self.validate_CSOSNType32(self.CSOSN)
# end class ICMSSN102Type


class ICMSSN201Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=201 (v.2.0)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None,
                 pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType33(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType34(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN201Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN201Type.subclass:
            return ICMSSN201Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN201Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_pCredSN(self): return self.pCredSN

    def set_pCredSN(self, pCredSN): self.pCredSN = pCredSN

    def get_vCredICMSSN(self): return self.vCredICMSSN

    def set_vCredICMSSN(self, vCredICMSSN): self.vCredICMSSN = vCredICMSSN

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType33(self, value):
        # Validate type CSOSNType33, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['201']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType33' % {
        "value": value.encode("utf-8")})

    def validate_modBCSTType34(self, value):
        # Validate type modBCSTType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType34' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN201Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN201Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN201Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN201Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN201Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN201Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCredSN>%s</%spCredSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCredSN),
            input_name='pCredSN')),
                    namespace_,
                    eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCredICMSSN>%s</%svCredICMSSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCredICMSSN),
            input_name='vCredICMSSN')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType33
            self.validate_CSOSNType33(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType34
            self.validate_modBCSTType34(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(
                vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN201Type


class ICMSSN202Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=202 ou 203 (v.2.0)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None,
                 vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType35(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType36(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN202Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN202Type.subclass:
            return ICMSSN202Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN202Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType35(self, value):
        # Validate type CSOSNType35, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['202', '203']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType35' % {
        "value": value.encode("utf-8")})

    def validate_modBCSTType36(self, value):
        # Validate type modBCSTType36, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType36' % {
        "value": value.encode("utf-8")})

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN202Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN202Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN202Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN202Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN202Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN202Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType35
            self.validate_CSOSNType35(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType36
            self.validate_modBCSTType36(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMSSN202Type


class ICMSSN500Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL,CRT=1 – Simples Nacional e CSOSN=500 (v.2.0)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None, vBCSTRet=None, pST=None,
                 vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType37(self.CSOSN)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN500Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN500Type.subclass:
            return ICMSSN500Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN500Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def get_vBCSTRet(self): return self.vBCSTRet

    def set_vBCSTRet(self, vBCSTRet): self.vBCSTRet = vBCSTRet

    def get_pST(self): return self.pST

    def set_pST(self, pST): self.pST = pST

    def get_vICMSSTRet(self): return self.vICMSSTRet

    def set_vICMSSTRet(self, vICMSSTRet): self.vICMSSTRet = vICMSSTRet

    def get_vBCFCPSTRet(self): return self.vBCFCPSTRet

    def set_vBCFCPSTRet(self, vBCFCPSTRet): self.vBCFCPSTRet = vBCFCPSTRet

    def get_pFCPSTRet(self): return self.pFCPSTRet

    def set_pFCPSTRet(self, pFCPSTRet): self.pFCPSTRet = pFCPSTRet

    def get_vFCPSTRet(self): return self.vFCPSTRet

    def set_vFCPSTRet(self, vFCPSTRet): self.vFCPSTRet = vFCPSTRet

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType37(self, value):
        # Validate type CSOSNType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType37' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN500Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN500Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN500Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN500Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN500Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN500Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCSTRet>%s</%svBCSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCSTRet),
            input_name='vBCSTRet')),
                    namespace_,
                    eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spST>%s</%spST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pST),
            input_name='pST')),
                    namespace_,
                    eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSSTRet>%s</%svICMSSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSSTRet),
            input_name='vICMSSTRet')),
                    namespace_,
                    eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPSTRet>%s</%svBCFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPSTRet),
            input_name='vBCFCPSTRet')),
                    namespace_,
                    eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPSTRet>%s</%spFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPSTRet),
            input_name='pFCPSTRet')),
                    namespace_,
                    eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPSTRet>%s</%svFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPSTRet),
            input_name='vFCPSTRet')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType37
            self.validate_CSOSNType37(self.CSOSN)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(
                vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(
                vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(
                pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(
                vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
# end class ICMSSN500Type


class ICMSSN900Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL, CRT=1 – Simples Nacional e CSOSN=900 (v2.0)"""
    subclass = None
    superclass = None

    def __init__(self, orig=None, CSOSN=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, modBCST=None, pMVAST=None,
                 pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType38(self.CSOSN)
        self.modBC = modBC
        self.validate_modBCType39(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType40(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN900Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN900Type.subclass:
            return ICMSSN900Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN900Type(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_orig(self): return self.orig

    def set_orig(self, orig): self.orig = orig

    def get_CSOSN(self): return self.CSOSN

    def set_CSOSN(self, CSOSN): self.CSOSN = CSOSN

    def get_modBC(self): return self.modBC

    def set_modBC(self, modBC): self.modBC = modBC

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pRedBC(self): return self.pRedBC

    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC

    def get_pICMS(self): return self.pICMS

    def set_pICMS(self, pICMS): self.pICMS = pICMS

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_modBCST(self): return self.modBCST

    def set_modBCST(self, modBCST): self.modBCST = modBCST

    def get_pMVAST(self): return self.pMVAST

    def set_pMVAST(self, pMVAST): self.pMVAST = pMVAST

    def get_pRedBCST(self): return self.pRedBCST

    def set_pRedBCST(self, pRedBCST): self.pRedBCST = pRedBCST

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_pICMSST(self): return self.pICMSST

    def set_pICMSST(self, pICMSST): self.pICMSST = pICMSST

    def get_vICMSST(self): return self.vICMSST

    def set_vICMSST(self, vICMSST): self.vICMSST = vICMSST

    def get_vBCFCPST(self): return self.vBCFCPST

    def set_vBCFCPST(self, vBCFCPST): self.vBCFCPST = vBCFCPST

    def get_pFCPST(self): return self.pFCPST

    def set_pFCPST(self, pFCPST): self.pFCPST = pFCPST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_pCredSN(self): return self.pCredSN

    def set_pCredSN(self, pCredSN): self.pCredSN = pCredSN

    def get_vCredICMSSN(self): return self.vCredICMSSN

    def set_vCredICMSSN(self, vCredICMSSN): self.vCredICMSSN = vCredICMSSN

    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on Torig' % {
        "value": value.encode("utf-8")})

    def validate_CSOSNType38(self, value):
        # Validate type CSOSNType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['900']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSOSNType38' % {
        "value": value.encode("utf-8")})

    def validate_modBCType39(self, value):
        # Validate type modBCType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCType39' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [
        ['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_modBCSTType40(self, value):
        # Validate type modBCSTType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modBCSTType40' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSSN900Type',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN900Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSSN900Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSSN900Type',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSSN900Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSSN900Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sorig>%s</%sorig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.orig),
            input_name='orig')),
                    namespace_,
                    eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCSOSN>%s</%sCSOSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CSOSN),
            input_name='CSOSN')),
                    namespace_,
                    eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBC>%s</%smodBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBC),
            input_name='modBC')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBC>%s</%spRedBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBC),
            input_name='pRedBC')),
                    namespace_,
                    eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMS>%s</%spICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMS),
            input_name='pICMS')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodBCST>%s</%smodBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modBCST),
            input_name='modBCST')),
                    namespace_,
                    eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spMVAST>%s</%spMVAST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pMVAST),
            input_name='pMVAST')),
                    namespace_,
                    eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spRedBCST>%s</%spRedBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pRedBCST),
            input_name='pRedBCST')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSST>%s</%spICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSST),
            input_name='pICMSST')),
                    namespace_,
                    eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSST>%s</%svICMSST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSST),
            input_name='vICMSST')),
                    namespace_,
                    eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPST>%s</%svBCFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPST),
            input_name='vBCFCPST')),
                    namespace_,
                    eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPST>%s</%spFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPST),
            input_name='pFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCredSN>%s</%spCredSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCredSN),
            input_name='pCredSN')),
                    namespace_,
                    eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCredICMSSN>%s</%svCredICMSSN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCredICMSSN),
            input_name='vCredICMSSN')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType38
            self.validate_CSOSNType38(self.CSOSN)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType39
            self.validate_modBCType39(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType40
            self.validate_modBCSTType40(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(
                vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN900Type


class IIType(GeneratedsSuper):
    """Dados do Imposto de Importação"""
    subclass = None
    superclass = None

    def __init__(self, vBC=None, vDespAdu=None, vII=None, vIOF=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vDespAdu = vDespAdu
        self.validate_TDec_1302(self.vDespAdu)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIOF = vIOF
        self.validate_TDec_1302(self.vIOF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IIType.subclass:
            return IIType.subclass(*args_, **kwargs_)
        else:
            return IIType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_vDespAdu(self): return self.vDespAdu

    def set_vDespAdu(self, vDespAdu): self.vDespAdu = vDespAdu

    def get_vII(self): return self.vII

    def set_vII(self, vII): self.vII = vII

    def get_vIOF(self): return self.vIOF

    def set_vIOF(self, vIOF): self.vIOF = vIOF

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vDespAdu is not None or
            self.vII is not None or
            self.vIOF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='IIType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='IIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='IIType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='IIType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='IIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.vDespAdu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDespAdu>%s</%svDespAdu>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDespAdu),
            input_name='vDespAdu')),
                    namespace_,
                    eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svII>%s</%svII>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vII),
            input_name='vII')),
                    namespace_,
                    eol_))
        if self.vIOF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIOF>%s</%svIOF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIOF),
            input_name='vIOF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vDespAdu':
            vDespAdu_ = child_.text
            vDespAdu_ = self.gds_validate_string(vDespAdu_, node, 'vDespAdu')
            self.vDespAdu = vDespAdu_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDespAdu)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIOF':
            vIOF_ = child_.text
            vIOF_ = self.gds_validate_string(vIOF_, node, 'vIOF')
            self.vIOF = vIOF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIOF)
# end class IIType


class ISSQNType(GeneratedsSuper):
    """ISSQN"""
    subclass = None
    superclass = None

    def __init__(self, vBC=None, vAliq=None, vISSQN=None, cMunFG=None, cListServ=None, vDeducao=None, vOutro=None, vDescIncond=None,
                 vDescCond=None, vISSRet=None, indISS=None, cServico=None, cMun=None, cPais=None, nProcesso=None, indIncentivo=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vAliq = vAliq
        self.validate_TDec_0302a04(self.vAliq)
        self.vISSQN = vISSQN
        self.validate_TDec_1302(self.vISSQN)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.cListServ = cListServ
        self.validate_TCListServ(self.cListServ)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.indISS = indISS
        self.validate_indISSType(self.indISS)
        self.cServico = cServico
        self.validate_cServicoType(self.cServico)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cPais = cPais
        self.validate_cPaisType(self.cPais)
        self.nProcesso = nProcesso
        self.validate_nProcessoType(self.nProcesso)
        self.indIncentivo = indIncentivo
        self.validate_indIncentivoType(self.indIncentivo)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNType.subclass:
            return ISSQNType.subclass(*args_, **kwargs_)
        else:
            return ISSQNType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_vAliq(self): return self.vAliq

    def set_vAliq(self, vAliq): self.vAliq = vAliq

    def get_vISSQN(self): return self.vISSQN

    def set_vISSQN(self, vISSQN): self.vISSQN = vISSQN

    def get_cMunFG(self): return self.cMunFG

    def set_cMunFG(self, cMunFG): self.cMunFG = cMunFG

    def get_cListServ(self): return self.cListServ

    def set_cListServ(self, cListServ): self.cListServ = cListServ

    def get_vDeducao(self): return self.vDeducao

    def set_vDeducao(self, vDeducao): self.vDeducao = vDeducao

    def get_vOutro(self): return self.vOutro

    def set_vOutro(self, vOutro): self.vOutro = vOutro

    def get_vDescIncond(self): return self.vDescIncond

    def set_vDescIncond(self, vDescIncond): self.vDescIncond = vDescIncond

    def get_vDescCond(self): return self.vDescCond

    def set_vDescCond(self, vDescCond): self.vDescCond = vDescCond

    def get_vISSRet(self): return self.vISSRet

    def set_vISSRet(self, vISSRet): self.vISSRet = vISSRet

    def get_indISS(self): return self.indISS

    def set_indISS(self, indISS): self.indISS = indISS

    def get_cServico(self): return self.cServico

    def set_cServico(self, cServico): self.cServico = cServico

    def get_cMun(self): return self.cMun

    def set_cMun(self, cMun): self.cMun = cMun

    def get_cPais(self): return self.cPais

    def set_cPais(self, cPais): self.cPais = cPais

    def get_nProcesso(self): return self.nProcesso

    def set_nProcesso(self, nProcesso): self.nProcesso = nProcesso

    def get_indIncentivo(self): return self.indIncentivo

    def set_indIncentivo(self, indIncentivo): self.indIncentivo = indIncentivo

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def validate_TCListServ(self, value):
        # Validate type TCListServ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '01.01',
                '01.02',
                '01.03',
                '01.04',
                '01.05',
                '01.06',
                '01.07',
                '01.08',
                '02.01',
                '03.02',
                '03.03',
                '03.04',
                '03.05',
                '04.01',
                '04.02',
                '04.03',
                '04.04',
                '04.05',
                '04.06',
                '04.07',
                '04.08',
                '04.09',
                '04.10',
                '04.11',
                '04.12',
                '04.13',
                '04.14',
                '04.15',
                '04.16',
                '04.17',
                '04.18',
                '04.19',
                '04.20',
                '04.21',
                '04.22',
                '04.23',
                '05.01',
                '05.02',
                '05.03',
                '05.04',
                '05.05',
                '05.06',
                '05.07',
                '05.08',
                '05.09',
                '06.01',
                '06.02',
                '06.03',
                '06.04',
                '06.05',
                '07.01',
                '07.02',
                '07.03',
                '07.04',
                '07.05',
                '07.06',
                '07.07',
                '07.08',
                '07.09',
                '07.10',
                '07.11',
                '07.12',
                '07.13',
                '07.16',
                '07.17',
                '07.18',
                '07.19',
                '07.20',
                '07.21',
                '07.22',
                '08.01',
                '08.02',
                '09.01',
                '09.02',
                '09.03',
                '10.01',
                '10.02',
                '10.03',
                '10.04',
                '10.05',
                '10.06',
                '10.07',
                '10.08',
                '10.09',
                '10.10',
                '11.01',
                '11.02',
                '11.03',
                '11.04',
                '12.01',
                '12.02',
                '12.03',
                '12.04',
                '12.05',
                '12.06',
                '12.07',
                '12.08',
                '12.09',
                '12.10',
                '12.11',
                '12.12',
                '12.13',
                '12.14',
                '12.15',
                '12.16',
                '12.17',
                '13.02',
                '13.03',
                '13.04',
                '13.05',
                '14.01',
                '14.02',
                '14.03',
                '14.04',
                '14.05',
                '14.06',
                '14.07',
                '14.08',
                '14.09',
                '14.10',
                '14.11',
                '14.12',
                '14.13',
                '15.01',
                '15.02',
                '15.03',
                '15.04',
                '15.05',
                '15.06',
                '15.07',
                '15.08',
                '15.09',
                '15.10',
                '15.11',
                '15.12',
                '15.13',
                '15.14',
                '15.15',
                '15.16',
                '15.17',
                '15.18',
                '16.01',
                '17.01',
                '17.02',
                '17.03',
                '17.04',
                '17.05',
                '17.06',
                '17.08',
                '17.09',
                '17.10',
                '17.11',
                '17.12',
                '17.13',
                '17.14',
                '17.15',
                '17.16',
                '17.17',
                '17.18',
                '17.19',
                '17.20',
                '17.21',
                '17.22',
                '17.23',
                '17.24',
                '18.01',
                '19.01',
                '20.01',
                '20.02',
                '20.03',
                '21.01',
                '22.01',
                '23.01',
                '24.01',
                '25.01',
                '25.02',
                '25.03',
                '25.04',
                '26.01',
                '27.01',
                '28.01',
                '29.01',
                '30.01',
                '31.01',
                '32.01',
                '33.01',
                '34.01',
                '35.01',
                '36.01',
                '37.01',
                '38.01',
                '39.01',
                '40.01']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TCListServ' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_indISSType(self, value):
        # Validate type indISSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indISSType' % {
        "value": value.encode("utf-8")})

    def validate_cServicoType(self, value):
        # Validate type cServicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cServicoType' % {
        "value": value.encode("utf-8")})
            if len(value) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cServicoType' % {
        "value": value.encode("utf-8")})

    def validate_cPaisType(self, value):
        # Validate type cPaisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cPaisType_patterns_, ))
    validate_cPaisType_patterns_ = [['^[0-9]{1,4}$']]

    def validate_nProcessoType(self, value):
        # Validate type nProcessoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nProcessoType' % {
        "value": value.encode("utf-8")})
            if len(value) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nProcessoType' % {
        "value": value.encode("utf-8")})

    def validate_indIncentivoType(self, value):
        # Validate type indIncentivoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indIncentivoType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vAliq is not None or
            self.vISSQN is not None or
            self.cMunFG is not None or
            self.cListServ is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.indISS is not None or
            self.cServico is not None or
            self.cMun is not None or
            self.cPais is not None or
            self.nProcesso is not None or
            self.indIncentivo is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ISSQNType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ISSQNType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ISSQNType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ISSQNType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ISSQNType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.vAliq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliq>%s</%svAliq>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliq),
            input_name='vAliq')),
                    namespace_,
                    eol_))
        if self.vISSQN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svISSQN>%s</%svISSQN>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vISSQN),
            input_name='vISSQN')),
                    namespace_,
                    eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMunFG>%s</%scMunFG>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMunFG),
            input_name='cMunFG')),
                    namespace_,
                    eol_))
        if self.cListServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scListServ>%s</%scListServ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cListServ),
            input_name='cListServ')),
                    namespace_,
                    eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDeducao>%s</%svDeducao>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDeducao),
            input_name='vDeducao')),
                    namespace_,
                    eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svOutro>%s</%svOutro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vOutro),
            input_name='vOutro')),
                    namespace_,
                    eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDescIncond>%s</%svDescIncond>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDescIncond),
            input_name='vDescIncond')),
                    namespace_,
                    eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDescCond>%s</%svDescCond>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDescCond),
            input_name='vDescCond')),
                    namespace_,
                    eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svISSRet>%s</%svISSRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vISSRet),
            input_name='vISSRet')),
                    namespace_,
                    eol_))
        if self.indISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindISS>%s</%sindISS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indISS),
            input_name='indISS')),
                    namespace_,
                    eol_))
        if self.cServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scServico>%s</%scServico>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cServico),
            input_name='cServico')),
                    namespace_,
                    eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMun>%s</%scMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMun),
            input_name='cMun')),
                    namespace_,
                    eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scPais>%s</%scPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cPais),
            input_name='cPais')),
                    namespace_,
                    eol_))
        if self.nProcesso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snProcesso>%s</%snProcesso>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nProcesso),
            input_name='nProcesso')),
                    namespace_,
                    eol_))
        if self.indIncentivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindIncentivo>%s</%sindIncentivo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indIncentivo),
            input_name='indIncentivo')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vAliq':
            vAliq_ = child_.text
            vAliq_ = self.gds_validate_string(vAliq_, node, 'vAliq')
            self.vAliq = vAliq_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.vAliq)
        elif nodeName_ == 'vISSQN':
            vISSQN_ = child_.text
            vISSQN_ = self.gds_validate_string(vISSQN_, node, 'vISSQN')
            self.vISSQN = vISSQN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vISSQN)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'cListServ':
            cListServ_ = child_.text
            cListServ_ = self.gds_validate_string(
                cListServ_, node, 'cListServ')
            self.cListServ = cListServ_
            # validate type TCListServ
            self.validate_TCListServ(self.cListServ)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(
                vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(
                vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'indISS':
            indISS_ = child_.text
            indISS_ = self.gds_validate_string(indISS_, node, 'indISS')
            self.indISS = indISS_
            # validate type indISSType
            self.validate_indISSType(self.indISS)
        elif nodeName_ == 'cServico':
            cServico_ = child_.text
            cServico_ = self.gds_validate_string(cServico_, node, 'cServico')
            self.cServico = cServico_
            # validate type cServicoType
            self.validate_cServicoType(self.cServico)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType
            self.validate_cPaisType(self.cPais)
        elif nodeName_ == 'nProcesso':
            nProcesso_ = child_.text
            nProcesso_ = self.gds_validate_string(
                nProcesso_, node, 'nProcesso')
            self.nProcesso = nProcesso_
            # validate type nProcessoType
            self.validate_nProcessoType(self.nProcesso)
        elif nodeName_ == 'indIncentivo':
            indIncentivo_ = child_.text
            indIncentivo_ = self.gds_validate_string(
                indIncentivo_, node, 'indIncentivo')
            self.indIncentivo = indIncentivo_
            # validate type indIncentivoType
            self.validate_indIncentivoType(self.indIncentivo)
# end class ISSQNType


class PISType(GeneratedsSuper):
    """Dados do PIS"""
    subclass = None
    superclass = None

    def __init__(self, PISAliq=None, PISQtde=None, PISNT=None, PISOutr=None):
        self.original_tagname_ = None
        self.PISAliq = PISAliq
        self.PISQtde = PISQtde
        self.PISNT = PISNT
        self.PISOutr = PISOutr

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISType.subclass:
            return PISType.subclass(*args_, **kwargs_)
        else:
            return PISType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_PISAliq(self): return self.PISAliq

    def set_PISAliq(self, PISAliq): self.PISAliq = PISAliq

    def get_PISQtde(self): return self.PISQtde

    def set_PISQtde(self, PISQtde): self.PISQtde = PISQtde

    def get_PISNT(self): return self.PISNT

    def set_PISNT(self, PISNT): self.PISNT = PISNT

    def get_PISOutr(self): return self.PISOutr

    def set_PISOutr(self, PISOutr): self.PISOutr = PISOutr

    def hasContent_(self):
        if (
            self.PISAliq is not None or
            self.PISQtde is not None or
            self.PISNT is not None or
            self.PISOutr is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PISAliq is not None:
            self.PISAliq.export(
                outfile,
                level,
                namespace_,
                name_='PISAliq',
                pretty_print=pretty_print)
        if self.PISQtde is not None:
            self.PISQtde.export(
                outfile,
                level,
                namespace_,
                name_='PISQtde',
                pretty_print=pretty_print)
        if self.PISNT is not None:
            self.PISNT.export(
                outfile,
                level,
                namespace_,
                name_='PISNT',
                pretty_print=pretty_print)
        if self.PISOutr is not None:
            self.PISOutr.export(
                outfile,
                level,
                namespace_,
                name_='PISOutr',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PISAliq':
            obj_ = PISAliqType.factory()
            obj_.build(child_)
            self.PISAliq = obj_
            obj_.original_tagname_ = 'PISAliq'
        elif nodeName_ == 'PISQtde':
            obj_ = PISQtdeType.factory()
            obj_.build(child_)
            self.PISQtde = obj_
            obj_.original_tagname_ = 'PISQtde'
        elif nodeName_ == 'PISNT':
            obj_ = PISNTType.factory()
            obj_.build(child_)
            self.PISNT = obj_
            obj_.original_tagname_ = 'PISNT'
        elif nodeName_ == 'PISOutr':
            obj_ = PISOutrType.factory()
            obj_.build(child_)
            self.PISOutr = obj_
            obj_.original_tagname_ = 'PISOutr'
# end class PISType


class PISAliqType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
 01 – Operação Tributável - Base de Cálculo = Valor da Operação Alíquota Normal (Cumulativo/Não Cumulativo);
02 - Operação Tributável - Base de Calculo = Valor da Operação (Alíquota Diferenciada);"""
    subclass = None
    superclass = None

    def __init__(self, CST=None, vBC=None, pPIS=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType41(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISAliqType.subclass:
            return PISAliqType.subclass(*args_, **kwargs_)
        else:
            return PISAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pPIS(self): return self.pPIS

    def set_pPIS(self, pPIS): self.pPIS = pPIS

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def validate_CSTType41(self, value):
        # Validate type CSTType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType41' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISAliqType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISAliqType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISAliqType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spPIS>%s</%spPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pPIS),
            input_name='pPIS')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType41
            self.validate_CSTType41(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISAliqType


class PISQtdeType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
03 - Operação Tributável - Base de Calculo = Quantidade Vendida x Alíquota por Unidade de Produto;"""
    subclass = None
    superclass = None

    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType42(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISQtdeType.subclass:
            return PISQtdeType.subclass(*args_, **kwargs_)
        else:
            return PISQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def validate_CSTType42(self, value):
        # Validate type CSTType42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType42' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISQtdeType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISQtdeType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISQtdeType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType42
            self.validate_CSTType42(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISQtdeType


class PISNTType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
04 - Operação Tributável - Tributação Monofásica - (Alíquota Zero);
06 - Operação Tributável - Alíquota Zero;
07 - Operação Isenta da contribuição;
08 - Operação Sem Incidência da contribuição;
09 - Operação com suspensão da contribuição;"""
    subclass = None
    superclass = None

    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType43(self.CST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISNTType.subclass:
            return PISNTType.subclass(*args_, **kwargs_)
        else:
            return PISNTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def validate_CSTType43(self, value):
        # Validate type CSTType43, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType43' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISNTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISNTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISNTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType43
            self.validate_CSTType43(self.CST)
# end class PISNTType


class PISOutrType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
99 - Outras Operações."""
    subclass = None
    superclass = None

    def __init__(self, CST=None, vBC=None, pPIS=None,
                 qBCProd=None, vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType44(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISOutrType.subclass:
            return PISOutrType.subclass(*args_, **kwargs_)
        else:
            return PISOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pPIS(self): return self.pPIS

    def set_pPIS(self, pPIS): self.pPIS = pPIS

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def validate_CSTType44(self, value):
        # Validate type CSTType44, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '49',
                '50',
                '51',
                '52',
                '53',
                '54',
                '55',
                '56',
                '60',
                '61',
                '62',
                '63',
                '64',
                '65',
                '66',
                '67',
                '70',
                '71',
                '72',
                '73',
                '74',
                '75',
                '98',
                '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType44' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISOutrType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISOutrType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISOutrType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spPIS>%s</%spPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pPIS),
            input_name='pPIS')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType44
            self.validate_CSTType44(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISOutrType


class PISSTType(GeneratedsSuper):
    """Dados do PIS Substituição Tributária"""
    subclass = None
    superclass = None

    def __init__(self, vBC=None, pPIS=None, qBCProd=None,
                 vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISSTType.subclass:
            return PISSTType.subclass(*args_, **kwargs_)
        else:
            return PISSTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pPIS(self): return self.pPIS

    def set_pPIS(self, pPIS): self.pPIS = pPIS

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]

    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [
        ['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='PISSTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='PISSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='PISSTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='PISSTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='PISSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spPIS>%s</%spPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pPIS),
            input_name='pPIS')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISSTType


class COFINSType(GeneratedsSuper):
    """Dados do COFINS"""
    subclass = None
    superclass = None

    def __init__(self, COFINSAliq=None, COFINSQtde=None,
                 COFINSNT=None, COFINSOutr=None):
        self.original_tagname_ = None
        self.COFINSAliq = COFINSAliq
        self.COFINSQtde = COFINSQtde
        self.COFINSNT = COFINSNT
        self.COFINSOutr = COFINSOutr

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSType.subclass:
            return COFINSType.subclass(*args_, **kwargs_)
        else:
            return COFINSType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_COFINSAliq(self): return self.COFINSAliq

    def set_COFINSAliq(self, COFINSAliq): self.COFINSAliq = COFINSAliq

    def get_COFINSQtde(self): return self.COFINSQtde

    def set_COFINSQtde(self, COFINSQtde): self.COFINSQtde = COFINSQtde

    def get_COFINSNT(self): return self.COFINSNT

    def set_COFINSNT(self, COFINSNT): self.COFINSNT = COFINSNT

    def get_COFINSOutr(self): return self.COFINSOutr

    def set_COFINSOutr(self, COFINSOutr): self.COFINSOutr = COFINSOutr

    def hasContent_(self):
        if (
            self.COFINSAliq is not None or
            self.COFINSQtde is not None or
            self.COFINSNT is not None or
            self.COFINSOutr is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.COFINSAliq is not None:
            self.COFINSAliq.export(
                outfile,
                level,
                namespace_,
                name_='COFINSAliq',
                pretty_print=pretty_print)
        if self.COFINSQtde is not None:
            self.COFINSQtde.export(
                outfile,
                level,
                namespace_,
                name_='COFINSQtde',
                pretty_print=pretty_print)
        if self.COFINSNT is not None:
            self.COFINSNT.export(
                outfile,
                level,
                namespace_,
                name_='COFINSNT',
                pretty_print=pretty_print)
        if self.COFINSOutr is not None:
            self.COFINSOutr.export(
                outfile,
                level,
                namespace_,
                name_='COFINSOutr',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COFINSAliq':
            obj_ = COFINSAliqType.factory()
            obj_.build(child_)
            self.COFINSAliq = obj_
            obj_.original_tagname_ = 'COFINSAliq'
        elif nodeName_ == 'COFINSQtde':
            obj_ = COFINSQtdeType.factory()
            obj_.build(child_)
            self.COFINSQtde = obj_
            obj_.original_tagname_ = 'COFINSQtde'
        elif nodeName_ == 'COFINSNT':
            obj_ = COFINSNTType.factory()
            obj_.build(child_)
            self.COFINSNT = obj_
            obj_.original_tagname_ = 'COFINSNT'
        elif nodeName_ == 'COFINSOutr':
            obj_ = COFINSOutrType.factory()
            obj_.build(child_)
            self.COFINSOutr = obj_
            obj_.original_tagname_ = 'COFINSOutr'
# end class COFINSType


class COFINSAliqType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS.
 01 – Operação Tributável - Base de Cálculo = Valor da Operação Alíquota Normal (Cumulativo/Não Cumulativo);
02 - Operação Tributável - Base de Calculo = Valor da Operação (Alíquota Diferenciada);"""
    subclass = None
    superclass = None

    def __init__(self, CST=None, vBC=None, pCOFINS=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType45(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSAliqType.subclass:
            return COFINSAliqType.subclass(*args_, **kwargs_)
        else:
            return COFINSAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pCOFINS(self): return self.pCOFINS

    def set_pCOFINS(self, pCOFINS): self.pCOFINS = pCOFINS

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def validate_CSTType45(self, value):
        # Validate type CSTType45, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType45' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSAliqType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSAliqType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSAliqType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCOFINS>%s</%spCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCOFINS),
            input_name='pCOFINS')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType45
            self.validate_CSTType45(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSAliqType


class COFINSQtdeType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS.
03 - Operação Tributável - Base de Calculo = Quantidade Vendida x Alíquota por Unidade de Produto;"""
    subclass = None
    superclass = None

    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType46(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSQtdeType.subclass:
            return COFINSQtdeType.subclass(*args_, **kwargs_)
        else:
            return COFINSQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def validate_CSTType46(self, value):
        # Validate type CSTType46, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType46' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSQtdeType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSQtdeType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSQtdeType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType46
            self.validate_CSTType46(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSQtdeType


class COFINSNTType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS:
04 - Operação Tributável - Tributação Monofásica - (Alíquota Zero);
06 - Operação Tributável - Alíquota Zero;
07 - Operação Isenta da contribuição;
08 - Operação Sem Incidência da contribuição;
09 - Operação com suspensão da contribuição;"""
    subclass = None
    superclass = None

    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType47(self.CST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSNTType.subclass:
            return COFINSNTType.subclass(*args_, **kwargs_)
        else:
            return COFINSNTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def validate_CSTType47(self, value):
        # Validate type CSTType47, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType47' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSNTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSNTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSNTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType47
            self.validate_CSTType47(self.CST)
# end class COFINSNTType


class COFINSOutrType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS:
49 - Outras Operações de Saída
50 - Operação com Direito a Crédito - Vinculada Exclusivamente a Receita Tributada no Mercado Interno
51 - Operação com Direito a Crédito – Vinculada Exclusivamente a Receita Não Tributada no Mercado Interno
52 - Operação com Direito a Crédito - Vinculada Exclusivamente a Receita de Exportação
53 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno
54 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas no Mercado Interno e de Exportação
55 - Operação com Direito a Crédito - Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação
56 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação
60 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente a Receita Tributada no Mercado Interno
61 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente a Receita Não-Tributada no Mercado Interno
62 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente a Receita de Exportação
63 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno
64 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas Tributadas no Mercado Interno e de Exportação
65 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação
66 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação
67 - Crédito Presumido - Outras Operações
70 - Operação de Aquisição sem Direito a Crédito
71 - Operação de Aquisição com Isenção
72 - Operação de Aquisição com Suspensão
73 - Operação de Aquisição a Alíquota Zero
74 - Operação de Aquisição sem Incidência da Contribuição
75 - Operação de Aquisição por Substituição Tributária
98 - Outras Operações de Entrada
99 - Outras Operações."""
    subclass = None
    superclass = None

    def __init__(self, CST=None, vBC=None, pCOFINS=None,
                 qBCProd=None, vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType48(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSOutrType.subclass:
            return COFINSOutrType.subclass(*args_, **kwargs_)
        else:
            return COFINSOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pCOFINS(self): return self.pCOFINS

    def set_pCOFINS(self, pCOFINS): self.pCOFINS = pCOFINS

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def validate_CSTType48(self, value):
        # Validate type CSTType48, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '49',
                '50',
                '51',
                '52',
                '53',
                '54',
                '55',
                '56',
                '60',
                '61',
                '62',
                '63',
                '64',
                '65',
                '66',
                '67',
                '70',
                '71',
                '72',
                '73',
                '74',
                '75',
                '98',
                '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType48' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSOutrType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSOutrType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSOutrType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCOFINS>%s</%spCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCOFINS),
            input_name='pCOFINS')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType48
            self.validate_CSTType48(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSOutrType


class COFINSSTType(GeneratedsSuper):
    """Dados do COFINS da
Substituição Tributaria;"""
    subclass = None
    superclass = None

    def __init__(self, vBC=None, pCOFINS=None, qBCProd=None,
                 vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSSTType.subclass:
            return COFINSSTType.subclass(*args_, **kwargs_)
        else:
            return COFINSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pCOFINS(self): return self.pCOFINS

    def set_pCOFINS(self, pCOFINS): self.pCOFINS = pCOFINS

    def get_qBCProd(self): return self.qBCProd

    def set_qBCProd(self, qBCProd): self.qBCProd = qBCProd

    def get_vAliqProd(self): return self.vAliqProd

    def set_vAliqProd(self, vAliqProd): self.vAliqProd = vAliqProd

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]

    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [
        ['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]

    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='COFINSSTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='COFINSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='COFINSSTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='COFINSSTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='COFINSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spCOFINS>%s</%spCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pCOFINS),
            input_name='pCOFINS')),
                    namespace_,
                    eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqBCProd>%s</%sqBCProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qBCProd),
            input_name='qBCProd')),
                    namespace_,
                    eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svAliqProd>%s</%svAliqProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vAliqProd),
            input_name='vAliqProd')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(
                vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSSTType


class ICMSUFDestType(GeneratedsSuper):
    """Grupo a ser informado nas vendas interestarduais para consumidor final, não contribuinte de ICMS"""
    subclass = None
    superclass = None

    def __init__(self, vBCUFDest=None, vBCFCPUFDest=None, pFCPUFDest=None, pICMSUFDest=None,
                 pICMSInter=None, pICMSInterPart=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None):
        self.original_tagname_ = None
        self.vBCUFDest = vBCUFDest
        self.validate_TDec_1302(self.vBCUFDest)
        self.vBCFCPUFDest = vBCFCPUFDest
        self.validate_TDec_1302(self.vBCFCPUFDest)
        self.pFCPUFDest = pFCPUFDest
        self.validate_TDec_0302a04(self.pFCPUFDest)
        self.pICMSUFDest = pICMSUFDest
        self.validate_TDec_0302a04(self.pICMSUFDest)
        self.pICMSInter = pICMSInter
        self.validate_pICMSInterType(self.pICMSInter)
        self.pICMSInterPart = pICMSInterPart
        self.validate_TDec_0302a04(self.pICMSInterPart)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFDestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFDestType.subclass:
            return ICMSUFDestType.subclass(*args_, **kwargs_)
        else:
            return ICMSUFDestType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBCUFDest(self): return self.vBCUFDest

    def set_vBCUFDest(self, vBCUFDest): self.vBCUFDest = vBCUFDest

    def get_vBCFCPUFDest(self): return self.vBCFCPUFDest

    def set_vBCFCPUFDest(self, vBCFCPUFDest): self.vBCFCPUFDest = vBCFCPUFDest

    def get_pFCPUFDest(self): return self.pFCPUFDest

    def set_pFCPUFDest(self, pFCPUFDest): self.pFCPUFDest = pFCPUFDest

    def get_pICMSUFDest(self): return self.pICMSUFDest

    def set_pICMSUFDest(self, pICMSUFDest): self.pICMSUFDest = pICMSUFDest

    def get_pICMSInter(self): return self.pICMSInter

    def set_pICMSInter(self, pICMSInter): self.pICMSInter = pICMSInter

    def get_pICMSInterPart(self): return self.pICMSInterPart

    def set_pICMSInterPart(
        self, pICMSInterPart): self.pICMSInterPart = pICMSInterPart

    def get_vFCPUFDest(self): return self.vFCPUFDest

    def set_vFCPUFDest(self, vFCPUFDest): self.vFCPUFDest = vFCPUFDest

    def get_vICMSUFDest(self): return self.vICMSUFDest

    def set_vICMSUFDest(self, vICMSUFDest): self.vICMSUFDest = vICMSUFDest

    def get_vICMSUFRemet(self): return self.vICMSUFRemet

    def set_vICMSUFRemet(self, vICMSUFRemet): self.vICMSUFRemet = vICMSUFRemet

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_pICMSInterType(self, value):
        # Validate type pICMSInterType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['4.00', '7.00', '12.00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on pICMSInterType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.vBCUFDest is not None or
            self.vBCFCPUFDest is not None or
            self.pFCPUFDest is not None or
            self.pICMSUFDest is not None or
            self.pICMSInter is not None or
            self.pICMSInterPart is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSUFDestType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFDestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSUFDestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSUFDestType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSUFDestType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSUFDestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCUFDest>%s</%svBCUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCUFDest),
            input_name='vBCUFDest')),
                    namespace_,
                    eol_))
        if self.vBCFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCFCPUFDest>%s</%svBCFCPUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCFCPUFDest),
            input_name='vBCFCPUFDest')),
                    namespace_,
                    eol_))
        if self.pFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spFCPUFDest>%s</%spFCPUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pFCPUFDest),
            input_name='pFCPUFDest')),
                    namespace_,
                    eol_))
        if self.pICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSUFDest>%s</%spICMSUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSUFDest),
            input_name='pICMSUFDest')),
                    namespace_,
                    eol_))
        if self.pICMSInter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSInter>%s</%spICMSInter>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSInter),
            input_name='pICMSInter')),
                    namespace_,
                    eol_))
        if self.pICMSInterPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSInterPart>%s</%spICMSInterPart>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSInterPart),
            input_name='pICMSInterPart')),
                    namespace_,
                    eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPUFDest>%s</%svFCPUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPUFDest),
            input_name='vFCPUFDest')),
                    namespace_,
                    eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSUFDest>%s</%svICMSUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSUFDest),
            input_name='vICMSUFDest')),
                    namespace_,
                    eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSUFRemet>%s</%svICMSUFRemet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSUFRemet),
            input_name='vICMSUFRemet')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBCUFDest':
            vBCUFDest_ = child_.text
            vBCUFDest_ = self.gds_validate_string(
                vBCUFDest_, node, 'vBCUFDest')
            self.vBCUFDest = vBCUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCUFDest)
        elif nodeName_ == 'vBCFCPUFDest':
            vBCFCPUFDest_ = child_.text
            vBCFCPUFDest_ = self.gds_validate_string(
                vBCFCPUFDest_, node, 'vBCFCPUFDest')
            self.vBCFCPUFDest = vBCFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPUFDest)
        elif nodeName_ == 'pFCPUFDest':
            pFCPUFDest_ = child_.text
            pFCPUFDest_ = self.gds_validate_string(
                pFCPUFDest_, node, 'pFCPUFDest')
            self.pFCPUFDest = pFCPUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pFCPUFDest)
        elif nodeName_ == 'pICMSUFDest':
            pICMSUFDest_ = child_.text
            pICMSUFDest_ = self.gds_validate_string(
                pICMSUFDest_, node, 'pICMSUFDest')
            self.pICMSUFDest = pICMSUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSUFDest)
        elif nodeName_ == 'pICMSInter':
            pICMSInter_ = child_.text
            pICMSInter_ = self.gds_validate_string(
                pICMSInter_, node, 'pICMSInter')
            self.pICMSInter = pICMSInter_
            # validate type pICMSInterType
            self.validate_pICMSInterType(self.pICMSInter)
        elif nodeName_ == 'pICMSInterPart':
            pICMSInterPart_ = child_.text
            pICMSInterPart_ = self.gds_validate_string(
                pICMSInterPart_, node, 'pICMSInterPart')
            self.pICMSInterPart = pICMSInterPart_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSInterPart)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(
                vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(
                vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(
                vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
# end class ICMSUFDestType


class impostoDevolType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, pDevol=None, IPI=None):
        self.original_tagname_ = None
        self.pDevol = pDevol
        self.validate_TDec_0302Max100(self.pDevol)
        self.IPI = IPI

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoDevolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoDevolType.subclass:
            return impostoDevolType.subclass(*args_, **kwargs_)
        else:
            return impostoDevolType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_pDevol(self): return self.pDevol

    def set_pDevol(self, pDevol): self.pDevol = pDevol

    def get_IPI(self): return self.IPI

    def set_IPI(self, IPI): self.IPI = IPI

    def validate_TDec_0302Max100(self, value):
        # Validate type TDec_0302Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Max100_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302Max100_patterns_, ))
    validate_TDec_0302Max100_patterns_ = [
        ['^0(\\.[0-9]{2})?$|^100(\\.00)?$|^[1-9]{1}[0-9]{0,1}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.pDevol is not None or
            self.IPI is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='impostoDevolType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoDevolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='impostoDevolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='impostoDevolType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='impostoDevolType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='impostoDevolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spDevol>%s</%spDevol>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pDevol),
            input_name='pDevol')),
                    namespace_,
                    eol_))
        if self.IPI is not None:
            self.IPI.export(
                outfile,
                level,
                namespace_,
                name_='IPI',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pDevol':
            pDevol_ = child_.text
            pDevol_ = self.gds_validate_string(pDevol_, node, 'pDevol')
            self.pDevol = pDevol_
            # validate type TDec_0302Max100
            self.validate_TDec_0302Max100(self.pDevol)
        elif nodeName_ == 'IPI':
            obj_ = IPIType.factory()
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
# end class impostoDevolType


class IPIType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, vIPIDevol=None):
        self.original_tagname_ = None
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPIType.subclass:
            return IPIType.subclass(*args_, **kwargs_)
        else:
            return IPIType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vIPIDevol(self): return self.vIPIDevol

    def set_vIPIDevol(self, vIPIDevol): self.vIPIDevol = vIPIDevol

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vIPIDevol is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='IPIType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='IPIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='IPIType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='IPIType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='IPIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIPIDevol>%s</%svIPIDevol>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIPIDevol),
            input_name='vIPIDevol')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(
                vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
# end class IPIType


class totalType(GeneratedsSuper):
    """Dados dos totais da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, ICMSTot=None, ISSQNtot=None, retTrib=None):
        self.original_tagname_ = None
        self.ICMSTot = ICMSTot
        self.ISSQNtot = ISSQNtot
        self.retTrib = retTrib

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, totalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if totalType.subclass:
            return totalType.subclass(*args_, **kwargs_)
        else:
            return totalType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_ICMSTot(self): return self.ICMSTot

    def set_ICMSTot(self, ICMSTot): self.ICMSTot = ICMSTot

    def get_ISSQNtot(self): return self.ISSQNtot

    def set_ISSQNtot(self, ISSQNtot): self.ISSQNtot = ISSQNtot

    def get_retTrib(self): return self.retTrib

    def set_retTrib(self, retTrib): self.retTrib = retTrib

    def hasContent_(self):
        if (
            self.ICMSTot is not None or
            self.ISSQNtot is not None or
            self.retTrib is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='totalType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('totalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='totalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='totalType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='totalType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='totalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMSTot is not None:
            self.ICMSTot.export(
                outfile,
                level,
                namespace_,
                name_='ICMSTot',
                pretty_print=pretty_print)
        if self.ISSQNtot is not None:
            self.ISSQNtot.export(
                outfile,
                level,
                namespace_,
                name_='ISSQNtot',
                pretty_print=pretty_print)
        if self.retTrib is not None:
            self.retTrib.export(
                outfile,
                level,
                namespace_,
                name_='retTrib',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMSTot':
            obj_ = ICMSTotType.factory()
            obj_.build(child_)
            self.ICMSTot = obj_
            obj_.original_tagname_ = 'ICMSTot'
        elif nodeName_ == 'ISSQNtot':
            obj_ = ISSQNtotType.factory()
            obj_.build(child_)
            self.ISSQNtot = obj_
            obj_.original_tagname_ = 'ISSQNtot'
        elif nodeName_ == 'retTrib':
            obj_ = retTribType.factory()
            obj_.build(child_)
            self.retTrib = obj_
            obj_.original_tagname_ = 'retTrib'
# end class totalType


class ICMSTotType(GeneratedsSuper):
    """Totais referentes ao ICMS"""
    subclass = None
    superclass = None

    def __init__(self, vBC=None, vICMS=None, vICMSDeson=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None, vFCP=None, vBCST=None, vST=None, vFCPST=None,
                 vFCPSTRet=None, vProd=None, vFrete=None, vSeg=None, vDesc=None, vII=None, vIPI=None, vIPIDevol=None, vPIS=None, vCOFINS=None, vOutro=None, vNF=None, vTotTrib=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.vST = vST
        self.validate_TDec_1302(self.vST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.vFrete = vFrete
        self.validate_TDec_1302(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302(self.vDesc)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
        self.vOutro = vOutro
        self.validate_TDec_1302(self.vOutro)
        self.vNF = vNF
        self.validate_TDec_1302(self.vNF)
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSTotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSTotType.subclass:
            return ICMSTotType.subclass(*args_, **kwargs_)
        else:
            return ICMSTotType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_vICMS(self): return self.vICMS

    def set_vICMS(self, vICMS): self.vICMS = vICMS

    def get_vICMSDeson(self): return self.vICMSDeson

    def set_vICMSDeson(self, vICMSDeson): self.vICMSDeson = vICMSDeson

    def get_vFCPUFDest(self): return self.vFCPUFDest

    def set_vFCPUFDest(self, vFCPUFDest): self.vFCPUFDest = vFCPUFDest

    def get_vICMSUFDest(self): return self.vICMSUFDest

    def set_vICMSUFDest(self, vICMSUFDest): self.vICMSUFDest = vICMSUFDest

    def get_vICMSUFRemet(self): return self.vICMSUFRemet

    def set_vICMSUFRemet(self, vICMSUFRemet): self.vICMSUFRemet = vICMSUFRemet

    def get_vFCP(self): return self.vFCP

    def set_vFCP(self, vFCP): self.vFCP = vFCP

    def get_vBCST(self): return self.vBCST

    def set_vBCST(self, vBCST): self.vBCST = vBCST

    def get_vST(self): return self.vST

    def set_vST(self, vST): self.vST = vST

    def get_vFCPST(self): return self.vFCPST

    def set_vFCPST(self, vFCPST): self.vFCPST = vFCPST

    def get_vFCPSTRet(self): return self.vFCPSTRet

    def set_vFCPSTRet(self, vFCPSTRet): self.vFCPSTRet = vFCPSTRet

    def get_vProd(self): return self.vProd

    def set_vProd(self, vProd): self.vProd = vProd

    def get_vFrete(self): return self.vFrete

    def set_vFrete(self, vFrete): self.vFrete = vFrete

    def get_vSeg(self): return self.vSeg

    def set_vSeg(self, vSeg): self.vSeg = vSeg

    def get_vDesc(self): return self.vDesc

    def set_vDesc(self, vDesc): self.vDesc = vDesc

    def get_vII(self): return self.vII

    def set_vII(self, vII): self.vII = vII

    def get_vIPI(self): return self.vIPI

    def set_vIPI(self, vIPI): self.vIPI = vIPI

    def get_vIPIDevol(self): return self.vIPIDevol

    def set_vIPIDevol(self, vIPIDevol): self.vIPIDevol = vIPIDevol

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def get_vOutro(self): return self.vOutro

    def set_vOutro(self, vOutro): self.vOutro = vOutro

    def get_vNF(self): return self.vNF

    def set_vNF(self, vNF): self.vNF = vNF

    def get_vTotTrib(self): return self.vTotTrib

    def set_vTotTrib(self, vTotTrib): self.vTotTrib = vTotTrib

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vICMS is not None or
            self.vICMSDeson is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None or
            self.vFCP is not None or
            self.vBCST is not None or
            self.vST is not None or
            self.vFCPST is not None or
            self.vFCPSTRet is not None or
            self.vProd is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vII is not None or
            self.vIPI is not None or
            self.vIPIDevol is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.vOutro is not None or
            self.vNF is not None or
            self.vTotTrib is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ICMSTotType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSTotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ICMSTotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ICMSTotType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ICMSTotType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ICMSTotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMS>%s</%svICMS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMS),
            input_name='vICMS')),
                    namespace_,
                    eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSDeson>%s</%svICMSDeson>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSDeson),
            input_name='vICMSDeson')),
                    namespace_,
                    eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPUFDest>%s</%svFCPUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPUFDest),
            input_name='vFCPUFDest')),
                    namespace_,
                    eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSUFDest>%s</%svICMSUFDest>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSUFDest),
            input_name='vICMSUFDest')),
                    namespace_,
                    eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSUFRemet>%s</%svICMSUFRemet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSUFRemet),
            input_name='vICMSUFRemet')),
                    namespace_,
                    eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCP>%s</%svFCP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCP),
            input_name='vFCP')),
                    namespace_,
                    eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCST>%s</%svBCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCST),
            input_name='vBCST')),
                    namespace_,
                    eol_))
        if self.vST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svST>%s</%svST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vST),
            input_name='vST')),
                    namespace_,
                    eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPST>%s</%svFCPST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPST),
            input_name='vFCPST')),
                    namespace_,
                    eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFCPSTRet>%s</%svFCPSTRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFCPSTRet),
            input_name='vFCPSTRet')),
                    namespace_,
                    eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svProd>%s</%svProd>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vProd),
            input_name='vProd')),
                    namespace_,
                    eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFrete>%s</%svFrete>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFrete),
            input_name='vFrete')),
                    namespace_,
                    eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svSeg>%s</%svSeg>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vSeg),
            input_name='vSeg')),
                    namespace_,
                    eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDesc>%s</%svDesc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDesc),
            input_name='vDesc')),
                    namespace_,
                    eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svII>%s</%svII>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vII),
            input_name='vII')),
                    namespace_,
                    eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIPI>%s</%svIPI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIPI),
            input_name='vIPI')),
                    namespace_,
                    eol_))
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIPIDevol>%s</%svIPIDevol>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIPIDevol),
            input_name='vIPIDevol')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svOutro>%s</%svOutro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vOutro),
            input_name='vOutro')),
                    namespace_,
                    eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svNF>%s</%svNF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vNF),
            input_name='vNF')),
                    namespace_,
                    eol_))
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svTotTrib>%s</%svTotTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vTotTrib),
            input_name='vTotTrib')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(
                vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(
                vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(
                vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(
                vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'vST':
            vST_ = child_.text
            vST_ = self.gds_validate_string(vST_, node, 'vST')
            self.vST = vST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(
                vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDesc)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
        elif nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(
                vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vOutro)
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vNF)
        elif nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
# end class ICMSTotType


class ISSQNtotType(GeneratedsSuper):
    """Totais referentes ao ISSQN"""
    subclass = None
    superclass = None

    def __init__(self, vServ=None, vBC=None, vISS=None, vPIS=None, vCOFINS=None, dCompet=None,
                 vDeducao=None, vOutro=None, vDescIncond=None, vDescCond=None, vISSRet=None, cRegTrib=None):
        self.original_tagname_ = None
        self.vServ = vServ
        self.validate_TDec_1302Opc(self.vServ)
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.vISS = vISS
        self.validate_TDec_1302Opc(self.vISS)
        self.vPIS = vPIS
        self.validate_TDec_1302Opc(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302Opc(self.vCOFINS)
        self.dCompet = dCompet
        self.validate_TData(self.dCompet)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.cRegTrib = cRegTrib
        self.validate_cRegTribType(self.cRegTrib)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNtotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNtotType.subclass:
            return ISSQNtotType.subclass(*args_, **kwargs_)
        else:
            return ISSQNtotType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vServ(self): return self.vServ

    def set_vServ(self, vServ): self.vServ = vServ

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_vISS(self): return self.vISS

    def set_vISS(self, vISS): self.vISS = vISS

    def get_vPIS(self): return self.vPIS

    def set_vPIS(self, vPIS): self.vPIS = vPIS

    def get_vCOFINS(self): return self.vCOFINS

    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS

    def get_dCompet(self): return self.dCompet

    def set_dCompet(self, dCompet): self.dCompet = dCompet

    def get_vDeducao(self): return self.vDeducao

    def set_vDeducao(self, vDeducao): self.vDeducao = vDeducao

    def get_vOutro(self): return self.vOutro

    def set_vOutro(self, vOutro): self.vOutro = vOutro

    def get_vDescIncond(self): return self.vDescIncond

    def set_vDescIncond(self, vDescIncond): self.vDescIncond = vDescIncond

    def get_vDescCond(self): return self.vDescCond

    def set_vDescCond(self, vDescCond): self.vDescCond = vDescCond

    def get_vISSRet(self): return self.vISSRet

    def set_vISSRet(self, vISSRet): self.vISSRet = vISSRet

    def get_cRegTrib(self): return self.cRegTrib

    def set_cRegTrib(self, cRegTrib): self.cRegTrib = cRegTrib

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]

    def validate_cRegTribType(self, value):
        # Validate type cRegTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on cRegTribType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBC is not None or
            self.vISS is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.dCompet is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.cRegTrib is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='ISSQNtotType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNtotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='ISSQNtotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='ISSQNtotType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='ISSQNtotType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='ISSQNtotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svServ>%s</%svServ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vServ),
            input_name='vServ')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.vISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svISS>%s</%svISS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vISS),
            input_name='vISS')),
                    namespace_,
                    eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPIS>%s</%svPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPIS),
            input_name='vPIS')),
                    namespace_,
                    eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svCOFINS>%s</%svCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vCOFINS),
            input_name='vCOFINS')),
                    namespace_,
                    eol_))
        if self.dCompet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdCompet>%s</%sdCompet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dCompet),
            input_name='dCompet')),
                    namespace_,
                    eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDeducao>%s</%svDeducao>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDeducao),
            input_name='vDeducao')),
                    namespace_,
                    eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svOutro>%s</%svOutro>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vOutro),
            input_name='vOutro')),
                    namespace_,
                    eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDescIncond>%s</%svDescIncond>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDescIncond),
            input_name='vDescIncond')),
                    namespace_,
                    eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDescCond>%s</%svDescCond>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDescCond),
            input_name='vDescCond')),
                    namespace_,
                    eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svISSRet>%s</%svISSRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vISSRet),
            input_name='vISSRet')),
                    namespace_,
                    eol_))
        if self.cRegTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scRegTrib>%s</%scRegTrib>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cRegTrib),
            input_name='cRegTrib')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vServ)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'vISS':
            vISS_ = child_.text
            vISS_ = self.gds_validate_string(vISS_, node, 'vISS')
            self.vISS = vISS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vCOFINS)
        elif nodeName_ == 'dCompet':
            dCompet_ = child_.text
            dCompet_ = self.gds_validate_string(dCompet_, node, 'dCompet')
            self.dCompet = dCompet_
            # validate type TData
            self.validate_TData(self.dCompet)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(
                vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(
                vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'cRegTrib':
            cRegTrib_ = child_.text
            cRegTrib_ = self.gds_validate_string(cRegTrib_, node, 'cRegTrib')
            self.cRegTrib = cRegTrib_
            # validate type cRegTribType
            self.validate_cRegTribType(self.cRegTrib)
# end class ISSQNtotType


class retTribType(GeneratedsSuper):
    """Retenção de Tributos Federais"""
    subclass = None
    superclass = None

    def __init__(self, vRetPIS=None, vRetCOFINS=None, vRetCSLL=None,
                 vBCIRRF=None, vIRRF=None, vBCRetPrev=None, vRetPrev=None):
        self.original_tagname_ = None
        self.vRetPIS = vRetPIS
        self.validate_TDec_1302Opc(self.vRetPIS)
        self.vRetCOFINS = vRetCOFINS
        self.validate_TDec_1302Opc(self.vRetCOFINS)
        self.vRetCSLL = vRetCSLL
        self.validate_TDec_1302Opc(self.vRetCSLL)
        self.vBCIRRF = vBCIRRF
        self.validate_TDec_1302Opc(self.vBCIRRF)
        self.vIRRF = vIRRF
        self.validate_TDec_1302Opc(self.vIRRF)
        self.vBCRetPrev = vBCRetPrev
        self.validate_TDec_1302Opc(self.vBCRetPrev)
        self.vRetPrev = vRetPrev
        self.validate_TDec_1302Opc(self.vRetPrev)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTribType.subclass:
            return retTribType.subclass(*args_, **kwargs_)
        else:
            return retTribType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vRetPIS(self): return self.vRetPIS

    def set_vRetPIS(self, vRetPIS): self.vRetPIS = vRetPIS

    def get_vRetCOFINS(self): return self.vRetCOFINS

    def set_vRetCOFINS(self, vRetCOFINS): self.vRetCOFINS = vRetCOFINS

    def get_vRetCSLL(self): return self.vRetCSLL

    def set_vRetCSLL(self, vRetCSLL): self.vRetCSLL = vRetCSLL

    def get_vBCIRRF(self): return self.vBCIRRF

    def set_vBCIRRF(self, vBCIRRF): self.vBCIRRF = vBCIRRF

    def get_vIRRF(self): return self.vIRRF

    def set_vIRRF(self, vIRRF): self.vIRRF = vIRRF

    def get_vBCRetPrev(self): return self.vBCRetPrev

    def set_vBCRetPrev(self, vBCRetPrev): self.vBCRetPrev = vBCRetPrev

    def get_vRetPrev(self): return self.vRetPrev

    def set_vRetPrev(self, vRetPrev): self.vRetPrev = vRetPrev

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.vRetPIS is not None or
            self.vRetCOFINS is not None or
            self.vRetCSLL is not None or
            self.vBCIRRF is not None or
            self.vIRRF is not None or
            self.vBCRetPrev is not None or
            self.vRetPrev is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='retTribType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='retTribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='retTribType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='retTribType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='retTribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vRetPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svRetPIS>%s</%svRetPIS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vRetPIS),
            input_name='vRetPIS')),
                    namespace_,
                    eol_))
        if self.vRetCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svRetCOFINS>%s</%svRetCOFINS>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vRetCOFINS),
            input_name='vRetCOFINS')),
                    namespace_,
                    eol_))
        if self.vRetCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svRetCSLL>%s</%svRetCSLL>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vRetCSLL),
            input_name='vRetCSLL')),
                    namespace_,
                    eol_))
        if self.vBCIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCIRRF>%s</%svBCIRRF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCIRRF),
            input_name='vBCIRRF')),
                    namespace_,
                    eol_))
        if self.vIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIRRF>%s</%svIRRF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIRRF),
            input_name='vIRRF')),
                    namespace_,
                    eol_))
        if self.vBCRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCRetPrev>%s</%svBCRetPrev>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCRetPrev),
            input_name='vBCRetPrev')),
                    namespace_,
                    eol_))
        if self.vRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svRetPrev>%s</%svRetPrev>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vRetPrev),
            input_name='vRetPrev')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vRetPIS':
            vRetPIS_ = child_.text
            vRetPIS_ = self.gds_validate_string(vRetPIS_, node, 'vRetPIS')
            self.vRetPIS = vRetPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPIS)
        elif nodeName_ == 'vRetCOFINS':
            vRetCOFINS_ = child_.text
            vRetCOFINS_ = self.gds_validate_string(
                vRetCOFINS_, node, 'vRetCOFINS')
            self.vRetCOFINS = vRetCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCOFINS)
        elif nodeName_ == 'vRetCSLL':
            vRetCSLL_ = child_.text
            vRetCSLL_ = self.gds_validate_string(vRetCSLL_, node, 'vRetCSLL')
            self.vRetCSLL = vRetCSLL_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCSLL)
        elif nodeName_ == 'vBCIRRF':
            vBCIRRF_ = child_.text
            vBCIRRF_ = self.gds_validate_string(vBCIRRF_, node, 'vBCIRRF')
            self.vBCIRRF = vBCIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCIRRF)
        elif nodeName_ == 'vIRRF':
            vIRRF_ = child_.text
            vIRRF_ = self.gds_validate_string(vIRRF_, node, 'vIRRF')
            self.vIRRF = vIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vIRRF)
        elif nodeName_ == 'vBCRetPrev':
            vBCRetPrev_ = child_.text
            vBCRetPrev_ = self.gds_validate_string(
                vBCRetPrev_, node, 'vBCRetPrev')
            self.vBCRetPrev = vBCRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCRetPrev)
        elif nodeName_ == 'vRetPrev':
            vRetPrev_ = child_.text
            vRetPrev_ = self.gds_validate_string(vRetPrev_, node, 'vRetPrev')
            self.vRetPrev = vRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPrev)
# end class retTribType


class transpType(GeneratedsSuper):
    """Dados dos transportes da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, modFrete=None, transporta=None, retTransp=None,
                 veicTransp=None, reboque=None, vagao=None, balsa=None, vol=None):
        self.original_tagname_ = None
        self.modFrete = modFrete
        self.validate_modFreteType(self.modFrete)
        self.transporta = transporta
        self.retTransp = retTransp
        self.veicTransp = veicTransp
        if reboque is None:
            self.reboque = []
        else:
            self.reboque = reboque
        self.vagao = vagao
        self.validate_vagaoType(self.vagao)
        self.balsa = balsa
        self.validate_balsaType(self.balsa)
        if vol is None:
            self.vol = []
        else:
            self.vol = vol

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transpType.subclass:
            return transpType.subclass(*args_, **kwargs_)
        else:
            return transpType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_modFrete(self): return self.modFrete

    def set_modFrete(self, modFrete): self.modFrete = modFrete

    def get_transporta(self): return self.transporta

    def set_transporta(self, transporta): self.transporta = transporta

    def get_retTransp(self): return self.retTransp

    def set_retTransp(self, retTransp): self.retTransp = retTransp

    def get_veicTransp(self): return self.veicTransp

    def set_veicTransp(self, veicTransp): self.veicTransp = veicTransp

    def get_reboque(self): return self.reboque

    def set_reboque(self, reboque): self.reboque = reboque

    def add_reboque(self, value): self.reboque.append(value)

    def insert_reboque_at(
        self,
        index,
        value): self.reboque.insert(
        index,
        value)

    def replace_reboque_at(self, index, value): self.reboque[index] = value

    def get_vagao(self): return self.vagao

    def set_vagao(self, vagao): self.vagao = vagao

    def get_balsa(self): return self.balsa

    def set_balsa(self, balsa): self.balsa = balsa

    def get_vol(self): return self.vol

    def set_vol(self, vol): self.vol = vol

    def add_vol(self, value): self.vol.append(value)

    def insert_vol_at(self, index, value): self.vol.insert(index, value)

    def replace_vol_at(self, index, value): self.vol[index] = value

    def validate_modFreteType(self, value):
        # Validate type modFreteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on modFreteType' % {
        "value": value.encode("utf-8")})

    def validate_vagaoType(self, value):
        # Validate type vagaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on vagaoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on vagaoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_vagaoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_vagaoType_patterns_, ))
    validate_vagaoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_balsaType(self, value):
        # Validate type balsaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on balsaType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on balsaType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_balsaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_balsaType_patterns_, ))
    validate_balsaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.modFrete is not None or
            self.transporta is not None or
            self.retTransp is not None or
            self.veicTransp is not None or
            self.reboque or
            self.vagao is not None or
            self.balsa is not None or
            self.vol
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='transpType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='transpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='transpType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='transpType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='transpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smodFrete>%s</%smodFrete>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.modFrete),
            input_name='modFrete')),
                    namespace_,
                    eol_))
        if self.transporta is not None:
            self.transporta.export(
                outfile,
                level,
                namespace_,
                name_='transporta',
                pretty_print=pretty_print)
        if self.retTransp is not None:
            self.retTransp.export(
                outfile,
                level,
                namespace_,
                name_='retTransp',
                pretty_print=pretty_print)
        if self.veicTransp is not None:
            self.veicTransp.export(
                outfile,
                level,
                namespace_,
                name_='veicTransp',
                pretty_print=pretty_print)
        for reboque_ in self.reboque:
            reboque_.export(
                outfile,
                level,
                namespace_,
                name_='reboque',
                pretty_print=pretty_print)
        if self.vagao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svagao>%s</%svagao>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vagao),
            input_name='vagao')),
                    namespace_,
                    eol_))
        if self.balsa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sbalsa>%s</%sbalsa>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.balsa),
            input_name='balsa')),
                    namespace_,
                    eol_))
        for vol_ in self.vol:
            vol_.export(
                outfile,
                level,
                namespace_,
                name_='vol',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modFrete':
            modFrete_ = child_.text
            modFrete_ = self.gds_validate_string(modFrete_, node, 'modFrete')
            self.modFrete = modFrete_
            # validate type modFreteType
            self.validate_modFreteType(self.modFrete)
        elif nodeName_ == 'transporta':
            obj_ = transportaType.factory()
            obj_.build(child_)
            self.transporta = obj_
            obj_.original_tagname_ = 'transporta'
        elif nodeName_ == 'retTransp':
            obj_ = retTranspType.factory()
            obj_.build(child_)
            self.retTransp = obj_
            obj_.original_tagname_ = 'retTransp'
        elif nodeName_ == 'veicTransp':
            obj_ = TVeiculo.factory()
            obj_.build(child_)
            self.veicTransp = obj_
            obj_.original_tagname_ = 'veicTransp'
        elif nodeName_ == 'reboque':
            obj_ = TVeiculo.factory()
            obj_.build(child_)
            self.reboque.append(obj_)
            obj_.original_tagname_ = 'reboque'
        elif nodeName_ == 'vagao':
            vagao_ = child_.text
            vagao_ = self.gds_validate_string(vagao_, node, 'vagao')
            self.vagao = vagao_
            # validate type vagaoType
            self.validate_vagaoType(self.vagao)
        elif nodeName_ == 'balsa':
            balsa_ = child_.text
            balsa_ = self.gds_validate_string(balsa_, node, 'balsa')
            self.balsa = balsa_
            # validate type balsaType
            self.validate_balsaType(self.balsa)
        elif nodeName_ == 'vol':
            obj_ = volType.factory()
            obj_.build(child_)
            self.vol.append(obj_)
            obj_.original_tagname_ = 'vol'
# end class transpType


class transportaType(GeneratedsSuper):
    """Dados do transportador"""
    subclass = None
    superclass = None

    def __init__(self, CNPJ=None, CPF=None, xNome=None,
                 IE=None, xEnder=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType49(self.xNome)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.xEnder = xEnder
        self.validate_xEnderType(self.xEnder)
        self.xMun = xMun
        self.validate_xMunType(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportaType.subclass:
            return transportaType.subclass(*args_, **kwargs_)
        else:
            return transportaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_CPF(self): return self.CPF

    def set_CPF(self, CPF): self.CPF = CPF

    def get_xNome(self): return self.xNome

    def set_xNome(self, xNome): self.xNome = xNome

    def get_IE(self): return self.IE

    def set_IE(self, IE): self.IE = IE

    def get_xEnder(self): return self.xEnder

    def set_xEnder(self, xEnder): self.xEnder = xEnder

    def get_xMun(self): return self.xMun

    def set_xMun(self, xMun): self.xMun = xMun

    def get_UF(self): return self.UF

    def set_UF(self, UF): self.UF = UF

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]

    def validate_xNomeType49(self, value):
        # Validate type xNomeType49, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xNomeType49' % {
        "value": value})
            if len(str(value)) < 2:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xNomeType49' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType49_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xNomeType49_patterns_, ))
    validate_xNomeType49_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [['^ISENTO$|^[0-9]{2,14}$']]

    def validate_xEnderType(self, value):
        # Validate type xEnderType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xEnderType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xEnderType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xEnderType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xEnderType_patterns_, ))
    validate_xEnderType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xMunType(self, value):
        # Validate type xMunType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xMunType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xMunType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xMunType_patterns_, ))
    validate_xMunType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO',
                'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUf' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.IE is not None or
            self.xEnder is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='transportaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='transportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='transportaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='transportaType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='transportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCPF>%s</%sCPF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CPF),
            input_name='CPF')),
                    namespace_,
                    eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxNome>%s</%sxNome>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xNome),
            input_name='xNome')),
                    namespace_,
                    eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sIE>%s</%sIE>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.IE),
            input_name='IE')),
                    namespace_,
                    eol_))
        if self.xEnder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxEnder>%s</%sxEnder>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xEnder),
            input_name='xEnder')),
                    namespace_,
                    eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMun>%s</%sxMun>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMun),
            input_name='xMun')),
                    namespace_,
                    eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUF>%s</%sUF>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UF),
            input_name='UF')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType49
            self.validate_xNomeType49(self.xNome)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'xEnder':
            xEnder_ = child_.text
            xEnder_ = self.gds_validate_string(xEnder_, node, 'xEnder')
            self.xEnder = xEnder_
            # validate type xEnderType
            self.validate_xEnderType(self.xEnder)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType
            self.validate_xMunType(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class transportaType


class retTranspType(GeneratedsSuper):
    """Dados da retenção  ICMS do Transporte"""
    subclass = None
    superclass = None

    def __init__(self, vServ=None, vBCRet=None, pICMSRet=None,
                 vICMSRet=None, CFOP=None, cMunFG=None):
        self.original_tagname_ = None
        self.vServ = vServ
        self.validate_TDec_1302(self.vServ)
        self.vBCRet = vBCRet
        self.validate_TDec_1302(self.vBCRet)
        self.pICMSRet = pICMSRet
        self.validate_TDec_0302a04(self.pICMSRet)
        self.vICMSRet = vICMSRet
        self.validate_TDec_1302(self.vICMSRet)
        self.CFOP = CFOP
        self.validate_CFOPType50(self.CFOP)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTranspType.subclass:
            return retTranspType.subclass(*args_, **kwargs_)
        else:
            return retTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_vServ(self): return self.vServ

    def set_vServ(self, vServ): self.vServ = vServ

    def get_vBCRet(self): return self.vBCRet

    def set_vBCRet(self, vBCRet): self.vBCRet = vBCRet

    def get_pICMSRet(self): return self.pICMSRet

    def set_pICMSRet(self, pICMSRet): self.pICMSRet = pICMSRet

    def get_vICMSRet(self): return self.vICMSRet

    def set_vICMSRet(self, vICMSRet): self.vICMSRet = vICMSRet

    def get_CFOP(self): return self.CFOP

    def set_CFOP(self, CFOP): self.CFOP = CFOP

    def get_cMunFG(self): return self.cMunFG

    def set_cMunFG(self, cMunFG): self.cMunFG = cMunFG

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_CFOPType50(self, value):
        # Validate type CFOPType50, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType50_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_CFOPType50_patterns_, ))
    validate_CFOPType50_patterns_ = [['^[1,2,3,5,6,7]{1}[0-9]{3}$']]

    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]

    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBCRet is not None or
            self.pICMSRet is not None or
            self.vICMSRet is not None or
            self.CFOP is not None or
            self.cMunFG is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='retTranspType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='retTranspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='retTranspType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='retTranspType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='retTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svServ>%s</%svServ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vServ),
            input_name='vServ')),
                    namespace_,
                    eol_))
        if self.vBCRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBCRet>%s</%svBCRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBCRet),
            input_name='vBCRet')),
                    namespace_,
                    eol_))
        if self.pICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spICMSRet>%s</%spICMSRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pICMSRet),
            input_name='pICMSRet')),
                    namespace_,
                    eol_))
        if self.vICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svICMSRet>%s</%svICMSRet>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vICMSRet),
            input_name='vICMSRet')),
                    namespace_,
                    eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCFOP>%s</%sCFOP>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CFOP),
            input_name='CFOP')),
                    namespace_,
                    eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scMunFG>%s</%scMunFG>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cMunFG),
            input_name='cMunFG')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vServ)
        elif nodeName_ == 'vBCRet':
            vBCRet_ = child_.text
            vBCRet_ = self.gds_validate_string(vBCRet_, node, 'vBCRet')
            self.vBCRet = vBCRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCRet)
        elif nodeName_ == 'pICMSRet':
            pICMSRet_ = child_.text
            pICMSRet_ = self.gds_validate_string(pICMSRet_, node, 'pICMSRet')
            self.pICMSRet = pICMSRet_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSRet)
        elif nodeName_ == 'vICMSRet':
            vICMSRet_ = child_.text
            vICMSRet_ = self.gds_validate_string(vICMSRet_, node, 'vICMSRet')
            self.vICMSRet = vICMSRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSRet)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType50
            self.validate_CFOPType50(self.CFOP)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
# end class retTranspType


class volType(GeneratedsSuper):
    """Dados dos volumes"""
    subclass = None
    superclass = None

    def __init__(self, qVol=None, esp=None, marca=None,
                 nVol=None, pesoL=None, pesoB=None, lacres=None):
        self.original_tagname_ = None
        self.qVol = qVol
        self.validate_qVolType(self.qVol)
        self.esp = esp
        self.validate_espType(self.esp)
        self.marca = marca
        self.validate_marcaType(self.marca)
        self.nVol = nVol
        self.validate_nVolType(self.nVol)
        self.pesoL = pesoL
        self.validate_TDec_1203(self.pesoL)
        self.pesoB = pesoB
        self.validate_TDec_1203(self.pesoB)
        if lacres is None:
            self.lacres = []
        else:
            self.lacres = lacres

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, volType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if volType.subclass:
            return volType.subclass(*args_, **kwargs_)
        else:
            return volType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_qVol(self): return self.qVol

    def set_qVol(self, qVol): self.qVol = qVol

    def get_esp(self): return self.esp

    def set_esp(self, esp): self.esp = esp

    def get_marca(self): return self.marca

    def set_marca(self, marca): self.marca = marca

    def get_nVol(self): return self.nVol

    def set_nVol(self, nVol): self.nVol = nVol

    def get_pesoL(self): return self.pesoL

    def set_pesoL(self, pesoL): self.pesoL = pesoL

    def get_pesoB(self): return self.pesoB

    def set_pesoB(self, pesoB): self.pesoB = pesoB

    def get_lacres(self): return self.lacres

    def set_lacres(self, lacres): self.lacres = lacres

    def add_lacres(self, value): self.lacres.append(value)

    def insert_lacres_at(self, index, value): self.lacres.insert(index, value)

    def replace_lacres_at(self, index, value): self.lacres[index] = value

    def validate_qVolType(self, value):
        # Validate type qVolType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_qVolType_patterns_, ))
    validate_qVolType_patterns_ = [['^[0-9]{1,15}$']]

    def validate_espType(self, value):
        # Validate type espType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on espType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on espType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_espType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_espType_patterns_, ))
    validate_espType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_marcaType(self, value):
        # Validate type marcaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on marcaType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on marcaType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_marcaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_marcaType_patterns_, ))
    validate_marcaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_nVolType(self, value):
        # Validate type nVolType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nVolType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nVolType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nVolType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nVolType_patterns_, ))
    validate_nVolType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [
        ['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]

    def hasContent_(self):
        if (
            self.qVol is not None or
            self.esp is not None or
            self.marca is not None or
            self.nVol is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.lacres
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='volType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('volType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='volType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='volType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='volType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='volType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqVol>%s</%sqVol>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qVol),
            input_name='qVol')),
                    namespace_,
                    eol_))
        if self.esp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sesp>%s</%sesp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.esp),
            input_name='esp')),
                    namespace_,
                    eol_))
        if self.marca is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%smarca>%s</%smarca>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.marca),
            input_name='marca')),
                    namespace_,
                    eol_))
        if self.nVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snVol>%s</%snVol>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nVol),
            input_name='nVol')),
                    namespace_,
                    eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spesoL>%s</%spesoL>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pesoL),
            input_name='pesoL')),
                    namespace_,
                    eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spesoB>%s</%spesoB>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pesoB),
            input_name='pesoB')),
                    namespace_,
                    eol_))
        for lacres_ in self.lacres:
            lacres_.export(
                outfile,
                level,
                namespace_,
                name_='lacres',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qVol':
            qVol_ = child_.text
            qVol_ = self.gds_validate_string(qVol_, node, 'qVol')
            self.qVol = qVol_
            # validate type qVolType
            self.validate_qVolType(self.qVol)
        elif nodeName_ == 'esp':
            esp_ = child_.text
            esp_ = self.gds_validate_string(esp_, node, 'esp')
            self.esp = esp_
            # validate type espType
            self.validate_espType(self.esp)
        elif nodeName_ == 'marca':
            marca_ = child_.text
            marca_ = self.gds_validate_string(marca_, node, 'marca')
            self.marca = marca_
            # validate type marcaType
            self.validate_marcaType(self.marca)
        elif nodeName_ == 'nVol':
            nVol_ = child_.text
            nVol_ = self.gds_validate_string(nVol_, node, 'nVol')
            self.nVol = nVol_
            # validate type nVolType
            self.validate_nVolType(self.nVol)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoB)
        elif nodeName_ == 'lacres':
            obj_ = lacresType.factory()
            obj_.build(child_)
            self.lacres.append(obj_)
            obj_.original_tagname_ = 'lacres'
# end class volType


class lacresType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
        self.validate_nLacreType(self.nLacre)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacresType.subclass:
            return lacresType.subclass(*args_, **kwargs_)
        else:
            return lacresType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nLacre(self): return self.nLacre

    def set_nLacre(self, nLacre): self.nLacre = nLacre

    def validate_nLacreType(self, value):
        # Validate type nLacreType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nLacreType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nLacreType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nLacreType_patterns_, ))
    validate_nLacreType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='lacresType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacresType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='lacresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='lacresType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='lacresType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='lacresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snLacre>%s</%snLacre>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nLacre),
            input_name='nLacre')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType
            self.validate_nLacreType(self.nLacre)
# end class lacresType


class cobrType(GeneratedsSuper):
    """Dados da cobrança da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, fat=None, dup=None):
        self.original_tagname_ = None
        self.fat = fat
        if dup is None:
            self.dup = []
        else:
            self.dup = dup

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobrType.subclass:
            return cobrType.subclass(*args_, **kwargs_)
        else:
            return cobrType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_fat(self): return self.fat

    def set_fat(self, fat): self.fat = fat

    def get_dup(self): return self.dup

    def set_dup(self, dup): self.dup = dup

    def add_dup(self, value): self.dup.append(value)

    def insert_dup_at(self, index, value): self.dup.insert(index, value)

    def replace_dup_at(self, index, value): self.dup[index] = value

    def hasContent_(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='cobrType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='cobrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='cobrType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='cobrType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='cobrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            self.fat.export(
                outfile,
                level,
                namespace_,
                name_='fat',
                pretty_print=pretty_print)
        for dup_ in self.dup:
            dup_.export(
                outfile,
                level,
                namespace_,
                name_='dup',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fat':
            obj_ = fatType.factory()
            obj_.build(child_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dupType.factory()
            obj_.build(child_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobrType


class fatType(GeneratedsSuper):
    """Dados da fatura"""
    subclass = None
    superclass = None

    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None):
        self.original_tagname_ = None
        self.nFat = nFat
        self.validate_nFatType(self.nFat)
        self.vOrig = vOrig
        self.validate_TDec_1302Opc(self.vOrig)
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vLiq = vLiq
        self.validate_TDec_1302Opc(self.vLiq)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatType.subclass:
            return fatType.subclass(*args_, **kwargs_)
        else:
            return fatType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nFat(self): return self.nFat

    def set_nFat(self, nFat): self.nFat = nFat

    def get_vOrig(self): return self.vOrig

    def set_vOrig(self, vOrig): self.vOrig = vOrig

    def get_vDesc(self): return self.vDesc

    def set_vDesc(self, vDesc): self.vDesc = vDesc

    def get_vLiq(self): return self.vLiq

    def set_vLiq(self, vLiq): self.vLiq = vLiq

    def validate_nFatType(self, value):
        # Validate type nFatType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nFatType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nFatType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nFatType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nFatType_patterns_, ))
    validate_nFatType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='fatType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='fatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='fatType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='fatType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='fatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snFat>%s</%snFat>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nFat),
            input_name='nFat')),
                    namespace_,
                    eol_))
        if self.vOrig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svOrig>%s</%svOrig>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vOrig),
            input_name='vOrig')),
                    namespace_,
                    eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDesc>%s</%svDesc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDesc),
            input_name='vDesc')),
                    namespace_,
                    eol_))
        if self.vLiq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svLiq>%s</%svLiq>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vLiq),
            input_name='vLiq')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nFat':
            nFat_ = child_.text
            nFat_ = self.gds_validate_string(nFat_, node, 'nFat')
            self.nFat = nFat_
            # validate type nFatType
            self.validate_nFatType(self.nFat)
        elif nodeName_ == 'vOrig':
            vOrig_ = child_.text
            vOrig_ = self.gds_validate_string(vOrig_, node, 'vOrig')
            self.vOrig = vOrig_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOrig)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vLiq':
            vLiq_ = child_.text
            vLiq_ = self.gds_validate_string(vLiq_, node, 'vLiq')
            self.vLiq = vLiq_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vLiq)
# end class fatType


class dupType(GeneratedsSuper):
    """Dados das duplicatas NT 2011/004"""
    subclass = None
    superclass = None

    def __init__(self, nDup=None, dVenc=None, vDup=None):
        self.original_tagname_ = None
        self.nDup = nDup
        self.validate_nDupType(self.nDup)
        self.dVenc = dVenc
        self.validate_TData(self.dVenc)
        self.vDup = vDup
        self.validate_TDec_1302Opc(self.vDup)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dupType.subclass:
            return dupType.subclass(*args_, **kwargs_)
        else:
            return dupType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nDup(self): return self.nDup

    def set_nDup(self, nDup): self.nDup = nDup

    def get_dVenc(self): return self.dVenc

    def set_dVenc(self, dVenc): self.dVenc = dVenc

    def get_vDup(self): return self.vDup

    def set_vDup(self, vDup): self.vDup = vDup

    def validate_nDupType(self, value):
        # Validate type nDupType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nDupType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nDupType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nDupType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nDupType_patterns_, ))
    validate_nDupType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]

    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [
        ['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='dupType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='dupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='dupType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='dupType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='dupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snDup>%s</%snDup>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nDup),
            input_name='nDup')),
                    namespace_,
                    eol_))
        if self.dVenc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdVenc>%s</%sdVenc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dVenc),
            input_name='dVenc')),
                    namespace_,
                    eol_))
        if self.vDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDup>%s</%svDup>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDup),
            input_name='vDup')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDup':
            nDup_ = child_.text
            nDup_ = self.gds_validate_string(nDup_, node, 'nDup')
            self.nDup = nDup_
            # validate type nDupType
            self.validate_nDupType(self.nDup)
        elif nodeName_ == 'dVenc':
            dVenc_ = child_.text
            dVenc_ = self.gds_validate_string(dVenc_, node, 'dVenc')
            self.dVenc = dVenc_
            # validate type TData
            self.validate_TData(self.dVenc)
        elif nodeName_ == 'vDup':
            vDup_ = child_.text
            vDup_ = self.gds_validate_string(vDup_, node, 'vDup')
            self.vDup = vDup_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDup)
# end class dupType


class pagType(GeneratedsSuper):
    """Dados de Pagamento. Obrigatório apenas para (NFC-e) NT 2012/004"""
    subclass = None
    superclass = None

    def __init__(self, detPag=None, vTroco=None):
        self.original_tagname_ = None
        if detPag is None:
            self.detPag = []
        else:
            self.detPag = detPag
        self.vTroco = vTroco
        self.validate_TDec_1302(self.vTroco)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pagType.subclass:
            return pagType.subclass(*args_, **kwargs_)
        else:
            return pagType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_detPag(self): return self.detPag

    def set_detPag(self, detPag): self.detPag = detPag

    def add_detPag(self, value): self.detPag.append(value)

    def insert_detPag_at(self, index, value): self.detPag.insert(index, value)

    def replace_detPag_at(self, index, value): self.detPag[index] = value

    def get_vTroco(self): return self.vTroco

    def set_vTroco(self, vTroco): self.vTroco = vTroco

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.detPag or
            self.vTroco is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='pagType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='pagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='pagType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='pagType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='pagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detPag_ in self.detPag:
            detPag_.export(
                outfile,
                level,
                namespace_,
                name_='detPag',
                pretty_print=pretty_print)
        if self.vTroco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svTroco>%s</%svTroco>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vTroco),
            input_name='vTroco')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detPag':
            obj_ = detPagType.factory()
            obj_.build(child_)
            self.detPag.append(obj_)
            obj_.original_tagname_ = 'detPag'
        elif nodeName_ == 'vTroco':
            vTroco_ = child_.text
            vTroco_ = self.gds_validate_string(vTroco_, node, 'vTroco')
            self.vTroco = vTroco_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTroco)
# end class pagType


class detPagType(GeneratedsSuper):
    """Grupo de detalhamento da forma de pagamento."""
    subclass = None
    superclass = None

    def __init__(self, tPag=None, vPag=None, card=None):
        self.original_tagname_ = None
        self.tPag = tPag
        self.validate_tPagType(self.tPag)
        self.vPag = vPag
        self.validate_TDec_1302(self.vPag)
        self.card = card

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detPagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detPagType.subclass:
            return detPagType.subclass(*args_, **kwargs_)
        else:
            return detPagType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tPag(self): return self.tPag

    def set_tPag(self, tPag): self.tPag = tPag

    def get_vPag(self): return self.vPag

    def set_vPag(self, vPag): self.vPag = vPag

    def get_card(self): return self.card

    def set_card(self, card): self.card = card

    def validate_tPagType(self, value):
        # Validate type tPagType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '01',
                '02',
                '03',
                '04',
                '05',
                '10',
                '11',
                '12',
                '13',
                '14',
                '15',
                '90',
                '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tPagType' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.tPag is not None or
            self.vPag is not None or
            self.card is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='detPagType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detPagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='detPagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='detPagType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='detPagType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='detPagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stPag>%s</%stPag>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tPag),
            input_name='tPag')),
                    namespace_,
                    eol_))
        if self.vPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svPag>%s</%svPag>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vPag),
            input_name='vPag')),
                    namespace_,
                    eol_))
        if self.card is not None:
            self.card.export(
                outfile,
                level,
                namespace_,
                name_='card',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tPag':
            tPag_ = child_.text
            tPag_ = self.gds_validate_string(tPag_, node, 'tPag')
            self.tPag = tPag_
            # validate type tPagType
            self.validate_tPagType(self.tPag)
        elif nodeName_ == 'vPag':
            vPag_ = child_.text
            vPag_ = self.gds_validate_string(vPag_, node, 'vPag')
            self.vPag = vPag_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPag)
        elif nodeName_ == 'card':
            obj_ = cardType.factory()
            obj_.build(child_)
            self.card = obj_
            obj_.original_tagname_ = 'card'
# end class detPagType


class cardType(GeneratedsSuper):
    """Grupo de Cartões"""
    subclass = None
    superclass = None

    def __init__(self, tpIntegra=None, CNPJ=None, tBand=None, cAut=None):
        self.original_tagname_ = None
        self.tpIntegra = tpIntegra
        self.validate_tpIntegraType(self.tpIntegra)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.tBand = tBand
        self.validate_tBandType(self.tBand)
        self.cAut = cAut
        self.validate_cAutType(self.cAut)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardType.subclass:
            return cardType.subclass(*args_, **kwargs_)
        else:
            return cardType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpIntegra(self): return self.tpIntegra

    def set_tpIntegra(self, tpIntegra): self.tpIntegra = tpIntegra

    def get_CNPJ(self): return self.CNPJ

    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ

    def get_tBand(self): return self.tBand

    def set_tBand(self, tBand): self.tBand = tBand

    def get_cAut(self): return self.cAut

    def set_cAut(self, cAut): self.cAut = cAut

    def validate_tpIntegraType(self, value):
        # Validate type tpIntegraType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tpIntegraType' % {
        "value": value.encode("utf-8")})

    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]

    def validate_tBandType(self, value):
        # Validate type tBandType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '01',
                '02',
                '03',
                '04',
                '05',
                '06',
                '07',
                '08',
                '09',
                '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on tBandType' % {
        "value": value.encode("utf-8")})

    def validate_cAutType(self, value):
        # Validate type cAutType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on cAutType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on cAutType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_cAutType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_cAutType_patterns_, ))
    validate_cAutType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.tpIntegra is not None or
            self.CNPJ is not None or
            self.tBand is not None or
            self.cAut is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='cardType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='cardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='cardType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='cardType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='cardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpIntegra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpIntegra>%s</%stpIntegra>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpIntegra),
            input_name='tpIntegra')),
                    namespace_,
                    eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCNPJ>%s</%sCNPJ>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CNPJ),
            input_name='CNPJ')),
                    namespace_,
                    eol_))
        if self.tBand is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stBand>%s</%stBand>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tBand),
            input_name='tBand')),
                    namespace_,
                    eol_))
        if self.cAut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scAut>%s</%scAut>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cAut),
            input_name='cAut')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpIntegra':
            tpIntegra_ = child_.text
            tpIntegra_ = self.gds_validate_string(
                tpIntegra_, node, 'tpIntegra')
            self.tpIntegra = tpIntegra_
            # validate type tpIntegraType
            self.validate_tpIntegraType(self.tpIntegra)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'tBand':
            tBand_ = child_.text
            tBand_ = self.gds_validate_string(tBand_, node, 'tBand')
            self.tBand = tBand_
            # validate type tBandType
            self.validate_tBandType(self.tBand)
        elif nodeName_ == 'cAut':
            cAut_ = child_.text
            cAut_ = self.gds_validate_string(cAut_, node, 'cAut')
            self.cAut = cAut_
            # validate type cAutType
            self.validate_cAutType(self.cAut)
# end class cardType


class infAdicType(GeneratedsSuper):
    """Informações adicionais da NF-e"""
    subclass = None
    superclass = None

    def __init__(self, infAdFisco=None, infCpl=None,
                 obsCont=None, obsFisco=None, procRef=None):
        self.original_tagname_ = None
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType(self.infAdFisco)
        self.infCpl = infCpl
        self.validate_infCplType(self.infCpl)
        if obsCont is None:
            self.obsCont = []
        else:
            self.obsCont = obsCont
        if obsFisco is None:
            self.obsFisco = []
        else:
            self.obsFisco = obsFisco
        if procRef is None:
            self.procRef = []
        else:
            self.procRef = procRef

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdicType.subclass:
            return infAdicType.subclass(*args_, **kwargs_)
        else:
            return infAdicType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_infAdFisco(self): return self.infAdFisco

    def set_infAdFisco(self, infAdFisco): self.infAdFisco = infAdFisco

    def get_infCpl(self): return self.infCpl

    def set_infCpl(self, infCpl): self.infCpl = infCpl

    def get_obsCont(self): return self.obsCont

    def set_obsCont(self, obsCont): self.obsCont = obsCont

    def add_obsCont(self, value): self.obsCont.append(value)

    def insert_obsCont_at(
        self,
        index,
        value): self.obsCont.insert(
        index,
        value)

    def replace_obsCont_at(self, index, value): self.obsCont[index] = value

    def get_obsFisco(self): return self.obsFisco

    def set_obsFisco(self, obsFisco): self.obsFisco = obsFisco

    def add_obsFisco(self, value): self.obsFisco.append(value)

    def insert_obsFisco_at(
        self,
        index,
        value): self.obsFisco.insert(
        index,
        value)

    def replace_obsFisco_at(self, index, value): self.obsFisco[index] = value

    def get_procRef(self): return self.procRef

    def set_procRef(self, procRef): self.procRef = procRef

    def add_procRef(self, value): self.procRef.append(value)

    def insert_procRef_at(
        self,
        index,
        value): self.procRef.insert(
        index,
        value)

    def replace_procRef_at(self, index, value): self.procRef[index] = value

    def validate_infAdFiscoType(self, value):
        # Validate type infAdFiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on infAdFiscoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on infAdFiscoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_infAdFiscoType_patterns_, ))
    validate_infAdFiscoType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_infCplType(self, value):
        # Validate type infCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 5000:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on infCplType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on infCplType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_infCplType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_infCplType_patterns_, ))
    validate_infCplType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.infAdFisco is not None or
            self.infCpl is not None or
            self.obsCont or
            self.obsFisco or
            self.procRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='infAdicType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdicType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='infAdicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='infAdicType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='infAdicType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='infAdicType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infAdFisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sinfAdFisco>%s</%sinfAdFisco>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.infAdFisco),
            input_name='infAdFisco')),
                    namespace_,
                    eol_))
        if self.infCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sinfCpl>%s</%sinfCpl>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.infCpl),
            input_name='infCpl')),
                    namespace_,
                    eol_))
        for obsCont_ in self.obsCont:
            obsCont_.export(
                outfile,
                level,
                namespace_,
                name_='obsCont',
                pretty_print=pretty_print)
        for obsFisco_ in self.obsFisco:
            obsFisco_.export(
                outfile,
                level,
                namespace_,
                name_='obsFisco',
                pretty_print=pretty_print)
        for procRef_ in self.procRef:
            procRef_.export(
                outfile,
                level,
                namespace_,
                name_='procRef',
                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infAdFisco':
            infAdFisco_ = child_.text
            infAdFisco_ = self.gds_validate_string(
                infAdFisco_, node, 'infAdFisco')
            self.infAdFisco = infAdFisco_
            # validate type infAdFiscoType
            self.validate_infAdFiscoType(self.infAdFisco)
        elif nodeName_ == 'infCpl':
            infCpl_ = child_.text
            infCpl_ = self.gds_validate_string(infCpl_, node, 'infCpl')
            self.infCpl = infCpl_
            # validate type infCplType
            self.validate_infCplType(self.infCpl)
        elif nodeName_ == 'obsCont':
            obj_ = obsContType.factory()
            obj_.build(child_)
            self.obsCont.append(obj_)
            obj_.original_tagname_ = 'obsCont'
        elif nodeName_ == 'obsFisco':
            obj_ = obsFiscoType.factory()
            obj_.build(child_)
            self.obsFisco.append(obj_)
            obj_.original_tagname_ = 'obsFisco'
        elif nodeName_ == 'procRef':
            obj_ = procRefType.factory()
            obj_.build(child_)
            self.procRef.append(obj_)
            obj_.original_tagname_ = 'procRef'
# end class infAdicType


class obsContType(GeneratedsSuper):
    """Campo de uso livre do contribuinte
informar o nome do campo no atributo xCampo
e o conteúdo do campo no xTexto"""
    subclass = None
    superclass = None

    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType(self.xTexto)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsContType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsContType.subclass:
            return obsContType.subclass(*args_, **kwargs_)
        else:
            return obsContType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xTexto(self): return self.xTexto

    def set_xTexto(self, xTexto): self.xTexto = xTexto

    def get_xCampo(self): return self.xCampo

    def set_xCampo(self, xCampo): self.xCampo = xCampo

    def validate_xTextoType(self, value):
        # Validate type xTextoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xTextoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xTextoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xTextoType_patterns_, ))
    validate_xTextoType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='obsContType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsContType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='obsContType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='obsContType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='obsContType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='obsContType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxTexto>%s</%sxTexto>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xTexto),
            input_name='xTexto')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType
            self.validate_xTextoType(self.xTexto)
# end class obsContType


class obsFiscoType(GeneratedsSuper):
    """Campo de uso exclusivo do Fisco
informar o nome do campo no atributo xCampo
e o conteúdo do campo no xTexto"""
    subclass = None
    superclass = None

    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType51(self.xTexto)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsFiscoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsFiscoType.subclass:
            return obsFiscoType.subclass(*args_, **kwargs_)
        else:
            return obsFiscoType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xTexto(self): return self.xTexto

    def set_xTexto(self, xTexto): self.xTexto = xTexto

    def get_xCampo(self): return self.xCampo

    def set_xCampo(self, xCampo): self.xCampo = xCampo

    def validate_xTextoType51(self, value):
        # Validate type xTextoType51, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xTextoType51' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xTextoType51' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType51_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xTextoType51_patterns_, ))
    validate_xTextoType51_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='obsFiscoType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsFiscoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='obsFiscoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='obsFiscoType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='obsFiscoType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='obsFiscoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxTexto>%s</%sxTexto>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xTexto),
            input_name='xTexto')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType51
            self.validate_xTextoType51(self.xTexto)
# end class obsFiscoType


class procRefType(GeneratedsSuper):
    """Grupo de informações do  processo referenciado"""
    subclass = None
    superclass = None

    def __init__(self, nProc=None, indProc=None):
        self.original_tagname_ = None
        self.nProc = nProc
        self.validate_nProcType(self.nProc)
        self.indProc = indProc
        self.validate_indProcType(self.indProc)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procRefType.subclass:
            return procRefType.subclass(*args_, **kwargs_)
        else:
            return procRefType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nProc(self): return self.nProc

    def set_nProc(self, nProc): self.nProc = nProc

    def get_indProc(self): return self.indProc

    def set_indProc(self, indProc): self.indProc = indProc

    def validate_nProcType(self, value):
        # Validate type nProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on nProcType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on nProcType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_nProcType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_nProcType_patterns_, ))
    validate_nProcType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_indProcType(self, value):
        # Validate type indProcType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on indProcType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.nProc is not None or
            self.indProc is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='procRefType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='procRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='procRefType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='procRefType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='procRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snProc>%s</%snProc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nProc),
            input_name='nProc')),
                    namespace_,
                    eol_))
        if self.indProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sindProc>%s</%sindProc>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.indProc),
            input_name='indProc')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nProc':
            nProc_ = child_.text
            nProc_ = self.gds_validate_string(nProc_, node, 'nProc')
            self.nProc = nProc_
            # validate type nProcType
            self.validate_nProcType(self.nProc)
        elif nodeName_ == 'indProc':
            indProc_ = child_.text
            indProc_ = self.gds_validate_string(indProc_, node, 'indProc')
            self.indProc = indProc_
            # validate type indProcType
            self.validate_indProcType(self.indProc)
# end class procRefType


class exportaType(GeneratedsSuper):
    """Informações de exportação"""
    subclass = None
    superclass = None

    def __init__(self, UFSaidaPais=None, xLocExporta=None, xLocDespacho=None):
        self.original_tagname_ = None
        self.UFSaidaPais = UFSaidaPais
        self.validate_TUfEmi(self.UFSaidaPais)
        self.xLocExporta = xLocExporta
        self.validate_xLocExportaType(self.xLocExporta)
        self.xLocDespacho = xLocDespacho
        self.validate_xLocDespachoType(self.xLocDespacho)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportaType.subclass:
            return exportaType.subclass(*args_, **kwargs_)
        else:
            return exportaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_UFSaidaPais(self): return self.UFSaidaPais

    def set_UFSaidaPais(self, UFSaidaPais): self.UFSaidaPais = UFSaidaPais

    def get_xLocExporta(self): return self.xLocExporta

    def set_xLocExporta(self, xLocExporta): self.xLocExporta = xLocExporta

    def get_xLocDespacho(self): return self.xLocDespacho

    def set_xLocDespacho(self, xLocDespacho): self.xLocDespacho = xLocDespacho

    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                'AC',
                'AL',
                'AM',
                'AP',
                'BA',
                'CE',
                'DF',
                'ES',
                'GO',
                'MA',
                'MG',
                'MS',
                'MT',
                'PA',
                'PB',
                'PE',
                'PI',
                'PR',
                'RJ',
                'RN',
                'RO',
                'RR',
                'RS',
                'SC',
                'SE',
                'SP',
                'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {
        "value": value.encode("utf-8")})

    def validate_xLocExportaType(self, value):
        # Validate type xLocExportaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLocExportaType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLocExportaType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocExportaType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLocExportaType_patterns_, ))
    validate_xLocExportaType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xLocDespachoType(self, value):
        # Validate type xLocDespachoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xLocDespachoType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xLocDespachoType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDespachoType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xLocDespachoType_patterns_, ))
    validate_xLocDespachoType_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.UFSaidaPais is not None or
            self.xLocExporta is not None or
            self.xLocDespacho is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='exportaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='exportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='exportaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='exportaType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='exportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFSaidaPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sUFSaidaPais>%s</%sUFSaidaPais>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.UFSaidaPais),
            input_name='UFSaidaPais')),
                    namespace_,
                    eol_))
        if self.xLocExporta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLocExporta>%s</%sxLocExporta>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLocExporta),
            input_name='xLocExporta')),
                    namespace_,
                    eol_))
        if self.xLocDespacho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxLocDespacho>%s</%sxLocDespacho>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xLocDespacho),
            input_name='xLocDespacho')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFSaidaPais':
            UFSaidaPais_ = child_.text
            UFSaidaPais_ = self.gds_validate_string(
                UFSaidaPais_, node, 'UFSaidaPais')
            self.UFSaidaPais = UFSaidaPais_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFSaidaPais)
        elif nodeName_ == 'xLocExporta':
            xLocExporta_ = child_.text
            xLocExporta_ = self.gds_validate_string(
                xLocExporta_, node, 'xLocExporta')
            self.xLocExporta = xLocExporta_
            # validate type xLocExportaType
            self.validate_xLocExportaType(self.xLocExporta)
        elif nodeName_ == 'xLocDespacho':
            xLocDespacho_ = child_.text
            xLocDespacho_ = self.gds_validate_string(
                xLocDespacho_, node, 'xLocDespacho')
            self.xLocDespacho = xLocDespacho_
            # validate type xLocDespachoType
            self.validate_xLocDespachoType(self.xLocDespacho)
# end class exportaType


class compraType(GeneratedsSuper):
    """Informações de compras  (Nota de Empenho, Pedido e Contrato)"""
    subclass = None
    superclass = None

    def __init__(self, xNEmp=None, xPed=None, xCont=None):
        self.original_tagname_ = None
        self.xNEmp = xNEmp
        self.validate_xNEmpType(self.xNEmp)
        self.xPed = xPed
        self.validate_xPedType52(self.xPed)
        self.xCont = xCont
        self.validate_xContType(self.xCont)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compraType.subclass:
            return compraType.subclass(*args_, **kwargs_)
        else:
            return compraType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xNEmp(self): return self.xNEmp

    def set_xNEmp(self, xNEmp): self.xNEmp = xNEmp

    def get_xPed(self): return self.xPed

    def set_xPed(self, xPed): self.xPed = xPed

    def get_xCont(self): return self.xCont

    def set_xCont(self, xCont): self.xCont = xCont

    def validate_xNEmpType(self, value):
        # Validate type xNEmpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 22:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xNEmpType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xNEmpType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xNEmpType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xNEmpType_patterns_, ))
    validate_xNEmpType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xPedType52(self, value):
        # Validate type xPedType52, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xPedType52' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xPedType52' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType52_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xPedType52_patterns_, ))
    validate_xPedType52_patterns_ = [
        ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_xContType(self, value):
        # Validate type xContType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xContType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xContType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xContType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xContType_patterns_, ))
    validate_xContType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.xNEmp is not None or
            self.xPed is not None or
            self.xCont is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='compraType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='compraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='compraType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='compraType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='compraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNEmp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxNEmp>%s</%sxNEmp>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xNEmp),
            input_name='xNEmp')),
                    namespace_,
                    eol_))
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxPed>%s</%sxPed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xPed),
            input_name='xPed')),
                    namespace_,
                    eol_))
        if self.xCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxCont>%s</%sxCont>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xCont),
            input_name='xCont')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xNEmp':
            xNEmp_ = child_.text
            xNEmp_ = self.gds_validate_string(xNEmp_, node, 'xNEmp')
            self.xNEmp = xNEmp_
            # validate type xNEmpType
            self.validate_xNEmpType(self.xNEmp)
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType52
            self.validate_xPedType52(self.xPed)
        elif nodeName_ == 'xCont':
            xCont_ = child_.text
            xCont_ = self.gds_validate_string(xCont_, node, 'xCont')
            self.xCont = xCont_
            # validate type xContType
            self.validate_xContType(self.xCont)
# end class compraType


class canaType(GeneratedsSuper):
    """Informações de registro aquisições de cana"""
    subclass = None
    superclass = None

    def __init__(self, safra=None, ref=None, forDia=None, qTotMes=None, qTotAnt=None,
                 qTotGer=None, deduc=None, vFor=None, vTotDed=None, vLiqFor=None):
        self.original_tagname_ = None
        self.safra = safra
        self.validate_safraType(self.safra)
        self.ref = ref
        self.validate_refType(self.ref)
        if forDia is None:
            self.forDia = []
        else:
            self.forDia = forDia
        self.qTotMes = qTotMes
        self.validate_TDec_1110v(self.qTotMes)
        self.qTotAnt = qTotAnt
        self.validate_TDec_1110v(self.qTotAnt)
        self.qTotGer = qTotGer
        self.validate_TDec_1110v(self.qTotGer)
        if deduc is None:
            self.deduc = []
        else:
            self.deduc = deduc
        self.vFor = vFor
        self.validate_TDec_1302(self.vFor)
        self.vTotDed = vTotDed
        self.validate_TDec_1302(self.vTotDed)
        self.vLiqFor = vLiqFor
        self.validate_TDec_1302(self.vLiqFor)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, canaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if canaType.subclass:
            return canaType.subclass(*args_, **kwargs_)
        else:
            return canaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_safra(self): return self.safra

    def set_safra(self, safra): self.safra = safra

    def get_ref(self): return self.ref

    def set_ref(self, ref): self.ref = ref

    def get_forDia(self): return self.forDia

    def set_forDia(self, forDia): self.forDia = forDia

    def add_forDia(self, value): self.forDia.append(value)

    def insert_forDia_at(self, index, value): self.forDia.insert(index, value)

    def replace_forDia_at(self, index, value): self.forDia[index] = value

    def get_qTotMes(self): return self.qTotMes

    def set_qTotMes(self, qTotMes): self.qTotMes = qTotMes

    def get_qTotAnt(self): return self.qTotAnt

    def set_qTotAnt(self, qTotAnt): self.qTotAnt = qTotAnt

    def get_qTotGer(self): return self.qTotGer

    def set_qTotGer(self, qTotGer): self.qTotGer = qTotGer

    def get_deduc(self): return self.deduc

    def set_deduc(self, deduc): self.deduc = deduc

    def add_deduc(self, value): self.deduc.append(value)

    def insert_deduc_at(self, index, value): self.deduc.insert(index, value)

    def replace_deduc_at(self, index, value): self.deduc[index] = value

    def get_vFor(self): return self.vFor

    def set_vFor(self, vFor): self.vFor = vFor

    def get_vTotDed(self): return self.vTotDed

    def set_vTotDed(self, vTotDed): self.vTotDed = vTotDed

    def get_vLiqFor(self): return self.vLiqFor

    def set_vLiqFor(self, vLiqFor): self.vLiqFor = vLiqFor

    def validate_safraType(self, value):
        # Validate type safraType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on safraType' % {
        "value": value})
            if len(str(value)) < 4:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on safraType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_safraType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_safraType_patterns_, ))
    validate_safraType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_refType(self, value):
        # Validate type refType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_refType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_refType_patterns_, ))
    validate_refType_patterns_ = [
        ['^(0[1-9]$|^1[0-2])([/][2][0-9][0-9][0-9])$']]

    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.safra is not None or
            self.ref is not None or
            self.forDia or
            self.qTotMes is not None or
            self.qTotAnt is not None or
            self.qTotGer is not None or
            self.deduc or
            self.vFor is not None or
            self.vTotDed is not None or
            self.vLiqFor is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='canaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('canaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='canaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='canaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='canaType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='canaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.safra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%ssafra>%s</%ssafra>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.safra),
            input_name='safra')),
                    namespace_,
                    eol_))
        if self.ref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sref>%s</%sref>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.ref),
            input_name='ref')),
                    namespace_,
                    eol_))
        for forDia_ in self.forDia:
            forDia_.export(
                outfile,
                level,
                namespace_,
                name_='forDia',
                pretty_print=pretty_print)
        if self.qTotMes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqTotMes>%s</%sqTotMes>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qTotMes),
            input_name='qTotMes')),
                    namespace_,
                    eol_))
        if self.qTotAnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqTotAnt>%s</%sqTotAnt>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qTotAnt),
            input_name='qTotAnt')),
                    namespace_,
                    eol_))
        if self.qTotGer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqTotGer>%s</%sqTotGer>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qTotGer),
            input_name='qTotGer')),
                    namespace_,
                    eol_))
        for deduc_ in self.deduc:
            deduc_.export(
                outfile,
                level,
                namespace_,
                name_='deduc',
                pretty_print=pretty_print)
        if self.vFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svFor>%s</%svFor>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vFor),
            input_name='vFor')),
                    namespace_,
                    eol_))
        if self.vTotDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svTotDed>%s</%svTotDed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vTotDed),
            input_name='vTotDed')),
                    namespace_,
                    eol_))
        if self.vLiqFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svLiqFor>%s</%svLiqFor>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vLiqFor),
            input_name='vLiqFor')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'safra':
            safra_ = child_.text
            safra_ = self.gds_validate_string(safra_, node, 'safra')
            self.safra = safra_
            # validate type safraType
            self.validate_safraType(self.safra)
        elif nodeName_ == 'ref':
            ref_ = child_.text
            ref_ = self.gds_validate_string(ref_, node, 'ref')
            self.ref = ref_
            # validate type refType
            self.validate_refType(self.ref)
        elif nodeName_ == 'forDia':
            obj_ = forDiaType.factory()
            obj_.build(child_)
            self.forDia.append(obj_)
            obj_.original_tagname_ = 'forDia'
        elif nodeName_ == 'qTotMes':
            qTotMes_ = child_.text
            qTotMes_ = self.gds_validate_string(qTotMes_, node, 'qTotMes')
            self.qTotMes = qTotMes_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotMes)
        elif nodeName_ == 'qTotAnt':
            qTotAnt_ = child_.text
            qTotAnt_ = self.gds_validate_string(qTotAnt_, node, 'qTotAnt')
            self.qTotAnt = qTotAnt_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotAnt)
        elif nodeName_ == 'qTotGer':
            qTotGer_ = child_.text
            qTotGer_ = self.gds_validate_string(qTotGer_, node, 'qTotGer')
            self.qTotGer = qTotGer_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotGer)
        elif nodeName_ == 'deduc':
            obj_ = deducType.factory()
            obj_.build(child_)
            self.deduc.append(obj_)
            obj_.original_tagname_ = 'deduc'
        elif nodeName_ == 'vFor':
            vFor_ = child_.text
            vFor_ = self.gds_validate_string(vFor_, node, 'vFor')
            self.vFor = vFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFor)
        elif nodeName_ == 'vTotDed':
            vTotDed_ = child_.text
            vTotDed_ = self.gds_validate_string(vTotDed_, node, 'vTotDed')
            self.vTotDed = vTotDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotDed)
        elif nodeName_ == 'vLiqFor':
            vLiqFor_ = child_.text
            vLiqFor_ = self.gds_validate_string(vLiqFor_, node, 'vLiqFor')
            self.vLiqFor = vLiqFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vLiqFor)
# end class canaType


class forDiaType(GeneratedsSuper):
    """Fornecimentos diários"""
    subclass = None
    superclass = None

    def __init__(self, dia=None, qtde=None):
        self.original_tagname_ = None
        self.dia = _cast(None, dia)
        self.qtde = qtde
        self.validate_TDec_1110v(self.qtde)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, forDiaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if forDiaType.subclass:
            return forDiaType.subclass(*args_, **kwargs_)
        else:
            return forDiaType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_qtde(self): return self.qtde

    def set_qtde(self, qtde): self.qtde = qtde

    def get_dia(self): return self.dia

    def set_dia(self, dia): self.dia = dia

    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]

    def hasContent_(self):
        if (
            self.qtde is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='forDiaType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('forDiaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='forDiaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='forDiaType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='forDiaType'):
        if self.dia is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            outfile.write(
                ' dia=%s' %
                (self.gds_encode(
                    self.gds_format_string(
                        quote_attrib(
                self.dia),
                        input_name='dia')),
                ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='forDiaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qtde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqtde>%s</%sqtde>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qtde),
            input_name='qtde')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dia', node)
        if value is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            self.dia = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qtde':
            qtde_ = child_.text
            qtde_ = self.gds_validate_string(qtde_, node, 'qtde')
            self.qtde = qtde_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qtde)
# end class forDiaType


class deducType(GeneratedsSuper):
    """Deduções - Taxas e Contribuições"""
    subclass = None
    superclass = None

    def __init__(self, xDed=None, vDed=None):
        self.original_tagname_ = None
        self.xDed = xDed
        self.validate_xDedType(self.xDed)
        self.vDed = vDed
        self.validate_TDec_1302(self.vDed)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, deducType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if deducType.subclass:
            return deducType.subclass(*args_, **kwargs_)
        else:
            return deducType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_xDed(self): return self.xDed

    def set_xDed(self, xDed): self.xDed = xDed

    def get_vDed(self): return self.vDed

    def set_vDed(self, vDed): self.vDed = vDed

    def validate_xDedType(self, value):
        # Validate type xDedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on xDedType' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on xDedType' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_xDedType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_xDedType_patterns_, ))
    validate_xDedType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def hasContent_(self):
        if (
            self.xDed is not None or
            self.vDed is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='deducType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('deducType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='deducType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='deducType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='deducType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='deducType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxDed>%s</%sxDed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xDed),
            input_name='xDed')),
                    namespace_,
                    eol_))
        if self.vDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svDed>%s</%svDed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vDed),
            input_name='vDed')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xDed':
            xDed_ = child_.text
            xDed_ = self.gds_validate_string(xDed_, node, 'xDed')
            self.xDed = xDed_
            # validate type xDedType
            self.validate_xDedType(self.xDed)
        elif nodeName_ == 'vDed':
            vDed_ = child_.text
            vDed_ = self.gds_validate_string(vDed_, node, 'vDed')
            self.vDed = vDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDed)
# end class deducType


class infNFeSuplType(GeneratedsSuper):
    """Informações suplementares Nota Fiscal"""
    subclass = None
    superclass = None

    def __init__(self, qrCode=None, urlChave=None):
        self.original_tagname_ = None
        self.qrCode = qrCode
        self.validate_qrCodeType(self.qrCode)
        self.urlChave = urlChave
        self.validate_urlChaveType(self.urlChave)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeSuplType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeSuplType.subclass:
            return infNFeSuplType.subclass(*args_, **kwargs_)
        else:
            return infNFeSuplType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_qrCode(self): return self.qrCode

    def set_qrCode(self, qrCode): self.qrCode = qrCode

    def get_urlChave(self): return self.urlChave

    def set_urlChave(self, urlChave): self.urlChave = urlChave

    def validate_qrCodeType(self, value):
        # Validate type qrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 600:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on qrCodeType' % {
        "value": value.encode("utf-8")})
            if len(value) < 100:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on qrCodeType' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodeType_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_qrCodeType_patterns_, ))
    validate_qrCodeType_patterns_ = [
        ['^((HTTPS?$|^https?)://.*\\?chNFe=[0-9]{44}&nVersao=[0-9]{3}&tpAmb=[1-2](&cDest=([A-Za-z0-9.:+-/)(]{0}$|^[A-Za-z0-9.:+-/)(]{5,20})?)?&dhEmi=[A-Fa-f0-9]{50}&vNF=(0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&vICMS=(0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&digVal=[A-Fa-f0-9]{56}&cIdToken=[0-9]{6}&cHashQRCode=[A-Fa-f0-9]{40})$']]

    def validate_urlChaveType(self, value):
        # Validate type urlChaveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 85:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on urlChaveType' % {
        "value": value.encode("utf-8")})
            if len(value) < 21:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on urlChaveType' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.qrCode is not None or
            self.urlChave is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='infNFeSuplType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeSuplType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='infNFeSuplType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='infNFeSuplType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='infNFeSuplType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='infNFeSuplType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqrCode>%s</%sqrCode>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qrCode),
            input_name='qrCode')),
                    namespace_,
                    eol_))
        if self.urlChave is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%surlChave>%s</%surlChave>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.urlChave),
            input_name='urlChave')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qrCode':
            qrCode_ = child_.text
            qrCode_ = self.gds_validate_string(qrCode_, node, 'qrCode')
            self.qrCode = qrCode_
            # validate type qrCodeType
            self.validate_qrCodeType(self.qrCode)
        elif nodeName_ == 'urlChave':
            urlChave_ = child_.text
            urlChave_ = self.gds_validate_string(urlChave_, node, 'urlChave')
            self.urlChave = urlChave_
            # validate type urlChaveType
            self.validate_urlChaveType(self.urlChave)
# end class infNFeSuplType


class infProtType(GeneratedsSuper):
    """Dados do protocolo de status"""
    subclass = None
    superclass = None

    def __init__(self, Id=None, tpAmb=None, verAplic=None, chNFe=None,
                 dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType.subclass:
            return infProtType.subclass(*args_, **kwargs_)
        else:
            return infProtType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_tpAmb(self): return self.tpAmb

    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb

    def get_verAplic(self): return self.verAplic

    def set_verAplic(self, verAplic): self.verAplic = verAplic

    def get_chNFe(self): return self.chNFe

    def set_chNFe(self, chNFe): self.chNFe = chNFe

    def get_dhRecbto(self): return self.dhRecbto

    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto

    def get_nProt(self): return self.nProt

    def set_nProt(self, nProt): self.nProt = nProt

    def get_digVal(self): return self.digVal

    def set_digVal(self, digVal): self.digVal = digVal

    def get_cStat(self): return self.cStat

    def set_cStat(self, cStat): self.cStat = cStat

    def get_xMotivo(self): return self.xMotivo

    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo

    def get_Id(self): return self.Id

    def set_Id(self, Id): self.Id = Id

    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {
        "value": value.encode("utf-8")})

    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]

    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [
        ['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]

    def validate_TProt(self, value):
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TProt' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TProt_patterns_, ))
    validate_TProt_patterns_ = [['^[0-9]{15}$']]

    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass

    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TStat' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]

    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {
        "value": value})
            if len(str(value)) < 1:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {
        "value": value})
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]

    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chNFe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='infProtType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='infProtType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='infProtType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='infProtType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(
                ' Id=%s' %
                (self.gds_encode(
                    self.gds_format_string(
                        quote_attrib(
                self.Id),
                        input_name='Id')),
                ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='infProtType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stpAmb>%s</%stpAmb>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tpAmb),
            input_name='tpAmb')),
                    namespace_,
                    eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sverAplic>%s</%sverAplic>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.verAplic),
            input_name='verAplic')),
                    namespace_,
                    eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%schNFe>%s</%schNFe>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.chNFe),
            input_name='chNFe')),
                    namespace_,
                    eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdhRecbto>%s</%sdhRecbto>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.dhRecbto),
            input_name='dhRecbto')),
                    namespace_,
                    eol_))
        if self.nProt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snProt>%s</%snProt>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nProt),
            input_name='nProt')),
                    namespace_,
                    eol_))
        if self.digVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sdigVal>%s</%sdigVal>%s' %
                (namespace_,
                 self.gds_format_base64(
                     self.digVal,
                     input_name='digVal'),
                    namespace_,
                    eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%scStat>%s</%scStat>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.cStat),
            input_name='cStat')),
                    namespace_,
                    eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sxMotivo>%s</%sxMotivo>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.xMotivo),
            input_name='xMotivo')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            nProt_ = child_.text
            nProt_ = self.gds_validate_string(nProt_, node, 'nProt')
            self.nProt = nProt_
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(
                        child_,
                        'requires base64 encoded string: %s' %
                        exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
# end class infProtType


class infRecType(GeneratedsSuper):
    """Dados do Recibo do Lote"""
    subclass = None
    superclass = None

    def __init__(self, nRec=None, tMed=None):
        self.original_tagname_ = None
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.tMed = tMed
        self.validate_TMed(self.tMed)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRecType.subclass:
            return infRecType.subclass(*args_, **kwargs_)
        else:
            return infRecType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_nRec(self): return self.nRec

    def set_nRec(self, nRec): self.nRec = nRec

    def get_tMed(self): return self.tMed

    def set_tMed(self, tMed): self.tMed = tMed

    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd maxLength restriction on TRec' % {
        "value": value.encode("utf-8")})
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]

    def validate_TMed(self, value):
        # Validate type TMed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TMed_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TMed_patterns_, ))
    validate_TMed_patterns_ = [['^[0-9]{1,4}$']]

    def hasContent_(self):
        if (
            self.nRec is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='infRecType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='infRecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='infRecType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='infRecType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='infRecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%snRec>%s</%snRec>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.nRec),
            input_name='nRec')),
                    namespace_,
                    eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%stMed>%s</%stMed>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.tMed),
            input_name='tMed')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'tMed':
            tMed_ = child_.text
            tMed_ = self.gds_validate_string(tMed_, node, 'tMed')
            self.tMed = tMed_
            # validate type TMed
            self.validate_TMed(self.tMed)
# end class infRecType


class IPITribType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, CST=None, vBC=None, pIPI=None,
                 qUnid=None, vUnid=None, vIPI=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType70(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pIPI = pIPI
        self.validate_TDec_0302a04(self.pIPI)
        self.qUnid = qUnid
        self.validate_TDec_1204v(self.qUnid)
        self.vUnid = vUnid
        self.validate_TDec_1104(self.vUnid)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPITribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPITribType.subclass:
            return IPITribType.subclass(*args_, **kwargs_)
        else:
            return IPITribType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def get_vBC(self): return self.vBC

    def set_vBC(self, vBC): self.vBC = vBC

    def get_pIPI(self): return self.pIPI

    def set_pIPI(self, pIPI): self.pIPI = pIPI

    def get_qUnid(self): return self.qUnid

    def set_qUnid(self, qUnid): self.qUnid = qUnid

    def get_vUnid(self): return self.vUnid

    def set_vUnid(self, vUnid): self.vUnid = vUnid

    def get_vIPI(self): return self.vIPI

    def set_vIPI(self, vIPI): self.vIPI = vIPI

    def validate_CSTType70(self, value):
        # Validate type CSTType70, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00', '49', '50', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType70' % {
        "value": value.encode("utf-8")})

    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [
        ['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]

    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [
        ['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]

    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [
        ['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]

    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn(
                    'Value "%s" does not match xsd pattern restrictions: %s' %
                    (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [
        ['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]

    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pIPI is not None or
            self.qUnid is not None or
            self.vUnid is not None or
            self.vIPI is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='IPITribType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPITribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='IPITribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='IPITribType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='IPITribType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='IPITribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svBC>%s</%svBC>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vBC),
            input_name='vBC')),
                    namespace_,
                    eol_))
        if self.pIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%spIPI>%s</%spIPI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.pIPI),
            input_name='pIPI')),
                    namespace_,
                    eol_))
        if self.qUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sqUnid>%s</%sqUnid>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.qUnid),
            input_name='qUnid')),
                    namespace_,
                    eol_))
        if self.vUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svUnid>%s</%svUnid>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vUnid),
            input_name='vUnid')),
                    namespace_,
                    eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%svIPI>%s</%svIPI>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.vIPI),
            input_name='vIPI')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType70
            self.validate_CSTType70(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pIPI':
            pIPI_ = child_.text
            pIPI_ = self.gds_validate_string(pIPI_, node, 'pIPI')
            self.pIPI = pIPI_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pIPI)
        elif nodeName_ == 'qUnid':
            qUnid_ = child_.text
            qUnid_ = self.gds_validate_string(qUnid_, node, 'qUnid')
            self.qUnid = qUnid_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qUnid)
        elif nodeName_ == 'vUnid':
            vUnid_ = child_.text
            vUnid_ = self.gds_validate_string(vUnid_, node, 'vUnid')
            self.vUnid = vUnid_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vUnid)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
# end class IPITribType


class IPINTType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType71(self.CST)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPINTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPINTType.subclass:
            return IPINTType.subclass(*args_, **kwargs_)
        else:
            return IPINTType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_CST(self): return self.CST

    def set_CST(self, CST): self.CST = CST

    def validate_CSTType71(self, value):
        # Validate type CSTType71, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = [
                '01',
                '02',
                '03',
                '04',
                '05',
                '51',
                '52',
                '53',
                '54',
                '55']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on CSTType71' % {
        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='IPINTType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPINTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='IPINTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='IPINTType',
                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='IPINTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='IPINTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sCST>%s</%sCST>%s' %
                (namespace_,
                 self.gds_encode(
                     self.gds_format_string(
             quote_xml(
                self.CST),
            input_name='CST')),
                    namespace_,
                    eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType71
            self.validate_CSTType71(self.CST)
# end class IPINTType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Algorithm(self): return self.Algorithm

    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='CanonicalizationMethodType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            'CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='CanonicalizationMethodType',
                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Algorithm(self): return self.Algorithm

    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='SignatureMethodType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='SignatureMethodType',
                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)

    def get_Algorithm(self): return self.Algorithm

    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='editix:', name_='DigestMethodType',
               namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write(
            '<%s%s%s' %
            (namespace_,
             name_,
             namespacedef_ and ' ' +
             namespacedef_ or '',
             ))
        already_processed = set()
        self.exportAttributes(
            outfile,
            level,
            already_processed,
            namespace_,
            name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(
                outfile,
                level + 1,
                namespace_='editix:',
                name_='DigestMethodType',
                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))

    def exportAttributes(self, outfile, level, already_processed,
                         namespace_='editix:', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))

    def exportChildren(self, outfile, level, namespace_='editix:',
                       name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'CIDE': CIDEType,
    'COFINS': COFINSType,
    'COFINSAliq': COFINSAliqType,
    'COFINSNT': COFINSNTType,
    'COFINSOutr': COFINSOutrType,
    'COFINSQtde': COFINSQtdeType,
    'COFINSST': COFINSSTType,
    'CanonicalizationMethod': CanonicalizationMethodType,
    'DI': DIType,
    'DigestMethod': DigestMethodType,
    'ICMS': ICMSType,
    'ICMS00': ICMS00Type,
    'ICMS10': ICMS10Type,
    'ICMS20': ICMS20Type,
    'ICMS30': ICMS30Type,
    'ICMS40': ICMS40Type,
    'ICMS51': ICMS51Type,
    'ICMS60': ICMS60Type,
    'ICMS70': ICMS70Type,
    'ICMS90': ICMS90Type,
    'ICMSPart': ICMSPartType,
    'ICMSSN101': ICMSSN101Type,
    'ICMSSN102': ICMSSN102Type,
    'ICMSSN201': ICMSSN201Type,
    'ICMSSN202': ICMSSN202Type,
    'ICMSSN500': ICMSSN500Type,
    'ICMSSN900': ICMSSN900Type,
    'ICMSST': ICMSSTType,
    'ICMSTot': ICMSTotType,
    'ICMSUFDest': ICMSUFDestType,
    'II': IIType,
    'IPI': IPIType,
    'IPINT': IPINTType,
    'IPITrib': IPITribType,
    'ISSQN': ISSQNType,
    'ISSQNtot': ISSQNtotType,
    'KeyInfo': KeyInfoType,
    'NFe': TNFe,
    'NFref': NFrefType,
    'PIS': PISType,
    'PISAliq': PISAliqType,
    'PISNT': PISNTType,
    'PISOutr': PISOutrType,
    'PISQtde': PISQtdeType,
    'PISST': PISSTType,
    'Reference': ReferenceType,
    'Signature': SignatureType,
    'SignatureMethod': SignatureMethodType,
    'SignatureValue': SignatureValueType,
    'SignedInfo': SignedInfoType,
    'Transform': TransformType,
    'Transforms': TransformsType,
    'X509Data': X509DataType,
    'adi': adiType,
    'arma': armaType,
    'autXML': autXMLType,
    'avulsa': avulsaType,
    'cana': canaType,
    'card': cardType,
    'cobr': cobrType,
    'comb': combType,
    'compra': compraType,
    'deduc': deducType,
    'dest': destType,
    'det': detType,
    'detExport': detExportType,
    'detPag': detPagType,
    'dup': dupType,
    'emit': emitType,
    'encerrante': encerranteType,
    'enderDest': TEndereco,
    'enderEmit': TEnderEmi,
    'entrega': TLocal,
    'exportInd': exportIndType,
    'exporta': exportaType,
    'fat': fatType,
    'forDia': forDiaType,
    'ide': ideType,
    'imposto': impostoType,
    'impostoDevol': impostoDevolType,
    'infAdic': infAdicType,
    'infNFe': infNFeType,
    'infNFeSupl': infNFeSuplType,
    'infProt': infProtType,
    'infRec': infRecType,
    'lacres': lacresType,
    'med': medType,
    'obsCont': obsContType,
    'obsFisco': obsFiscoType,
    'pag': pagType,
    'procRef': procRefType,
    'prod': prodType,
    'protNFe': TProtNFe,
    'rastro': rastroType,
    'reboque': TVeiculo,
    'refECF': refECFType,
    'refNF': refNFType,
    'refNFP': refNFPType,
    'retTransp': retTranspType,
    'retTrib': retTribType,
    'retirada': TLocal,
    'total': totalType,
    'transp': transpType,
    'transporta': transportaType,
    'veicProd': veicProdType,
    'veicTransp': TVeiculo,
    'vol': volType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:editix="http://www.portalfiscal.inf.br/nfe"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from leiauteNFe import *\n\n')
        sys.stdout.write('import leiauteNFe as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CIDEType",
    "COFINSAliqType",
    "COFINSNTType",
    "COFINSOutrType",
    "COFINSQtdeType",
    "COFINSSTType",
    "COFINSType",
    "CanonicalizationMethodType",
    "DIType",
    "DigestMethodType",
    "ICMS00Type",
    "ICMS10Type",
    "ICMS20Type",
    "ICMS30Type",
    "ICMS40Type",
    "ICMS51Type",
    "ICMS60Type",
    "ICMS70Type",
    "ICMS90Type",
    "ICMSPartType",
    "ICMSSN101Type",
    "ICMSSN102Type",
    "ICMSSN201Type",
    "ICMSSN202Type",
    "ICMSSN500Type",
    "ICMSSN900Type",
    "ICMSSTType",
    "ICMSTotType",
    "ICMSType",
    "ICMSUFDestType",
    "IIType",
    "IPINTType",
    "IPITribType",
    "IPIType",
    "ISSQNType",
    "ISSQNtotType",
    "KeyInfoType",
    "NFrefType",
    "PISAliqType",
    "PISNTType",
    "PISOutrType",
    "PISQtdeType",
    "PISSTType",
    "PISType",
    "ReferenceType",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TConsReciNFe",
    "TEnderEmi",
    "TEndereco",
    "TEnviNFe",
    "TIpi",
    "TLocal",
    "TNFe",
    "TNfeProc",
    "TProtNFe",
    "TRetConsReciNFe",
    "TRetEnviNFe",
    "TVeiculo",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "adiType",
    "armaType",
    "autXMLType",
    "avulsaType",
    "canaType",
    "cardType",
    "cobrType",
    "combType",
    "compraType",
    "deducType",
    "destType",
    "detExportType",
    "detPagType",
    "detType",
    "dupType",
    "emitType",
    "encerranteType",
    "exportIndType",
    "exportaType",
    "fatType",
    "forDiaType",
    "ideType",
    "impostoDevolType",
    "impostoType",
    "infAdicType",
    "infNFeSuplType",
    "infNFeType",
    "infProtType",
    "infRecType",
    "lacresType",
    "medType",
    "obsContType",
    "obsFiscoType",
    "pagType",
    "procRefType",
    "prodType",
    "rastroType",
    "refECFType",
    "refNFPType",
    "refNFType",
    "retTranspType",
    "retTribType",
    "totalType",
    "transpType",
    "transportaType",
    "veicProdType",
    "volType"
]
