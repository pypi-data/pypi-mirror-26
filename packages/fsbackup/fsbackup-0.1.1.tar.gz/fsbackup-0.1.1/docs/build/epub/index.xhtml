<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module fsbackup, Multi-Volume Backup for Large Filesystems</title>
    
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> 
  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-fsbackup-multi-volume-backup-for-large-filesystems">
<h1>Module <code class="xref py py-mod docutils literal"><span class="pre">fsbackup</span></code>, Multi-Volume Backup for Large Filesystems</h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview</h2>
<p>A command-line script in Python is provided, to manage backups for large filesystems in multiple external disks.</p>
<p>It is intended as a minimalist system, to get the job done but with no GUI or other niceties. At least not yet!
I just wanted to sleep well at night.</p>
<div class="section" id="motivation">
<h3>Motivation</h3>
<div class="section" id="the-problem">
<h4>The Problem</h4>
<p>For more than a decade I had being gathering content and
storing it in external drives.
For backup purposes I used to buy them in pairs, so that one would work as the other&#8217;s mirror.
Of course the solution was far from ideal, there were tv-series, movies, and documentaries in most disks,
sparsed pretty much randomly, and when the number of disks reached 15 (plus backups) even finding content was a pain.
I had simple text files with the file contents of each disk, which needed to be updated, etc.</p>
</div>
<div class="section" id="an-improvement">
<h4>An Improvement</h4>
<p>A friend talked to me about a NAS he had recently acquired. After little consideration I realized I had been needing
one myself for a long time, just did not know such a thing existed. Taking into account the size of the files I already had,
plus reasonable mid-term foreseable needs, I bought a 6-slots NAS and put 8GB disks in it (5 of them currently).</p>
<p>Now the content was neatly organised, easy to find and maintain.</p>
<p>I was using RAID5, which is nice, but in several forums I found the clear warning
that <a class="reference external" href="https://serverfault.com/questions/2888/why-is-raid-not-a-backup">RAID does not work as backup</a><span class="link-target"> [https://serverfault.com/questions/2888/why-is-raid-not-a-backup]</span>, so I started worring.
I had the need of a real backup, and a bunch of external drives which content was already in the NAS.
Obviously they might be used to backup content, but I could not bring myself to even try to micro-manage it.
It would be particularly hard because some folders are way bigger that the external drives, so they would have to be split manually.</p>
</div>
</div>
<div class="section" id="backup-system-overview">
<h3>Backup System Overview</h3>
<p>The idea behind the implementation of <strong>fsbackup</strong> is pretty simple, and everything gets done by the <code class="docutils literal"><span class="pre">fsbck</span></code> command.
Given a list of one or more paths that we want backed-up, the backup system works in three stages.</p>
<div class="section" id="stage-1">
<h4>Stage 1</h4>
<p>A command (intended to be scheduled nightly) keeps a collection in a <a class="reference external" href="https://www.mongodb.com/">mongoDB</a><span class="link-target"> [https://www.mongodb.com/]</span> database updated with
the absolute path, size, last modification timestamp and a hash function (currently SHA-256) of each file in that list of paths.
They are interpreted as file-trees, so all the content buried in those paths is included.
It can be done with something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">refreshHashes</span> <span class="o">-</span><span class="n">db</span><span class="o">=</span><span class="n">conn_multimedia</span><span class="o">.</span><span class="n">json</span>
</pre></div>
</div>
<p>Only new files, or files with a more recent modification timestamp than the one in the database have their hash function recalculated
(since it is really time-consuming). As you might have guessed, the <code class="docutils literal"><span class="pre">db</span></code> argument refers
to a <a class="reference external" href="https://en.wikipedia.org/wiki/JSON">json</a><span class="link-target"> [https://en.wikipedia.org/wiki/JSON]</span> file with information regarding the location
of the filesystem, as well as mongoDB collections where the information is stored.</p>
</div>
<div class="section" id="stage-2">
<h4>Stage 2</h4>
<p>External hard disks work as backup volumes, containing files renamed with their hash function. The folder structure in the original filesystem
is not replicated, all files are at root level. Except that, using git-style, they are divided in folders according to the first
letters in the hash, to avoid having thousands of files in the same directory.</p>
<p>In order to update the backup, we can mount a disk that works as backup volume (say, it is in G:), and run:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">processDrive</span> <span class="o">-</span><span class="n">db</span><span class="o">=</span><span class="n">conn_multimedia</span><span class="o">.</span><span class="n">json</span> <span class="o">--</span><span class="n">drive</span><span class="o">=</span><span class="n">G</span>
</pre></div>
</div>
<p>This action:</p>
<ul>
<li><p class="first">Removes from the volume files that are not necessary anymore.</p>
</li>
<li><p class="first">Copies new files that were not backed-up yet.</p>
</li>
<li><p class="first">Provides a backup status report, with:</p>
<blockquote>
<div><ul class="simple">
<li>the number of files/size pending backup (if there was not enough room in that volume).</li>
<li>a summary of the number of files/size in each volume.</li>
<li>a file per volume is created with the detailed absolute paths of each file backed-up in it.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>For this to work properly, another collection in the database stores the hashes backed in each volume.</p>
</div>
<div class="section" id="stage-3">
<h4>Stage 3</h4>
<p>If/when the time comes information needs to be retrieved from the volumes, the script handles that as well. For instance, the command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">db</span><span class="o">=</span><span class="n">conn_multimedia</span><span class="o">.</span><span class="n">json</span> <span class="o">--</span><span class="n">drive</span><span class="o">=</span><span class="n">G</span> <span class="o">--</span><span class="n">sourcepath</span><span class="o">=//</span><span class="n">Zeycus</span><span class="o">/</span><span class="n">multimedia</span><span class="o">/</span><span class="n">movies</span> <span class="o">--</span><span class="n">destpath</span><span class="o">=</span><span class="n">F</span><span class="p">:</span>\<span class="n">chekouts</span>\<span class="n">movies</span>
</pre></div>
</div>
<p>recovers the relevant information in the actual (G:) volume for a particular folder. In a worst-case scenario, to recover all the files
you&#8217;d have to do this for every volume.</p>
</div>
</div>
<div class="section" id="collaboration">
<h3>Collaboration</h3>
<p>You may wish to improve or add features, in that case you are more than welcome, feel free to contact me at <a class="reference external" href="mailto:zeycus&#37;&#52;&#48;gmail&#46;com">zeycus<span>&#64;</span>gmail<span>&#46;</span>com</a>.</p>
</div>
</div>
<div class="section" id="database-structure">
<h2>Database Structure</h2>
<p>Information regarding the filesystem to be backed-up, and the current content
of volumes, is stored in a <a class="reference external" href="https://www.mongodb.com/">mongoDB</a><span class="link-target"> [https://www.mongodb.com/]</span> database.</p>
<div class="section" id="filesystem">
<h3>Filesystem</h3>
<p>The collection that stores the information about the files currently in the filesystem is (uninspiredly!) named <code class="docutils literal"><span class="pre">files</span></code>.
The entries/documents in it have the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="n">ObjectId</span><span class="p">(</span><span class="s2">&quot;59e0a71c2afc32cfc4e7fa48&quot;</span><span class="p">),</span>
<span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">ZEYCUS-TVS671\Multimedia\video\animePlex\Shin Chan\Season 01\Shin Chan - S01E613.mp4&quot;</span><span class="p">,</span>
<span class="s1">&#39;hash&#39;</span><span class="p">:</span> <span class="s2">&quot;4a7facfe42e8ff8812f9cab058bf79981974d9e2e300d56217d675ec5987cf05&quot;</span><span class="p">,</span>
<span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="mi">1197773340</span><span class="p">,</span>
<span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">68097104</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal"><span class="pre">filename</span></code> field is the absolute path of the file.</li>
<li>The <code class="docutils literal"><span class="pre">hash</span></code> field is the SHA-256 hash of the file.</li>
<li><code class="docutils literal"><span class="pre">timestamp</span></code> is the file&#8217;s last-modified timestamp.</li>
<li><code class="docutils literal"><span class="pre">size</span></code> is the size of the file in bytes, obtained with <code class="docutils literal"><span class="pre">os.stat(fn).st_mtime</span></code>.</li>
</ul>
</div></blockquote>
<p>The fields used for look-up are <code class="docutils literal"><span class="pre">filename</span></code> and <code class="docutils literal"><span class="pre">hash</span></code>, so the collection should have an index on each of them.
The one on <code class="docutils literal"><span class="pre">filename</span></code> should be have <code class="docutils literal"><span class="pre">unique=True</span></code>, to ensure no filename is added twice <a class="footnote-reference" href="#find" id="id2">[2]</a> .</p>
<p>The class that manages this collection is <a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><code class="xref py py-class docutils literal"><span class="pre">FileDB</span></code></a>.</p>
</div>
<div class="section" id="volumes">
<h3>Volumes</h3>
<p>On the other hand, the present state of backup volumes is stored in the collection <code class="docutils literal"><span class="pre">volumes</span></code>,
with entries like</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="n">ObjectId</span><span class="p">(</span><span class="s2">&quot;59e484603e12972bd4209fbe&quot;</span><span class="p">),</span>
<span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="s2">&quot;3EC0BECC&quot;</span><span class="p">,</span>
<span class="s1">&#39;hash&#39;</span><span class="p">:</span> <span class="s2">&quot;0017eef276f4247807fa3f4e565b8c925a2db0f8bfbb020248ad6c3df6a6ea77&quot;</span><span class="p">,</span>
<span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">97092</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal"><span class="pre">volume</span></code> is the volume SerialNumber.</li>
<li>The <code class="docutils literal"><span class="pre">hash</span></code> field is the SHA-256 hash of the file.</li>
<li><code class="docutils literal"><span class="pre">size</span></code> is the size of the file in bytes.</li>
</ul>
</div></blockquote>
<p>This entry is saying that volume 3EC0BECC contains a file with the given hash, and filesize 97,092 bytes.</p>
<p>There should be a a unique index on field <code class="docutils literal"><span class="pre">hash</span></code> <a class="footnote-reference" href="#f1" id="id3">[1]</a> .</p>
<p>The methods that add/remove files from a volume (see class <a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><code class="xref py py-class docutils literal"><span class="pre">HashVolume</span></code></a>)
also update this collection, so that it remains up-to-date.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>In fact, this enforces that only one volume may contain a file with a specific hash. If the backup
methods are working correctly this should be the case. If the same file is found in different
folders in the filesystem, or with different names, no space is wasted and just one copy will
be present in backup volumes.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="find" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>This is not true for <code class="docutils literal"><span class="pre">hash</span></code>, because we need to be able to backup systems that contain the same file in different locations.
I was surprised to find that I had about a 5% of file redundancy in number of files, it turned out that some tiny files were necessary in many locations.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="volume-content">
<h2>Volume Content</h2>
<p>Volumes contain backups of the files in the filesystem: files with the same content. However, they are renamed with the hash of the content.
This means that no information regarding the filename in the real filesystem, or the path where it is located, can be found in the volumes (that information is stored in the <code class="docutils literal"><span class="pre">files</span></code> collection in the database).
All the files in the volume are placed in the root of the filesystem, but classified with their first 3 letters to avoid the problems associated with having too many files in the same folder.
An actual volume looks like this:</p>
<div class="figure align-center" id="id6">
<img alt="_images/volume_screenshot.png" src="_images/volume_screenshot.png" />
<p class="caption"><span class="caption-text">Content of a backup volume.</span></p>
</div>
</div>
<div class="section" id="filesystem-config-files">
<h2>Filesystem config files</h2>
<p>The information about filesystems that we want backed-up is gathered in JSON files,
one per filesystem. For instance:</p>
<div class="highlight-json"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;connstr&quot;</span><span class="p">:</span> <span class="s2">&quot;mongodb://myuser:mypwd@ds21135.mlab.com:34562/fsbackup_tvs761_main&quot;</span><span class="p">,</span>
  <span class="nt">&quot;paths&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;\\\\ZEYCUS-TVS671\\Multimedia&quot;</span><span class="p">,</span>
    <span class="s2">&quot;\\\\ZEYCUS-TVS671\\Resources&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;reportpref&quot;</span><span class="p">:</span> <span class="s2">&quot;F:\\Dropbox\\fsbackup\\reports\\main_&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The information is as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connstr</span></code></dt>
<dd>The connection string to the mongoDB database.</dd>
<dt><code class="docutils literal"><span class="pre">paths</span></code></dt>
<dd>The list of paths in the filesystem that we want backed-up. So far I&#8217;ve been using absolute paths myself,
but I think that paths relative to the location of the config file work as well. But I have not tested
it that heavily.</dd>
<dt><code class="docutils literal"><span class="pre">reportpref</span></code></dt>
<dd>Prefix for reports. All files created by the <code class="docutils literal"><span class="pre">backupStatus</span></code> command are created with that prefix.</dd>
</dl>
</div>
<div class="section" id="detailed-command-usage">
<h2>Detailed command usage</h2>
<p>Everything works via the <code class="docutils literal"><span class="pre">fsbck</span></code> command. If the installation is correct, it should be available no matter what the active directory is.
In this section, the basic usage is shown, but the full detail and optional parameters can be found in <a class="reference internal" href="#module-fsbackup.commands" title="fsbackup.commands"><code class="xref py py-mod docutils literal"><span class="pre">commands</span></code></a> module documentation.</p>
<div class="section" id="database-creation">
<h3>Database Creation</h3>
<dl class="docutils">
<dt>It is achieved with::</dt>
<dd>fsbck.py createDatabase -db=&lt;config_file&gt;</dd>
</dl>
<p>If the database containing the two necessary collections <code class="docutils literal"><span class="pre">files</span></code> and <code class="docutils literal"><span class="pre">volumes</span></code> do not exist, they are created.
Otherwise the execution fails. If you want it rebuild, add the <code class="docutils literal"><span class="pre">--force</span></code> flag.</p>
</div>
<div class="section" id="create-reports-for-backup-status">
<h3>Create reports for backup status</h3>
<dl class="docutils">
<dt>With::</dt>
<dd>fsbck.py backupStatus -db=&lt;config_file&gt;</dd>
</dl>
<p>several text files are created (with different level of detail) regarding the status of the backup:</p>
<blockquote>
<div><ul class="simple">
<li>size and number of files in each backup volume</li>
<li>size and number of files not yet backed-up</li>
<li>size and number of files in the volumes than are no longer necessary</li>
<li>explicit list of files in each volume</li>
</ul>
</div></blockquote>
<p>An example of the files created:</p>
<div class="figure align-center" id="id7">
<img alt="_images/reportfiles_screenshot.png" src="_images/reportfiles_screenshot.png" />
<p class="caption"><span class="caption-text">Files created by <code class="docutils literal"><span class="pre">backupStatus</span></code>.</span></p>
</div>
<p>Contrary to what it might seem, this operation is fairly quick.</p>
</div>
<div class="section" id="database-files-update">
<h3>Database <code class="docutils literal"><span class="pre">files</span></code> update</h3>
<p>This command updates the database information to match the current state of the filesystem.
If files are modified their hash is recalculated, if files were removed their entries are eliminated from
the database, and new files require new entries.</p>
<p>This is achieved with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">refreshHashes</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>For large systems, the calculation of hashes is time-consuming. The first time I calculated it for my NAS it took nearly
a week. So, I prefer to perform this process dayly, in scheduled task at night, and right after it the <code class="docutils literal"><span class="pre">backupStatus</span></code> reports are regenerated.</p>
</div>
<div class="section" id="volume-update">
<h3>Volume update</h3>
<p>This is the way content gets actually backed-up. Suppose you have a volume with available space on it, or if you are going to create
a new volume, just a formated external drive. When connected, it is assigned a drive letter, say J: <a class="footnote-reference" href="#fwin" id="id4">[3]</a> . Then
to perform the update use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">updateVolume</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">drive</span><span class="o">=</span><span class="n">J</span>
</pre></div>
</div>
<p>New files are added to the volume, until it is full or all of them are processed, a text message tells which of the two.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be sure that the <code class="docutils literal"><span class="pre">files</span></code> information is updated (via command <code class="docutils literal"><span class="pre">refreshHashes</span></code>) before invoking a volume update. Otherwise, when the script tries to copy a file that the database is mentioning, it might not be physically there anymore, and thus exceptions would arise. There is no problem, however, if the only difference is that new files were created.</p>
</div>
</div>
<div class="section" id="volume-clensing">
<h3>Volume clensing</h3>
<p>When you remove files from your backed-up filesystem, copies of them remain in backup volumes. There is no harm in it,
just the waste of space. As time passes, the wasted space in volumes could amount to something. With:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">cleanVolume</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">drive</span><span class="o">=&lt;</span><span class="n">driveLetter</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>the files in the volume than are not shown as necessary by the database are removed.</p>
</div>
<div class="section" id="volume-processing">
<h3>Volume processing</h3>
<p>In the first days, when I wanted to update a volume I found myself always performing:</p>
<blockquote>
<div><ol class="arabic simple">
<li>volume clensing</li>
<li>volume update</li>
<li>backuptatus reports regeneration</li>
</ol>
</div></blockquote>
<p>I created a batch, but after a while I decided an additional command was in order to do it all: <code class="docutils literal"><span class="pre">processDrive</span></code>. With:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">processDrive</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">drive</span><span class="o">=&lt;</span><span class="n">driveLetter</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>those three tasks are performed. This keeps the volumes clean of old files, the system fully updated and the status reports
reflecting the current backup status.</p>
<p>In a day-to-day basis this is almost the only command you need (if the <code class="docutils literal"><span class="pre">refreshHashes</span></code> is taken care of by an scheduled task).
Of course, you could manually run <code class="docutils literal"><span class="pre">refreshHashes</span></code> before processing a drive, just to make sure the database is up-to-date.</p>
</div>
<div class="section" id="information-recovery-from-volumes">
<h3>Information recovery from volumes</h3>
<p>All the burden of keeping the filesystem updated has a single purpose: to be able to recover content from the backup volumes
when necessary. This operation may be infrequent, but it is arguably the most important. It is currently performed with the
<code class="docutils literal"><span class="pre">checkout</span></code> command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">updateVolume</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">drive</span><span class="o">=&lt;</span><span class="n">driveLetter</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">sourcepath</span><span class="o">=</span>\\<span class="n">ZEYCUS</span><span class="o">-</span><span class="n">TVS671</span>\<span class="n">Multimedia</span>\<span class="n">video</span>\<span class="n">seriesPlex</span>\<span class="n">Monk</span> <span class="o">--</span><span class="n">destpath</span><span class="o">=</span><span class="n">F</span><span class="p">:</span>\<span class="n">temp</span>\<span class="n">Monk</span>
</pre></div>
</div>
<p>This process finds all the files in the volume that are a backup of a file in the given <code class="docutils literal"><span class="pre">sourcepath</span></code> (or in a subfolder),
and copies them recreating the folder structure within the path <code class="docutils literal"><span class="pre">destpath</span></code>.</p>
<p>Needless to say, to recover the whole folder content you need to process all the volumes containing at least one relevant file. It is possible to see which volumes
are involved by searching the backup-status report files. Or just process them all, it takes very little time if no content is necessary.</p>
</div>
<div class="section" id="recalculation-of-volume-information">
<h3>Recalculation of Volume Information</h3>
<p>The operations that add and remove files from the volume in same time update the database.
So, theoretically, the database is always up-to-date. I have not found a single case in which this was not the case,
but nevertheless implemented:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fsbck</span><span class="o">.</span><span class="n">py</span> <span class="n">extractVolumeInfo</span> <span class="o">-</span><span class="n">db</span><span class="o">=&lt;</span><span class="n">config_file</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">drive</span><span class="o">=&lt;</span><span class="n">driveLetter</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>What this does is to remove from the <code class="docutils literal"><span class="pre">volumes</span></code> collection all the entries associated to the present volume, then
it is traversed and an entry is created for each actual file found.</p>
</div>
<div class="section" id="volume-integrity-check">
<h3>Volume Integrity Check</h3>
<dl class="docutils">
<dt>In case we want to make sure that a backup volume is OK, we can perform an integrity check with:</dt>
<dd>fsbck.py integrityCheck -db=&lt;config_file&gt; &#8211;drive=&lt;driveLetter&gt;</dd>
</dl>
<p>This is a time consuming operation that actually compares each file of the volume with its counterpart in the actual filesystem
(if it was not deleted). For 3TB disks it is taking me over a day.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is supposed to be done after a <code class="docutils literal"><span class="pre">refreshHashes</span></code>. Otherwise the information in the DDBB might not reflect the actual state of the filesystem.</p>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="fwin" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>I realize this is terribly Windows-oriented. For linux systems it would be rather similar, if/when Linux support is provided this documentation should be improved.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="observations">
<h2>Observations</h2>
<div class="section" id="volume-identification">
<h3>Volume identification</h3>
<p>Volumes are not numbered, instead they are identified by a unique identifier. For now it is their filesystem <a class="reference external" href="https://en.wikipedia.org/wiki/Volume_serial_number">volume serial number</a><span class="link-target"> [https://en.wikipedia.org/wiki/Volume_serial_number]</span>.
This means you never need to process the volumes in any order, nor when you update them.</p>
<p>For instance, suppose you remove some huge files from your filesystem (who would want to see <strong>THAT</strong> tv-show again!?). As a consequence the backupstatus report
shows that a volume contains now 300GB of removable files. You could choose this volume for your next <code class="docutils literal"><span class="pre">processDrive</span></code>: useless content will be dropped, making room and using it for fresh file backups.</p>
</div>
<div class="section" id="id5">
<h3>Volume content</h3>
<p>Files are not backed-up in any order. The system just aims to have each file backed-up in a (single) volume. This means content is more or less randomly
divided among volumes.</p>
</div>
</div>
<div class="section" id="please-be-aware">
<h2>Please, <strong>be aware</strong>!</h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">To be able to use mongoDB, we must have a connection to a mongoDB server. It could be our own machine, a hosting service, etc.</p>
</div>
<p>If you are new to mongoDB, several tutorials are available, <a class="reference external" href="https://www.hongkiat.com/blog/webdev-with-mongodb-part1/">this</a><span class="link-target"> [https://www.hongkiat.com/blog/webdev-with-mongodb-part1/]</span> is one of them. There are also many mongoDB-hosting services that provide free sandboxes with a decent size, no need to spend a dime just to experiment.</p>
<p>If you have mongoDB installed, to serve it locally (in Windows) just run:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">mongod</span><span class="o">.</span><span class="n">exe</span> <span class="o">--</span><span class="n">dbpath</span><span class="o">=&lt;</span><span class="n">database_path</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="section" id="regarding-tests">
<h3>Regarding tests</h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">To be able to run tests, we need a mongoDB server to connect to (I know of no better way. If there is, please let me know). The tests are written assuming that a local server is running.</p>
</div>
<p>Then, a client is created that connects to it, creates testing databases/collections, fills them, accesses information stored, and wipes them all in the end.</p>
</div>
<div class="section" id="information-safety">
<h3>Information safety</h3>
<p>The mongoDBs created are essential to be able to recover contents from the backup.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If they were lost, in the volumes you won&#8217;t see proper filenames or extensions. Therefore although the content is indeed there, finding what you need would be, at the very least, awefully painful, if not utterly infeasable.</p>
</div>
<p>For that reason it is reasonable to make sure the mongoDB databases are safe,
and backed-up as frequently and redundantly as possible. I am using mongoDB hosting, and keep a local copy as well. Even periodically storing a copy with its
timestamp might be interesting, if you want to play it safe.</p>
</div>
<div class="section" id="license">
<h3>License</h3>
<p>This software is released under MIT license, with no warranty implied or otherwise. That said, on the sunny side a unittest is included that performs the complete backup cycle and
makes sure that the checkout is identical to the original filesystem. And <code class="docutils literal"><span class="pre">integrityCheck</span></code> command is available, which actually compares each backed-up file with its
counterpart in the filesystem.</p>
</div>
</div>
<div class="section" id="todo">
<h2>TODO</h2>
<ol class="arabic">
<li><dl class="first docutils">
<dt>There are several aspects in this process than are very OS-dependent. For instance:</dt>
<dd><ul class="first simple">
<li>Copying files</li>
<li>The systax for absolute paths</li>
<li>Extraction of volume id</li>
</ul>
<p class="last">For now, I&#8217;ve been working on Windows, and I even had to implement at least an ugly hack (to handle +260 chars absolute paths, which
surprisingly causes problems in Windows). I wish it worked for Linux as well, at least, that is the very first thing I&#8217;d like to do.</p>
</dd>
</dl>
</li>
<li><p class="first">It seems not all filesystems have volume serialNumber. For that reason it seems that using disk serial numbers instead might be an improvement.
I chose volume serialnumbers because it was easy to extract, while the drive serial number containing a volume seemed hard to get (Googled for a while,
found no easy path).</p>
</li>
<li><p class="first">For now, the only way to retrieve information from the volumes is the <code class="docutils literal"><span class="pre">checkout</span></code> command, which rebuilds a folder/subfolder recursively. However, it would be
easy to add filters to recover only files that match a given regular expression, or filter them for timestamp or other features, etc.</p>
<p>Truth be told, this kind of operation is what I implemented for the case in which something <em>goes wrong</em>: content was deleted unwantingly, or the disk just crashed.
Fortunately those events happen pretty rarely, so little effort was dedicated to the recovery of information.</p>
</li>
<li><p class="first">If the <code class="docutils literal"><span class="pre">updateVolume</span></code> is aborted, I am not sure whether it is possible that a file could be partially written in the volume. I wonder if it could happen that, after
such event, the system thinks that file is correctly backed-up, when it is not. I should try to provoke this event and see what happens. In that case, maybe same kind
of <em>write-and-check-size</em> or something like that might be in order.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="code-documentation">
<h1>Code documentation</h1>
<div class="section" id="module-fsbackup.commands">
<span id="main-commands-module"></span><h2>Main Commands Module</h2>
<span class="target" id="module-commands"></span><dl class="function">
<dt id="fsbackup.commands.backupStatus">
<code class="descclassname">fsbackup.commands.</code><code class="descname">backupStatus</code><span class="sig-paren">(</span><em>fDB</em>, <em>volDB</em>, <em>reportPref</em><span class="sig-paren">)</span></dt>
<dd><p>Generates the status report.</p>
<dl class="docutils">
<dt>Several files are created:</dt>
<dd><ul class="first last simple">
<li>summary.txt: global summary.</li>
<li>missing.txt: list of files not yet backed-up.</li>
<li>content_&lt;vol&gt;.txt: the list of files backed-up in each volume.</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; the information regarding files</li>
<li><strong>volDB</strong> (<em>permanent-dict class</em>) &#8211; the informating regarading volumes</li>
<li><strong>reportPref</strong> (<em>str</em>) &#8211; prefix that tells where to create reporting</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.commands.extractVolumeInfo">
<code class="descclassname">fsbackup.commands.</code><code class="descname">extractVolumeInfo</code><span class="sig-paren">(</span><em>hashVol</em><span class="sig-paren">)</span></dt>
<dd><p>Regenerates the DDBB information regarding the files contained in the present volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hashVol</strong> (<a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><em>HashVolume</em></a>) &#8211; the information regarding volumes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.commands.cleanVolume">
<code class="descclassname">fsbackup.commands.</code><code class="descname">cleanVolume</code><span class="sig-paren">(</span><em>fDB</em>, <em>hashVol</em><span class="sig-paren">)</span></dt>
<dd><p>Removes files from the volume that are not necessary anymore.</p>
<p>Returns the number of deleted files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; the information regarding files</li>
<li><strong>hashVol</strong> (<a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><em>HashVolume</em></a>) &#8211; the information regarding volumes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.commands.updateVolume">
<code class="descclassname">fsbackup.commands.</code><code class="descname">updateVolume</code><span class="sig-paren">(</span><em>fDB</em>, <em>hashVol</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes useless files in the volume, and copies new files that need to be backed-up.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; the information regarding files</li>
<li><strong>hashVol</strong> (<a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><em>HashVolume</em></a>) &#8211; the information regarding volumes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.commands.refreshFileInfo">
<code class="descclassname">fsbackup.commands.</code><code class="descname">refreshFileInfo</code><span class="sig-paren">(</span><em>fDB</em>, <em>forceRecalc</em><span class="sig-paren">)</span></dt>
<dd><p>Updates the filename collection in the database, reflecting changes in the filesystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; the information regarding files</li>
<li><strong>forceRecalc</strong> (<em>bool</em>) &#8211; flag that tells if hashes &amp; timestamps should be recalculated from the file always.
If False (the default), recalculation happens always when the timestamp of the file is more recent than that
in the database, or for new files. If True, we recalculate for every file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.commands.createDatabase">
<code class="descclassname">fsbackup.commands.</code><code class="descname">createDatabase</code><span class="sig-paren">(</span><em>database</em>, <em>forceFlag</em>, <em>logger</em><span class="sig-paren">)</span></dt>
<dd><p>Creates database collections from scratch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; the information regarding files</li>
<li><strong>forceFlag</strong> (<em>bool</em>) &#8211; tells whether to remove info, if collections already exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="auxiliary-modules">
<h2>Auxiliary Modules</h2>
<div class="section" id="module-fsbackup.miscTools">
<span id="module-misctools"></span><h3>Module <a class="reference internal" href="#module-fsbackup.miscTools" title="fsbackup.miscTools"><code class="xref py py-mod docutils literal"><span class="pre">miscTools</span></code></a></h3>
<span class="target" id="module-miscTools"></span><dl class="function">
<dt id="fsbackup.miscTools.buildVolumeInfoList">
<code class="descclassname">fsbackup.miscTools.</code><code class="descname">buildVolumeInfoList</code><span class="sig-paren">(</span><em>container</em><span class="sig-paren">)</span></dt>
<dd><p>Returns, for each volume, the association {file-hash: file-size}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>container</strong> (<em>MongoAsDict</em>) &#8211; a MongoAsDict with the volume information</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of pairs (volId, {sha:size})</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-fsbackup.fileTools">
<span id="module-filetools"></span><h3>Module <a class="reference internal" href="#module-fsbackup.fileTools" title="fsbackup.fileTools"><code class="xref py py-mod docutils literal"><span class="pre">fileTools</span></code></a></h3>
<span class="target" id="module-fileTools"></span><dl class="function">
<dt id="fsbackup.fileTools.sizeof_fmt">
<code class="descclassname">fsbackup.fileTools.</code><code class="descname">sizeof_fmt</code><span class="sig-paren">(</span><em>num</em>, <em>suffix='B'</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a human-readable string for a file size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num</strong> (<em>int</em>) &#8211; size of the file, in units</li>
<li><strong>suffix</strong> (<em>str</em>) &#8211; the unit. Use &#8216;B&#8217; for bytes, the default.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
<p>Stolen from:</p>
<blockquote>
<div><a class="reference external" href="http://stackoverflow.com/questions/1094841/reusable-library-to-get-human-readable-version-of-file-size">http://stackoverflow.com/questions/1094841/reusable-library-to-get-human-readable-version-of-file-size</a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="fsbackup.fileTools.abspath2longabspath">
<code class="descclassname">fsbackup.fileTools.</code><code class="descname">abspath2longabspath</code><span class="sig-paren">(</span><em>abspath</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an absolute filepath than works for longer than 260 chars in Windows.</p>
<p>In Windows there is seems to be no support for paths longer than 260 chrs. Files that exist are not found, cannot
be open, etc. However, using this trick I seem to be able to access them.</p>
<p>Post with the trick description:</p>
<blockquote>
<div><a class="reference external" href="https://msdn.microsoft.com/en-us/library/aa365247.aspx#maxpath">https://msdn.microsoft.com/en-us/library/aa365247.aspx#maxpath</a></div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-fsbackup.diskTools">
<span id="module-disktools"></span><h3>Module <a class="reference internal" href="#module-fsbackup.diskTools" title="fsbackup.diskTools"><code class="xref py py-mod docutils literal"><span class="pre">diskTools</span></code></a></h3>
<span class="target" id="module-diskTools"></span><dl class="function">
<dt id="fsbackup.diskTools.genDrivesInfo">
<code class="descclassname">fsbackup.diskTools.</code><code class="descname">genDrivesInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Generator for drives information.</p>
</dd></dl>

<dl class="function">
<dt id="fsbackup.diskTools.genVolumesInfo">
<code class="descclassname">fsbackup.diskTools.</code><code class="descname">genVolumesInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Generator for volumes information.</p>
</dd></dl>

<dl class="function">
<dt id="fsbackup.diskTools.getVolumeInfo">
<code class="descclassname">fsbackup.diskTools.</code><code class="descname">getVolumeInfo</code><span class="sig-paren">(</span><em>driveLetter</em><span class="sig-paren">)</span></dt>
<dd><p>Returns volume info for the given driveLetter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>driveLetter</strong> (<em>str</em>) &#8211; the drive letter, for instance &#8216;C&#8217;</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fsbackup.diskTools.getAvailableLetter">
<code class="descclassname">fsbackup.diskTools.</code><code class="descname">getAvailableLetter</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the first drive letter available.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-fsbackup.hashVolume">
<span id="class-hashvolume"></span><h2>Class <a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><code class="xref py py-class docutils literal"><span class="pre">HashVolume</span></code></a></h2>
<span class="target" id="module-hashVolume"></span><dl class="class">
<dt id="fsbackup.hashVolume.HashVolume">
<em class="property">class </em><code class="descclassname">fsbackup.hashVolume.</code><code class="descname">HashVolume</code><span class="sig-paren">(</span><em>logger</em>, <em>locationPath</em>, <em>container</em>, <em>volId=None</em><span class="sig-paren">)</span></dt>
<dd><p>Class that handles a backup volume.</p>
<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.allVolumesHashes">
<code class="descname">allVolumesHashes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the set of all hashes in any volume, according to the DDBB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.augmentWithFiles">
<code class="descname">augmentWithFiles</code><span class="sig-paren">(</span><em>fDB</em><span class="sig-paren">)</span></dt>
<dd><p>Include in the volume backup for the files that need it.</p>
<p>It is done until all files are backed-up, on until the volume is full.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; filesystem information in DDBB.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">a pair (isFinished, hashList)<ul class="simple">
<li>isFinished tells whether the backup is complete. It is False if there are still
files that are not backed-up in any volume.</li>
<li>hashList is the list of hashes of the created files.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The strategy to choose which file to backup next is the following, but there are no
strong reasons for this, it should be changed if another is found better.</p>
<ul class="last simple">
<li>While there is plenty of room in the volume (threshold currently set to 20GB) and there is room
for the biggest file that requires backup, files are chosen randomly.
The reason is that usually there are folders with huge files, others with only tiny files.
If files were processed by their folder order, a volume could end up with millions
of small files, while another could contain just hundreds of heavy files. Not that it would
be a problem in principle, but I thought it might be better to balance volumes, and
a simple strategy is the random choice.</li>
<li>When the previous condition fails, choose the biggest file that fits, until none does.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.checkout">
<code class="descname">checkout</code><span class="sig-paren">(</span><em>fDB</em>, <em>sourcePath</em>, <em>destPath</em><span class="sig-paren">)</span></dt>
<dd><p>Rebuilds the filesystem, or a subfolder, from the backup content.</p>
<p>Returns a list of the filenames (in the original filesystem) that were restored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fDB</strong> (<a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><em>FileDB</em></a>) &#8211; filesystem information in DDBB.</li>
<li><strong>sourcePath</strong> (<em>str</em>) &#8211; path in the filesystem that you want restored</li>
<li><strong>destPath</strong> (<em>str</em>) &#8211; location where you want the files created</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.cleanOldHashes">
<code class="descname">cleanOldHashes</code><span class="sig-paren">(</span><em>totalHashesNeeded</em><span class="sig-paren">)</span></dt>
<dd><p>Removes files that are no longer necessary.</p>
<p>Returns the number of files removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>totalHashesNeeded</strong> (<em>set</em>) &#8211; hashes of files that need to be backed-up.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.fnForHash">
<code class="descname">fnForHash</code><span class="sig-paren">(</span><em>sha</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the absolute path of the file for a given hash.</p>
<p>The first three letters in the hash are used to create a 3-levels folder system,
for instance hash <code class="docutils literal"><span class="pre">4c07766937a4d241fafd3104426766f07c3ce9de7e577a76ad61eba512433cea</span></code>
corresponds to file</p>
<blockquote>
<div><code class="file docutils literal"><span class="pre">self.locationPath/4/c/0/4c07766937a4d241fafd3104426766f07c3ce9de7e577a76ad61eba512433cea</span></code></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sha</strong> (<em>str</em>) &#8211; any valid SHA</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.getAvailableSpace">
<code class="descname">getAvailableSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the available free space in the volume drive, in bytes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.recalculateContainer">
<code class="descname">recalculateContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Rebuilds the DDBB volume information, traversing the files in the volume.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is something ordinarily you don&#8217;t need to do, because the DDBB
is kept synchronized with the files in the volume. This method is to be used
in case for some reason the synchronization was broken.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>sha</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes the file with a given hash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sha</strong> (<em>str</em>) &#8211; the given hash</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.retrieveFilename">
<code class="descname">retrieveFilename</code><span class="sig-paren">(</span><em>sha</em>, <em>filename</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts a file from the volume, given its hash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sha</strong> (<em>str</em>) &#8211; the given hash</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename of the file to be created</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.storeFilename">
<code class="descname">storeFilename</code><span class="sig-paren">(</span><em>filename</em>, <em>size</em>, <em>sha=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a file in the volume.</p>
<p>The filename in the volume is the sha, not the original filename.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; location of the original file</li>
<li><strong>size</strong> (<em>int</em>) &#8211; size in bytes of the original file</li>
<li><strong>sha</strong> &#8211; the hash for the file. If not provided, it is calculated now</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.hashVolume.HashVolume.traverseFiles">
<code class="descname">traverseFiles</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Iterator over pairs (hash, size) for the present volume, checking which actual files are stored in it.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-fsbackup.fileDB">
<span id="class-filedb"></span><h2>Class <a class="reference internal" href="#fsbackup.fileDB.FileDB" title="fsbackup.fileDB.FileDB"><code class="xref py py-class docutils literal"><span class="pre">FileDB</span></code></a></h2>
<span class="target" id="module-fileDB"></span><dl class="class">
<dt id="fsbackup.fileDB.FileDB">
<em class="property">class </em><code class="descclassname">fsbackup.fileDB.</code><code class="descname">FileDB</code><span class="sig-paren">(</span><em>logger</em>, <em>fsPaths</em>, <em>container</em><span class="sig-paren">)</span></dt>
<dd><p>Class that handles the DDBB filesystem information.</p>
<p>Specifically, which files need to be backed-up, their location, size and hash.</p>
<dl class="method">
<dt id="fsbackup.fileDB.FileDB.checkout">
<code class="descname">checkout</code><span class="sig-paren">(</span><em>vol</em>, <em>sourcePath</em>, <em>destPath</em><span class="sig-paren">)</span></dt>
<dd><p>Rebuilds the filesystem, or a subfolder, from the backup content.</p>
<p>We just invoke the chekout method of the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vol</strong> (<a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><em>HashVolume</em></a>) &#8211; the volume from which information is to be restored.</li>
<li><strong>sourcePath</strong> (<em>str</em>) &#8211; path in the filesystem that you want restored</li>
<li><strong>destPath</strong> (<em>str</em>) &#8211; location where you want the files created</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.fileDB.FileDB.hashesSet">
<code class="descname">hashesSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the set of hashes in the DDBB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.fileDB.FileDB.reportStatusToFile">
<code class="descname">reportStatusToFile</code><span class="sig-paren">(</span><em>volHashesInfo</em>, <em>fnBase</em><span class="sig-paren">)</span></dt>
<dd><p>Creates backup-status report files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>volHashesInfo</strong> (<em>dict {vol: {hash: size}}</em>) &#8211; for each volume, associates the hash of each file with its size.</li>
<li><strong>fnBase</strong> (<em>str</em>) &#8211; prefix of the report files to be created</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.fileDB.FileDB.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>forceRecalc=False</em><span class="sig-paren">)</span></dt>
<dd><p>Updates the DDBB info traversing the actual filesystem.</p>
<p>After execution, the DDBB reflects exactly the files currently in the filesystem,
with their correct hash and size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>forceRecalc</strong> (<em>bool</em>) &#8211; flag that tells if hashes &amp; timestamps should be recalculated from the file always.
If <code class="docutils literal"><span class="pre">False</span></code> (the default), recalculation happens only when the timestamp of the file is more recent than that
in the database, or for new files. If <code class="docutils literal"><span class="pre">True</span></code>, recalculation takes place for every file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="fsbackup.fileDB.FileDB.volumeIntegrityCheck">
<code class="descname">volumeIntegrityCheck</code><span class="sig-paren">(</span><em>vol</em><span class="sig-paren">)</span></dt>
<dd><p>Performs a volume integrity check.</p>
<p>for each file that according to the DDBB is in this volume, a full comparison
is performed between the file in the filesystem and the file in the backup volume.
Of course, only when the file exists yet in the filesystem.</p>
<p>A final report with errors is generated, a list of errors returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vol</strong> (<a class="reference internal" href="#fsbackup.hashVolume.HashVolume" title="fsbackup.hashVolume.HashVolume"><em>HashVolume</em></a>) &#8211; the volume from which information is to be restored.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-fsbackup.mountPathInDrive">
<span id="class-mountpathindrive"></span><h2>Class <a class="reference internal" href="#fsbackup.mountPathInDrive.MountPathInDrive" title="fsbackup.mountPathInDrive.MountPathInDrive"><code class="xref py py-class docutils literal"><span class="pre">MountPathInDrive</span></code></a></h2>
<span class="target" id="module-mountPathInDrive"></span><dl class="class">
<dt id="fsbackup.mountPathInDrive.MountPathInDrive">
<em class="property">class </em><code class="descclassname">fsbackup.mountPathInDrive.</code><code class="descname">MountPathInDrive</code><span class="sig-paren">(</span><em>path</em>, <em>driveLetter</em><span class="sig-paren">)</span></dt>
<dd><p>Simple context manager for temporaly mounting a path in a Windows drive.</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">MountPathInDrive</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;F:\sources&quot;</span><span class="p">,</span> <span class="n">driveLetter</span><span class="o">=</span><span class="s1">&#39;J&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;J:&quot;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables</h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.xhtml"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.xhtml"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.xhtml"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>