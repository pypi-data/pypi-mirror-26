#!/usr/bin/env python

import json
import sys
import time
import traceback
import requests
import re

from argparse import ArgumentParser
from urlparse import urljoin
from socket import socket, AF_INET, SOCK_STREAM
from subprocess import check_output, Popen, PIPE, STDOUT


defaulttimeout = 4 # In seconds.
# NB: Version is duplicated in setup.py.
useragent = 'sous-sensu-checks/0.0.13'

# TODO: Alert us on unalertable sous projects due to missing fields etc.
# TODO: Alert when sensu team names are unrecognised.

def intOrDefault(i, d):
    if i == None:
        return d
    return i

class Check(object):

    def __init__(self, deployment, cluster, occurences):

        # Assume valid unless we say so later.
        self.valid = True

        env = deployment['Env']
        sourceID = deployment.get("SourceID")
        self.manifestID = sourceID.get("Location")
        if self.manifestID == "":
            self.setInvalid()
        flavor = deployment.get("Flavor") or ""
        if flavor != "":
            self.manifestID += ":" + flavor

        # The cluster could be read from the deployments OT_ENV var, but taking it from
        # args (see Main.run) as that's more explicit, and means we depend only on explicit
        # config in mnanifests, rather than inherited config from the env defs in Sous.
        self.Cluster = cluster

        # Disco init URL is read from deployments but is typically inherited, and thus
        # absent from manifests. We should keep an eye on this and ensure we continue to
        # depend on full Sous deployments rather than manifests.
        self.DiscoInitURL = env.get('OT_DISCO_INIT_URL') or self.setInvalid("Missing OT_DISCO_INIT_URL")
        # Prefix with http:// if not already.
        if not self.DiscoInitURL.startswith("http://") and not self.DiscoInitURL.startswith("https://"):
            self.DiscoInitURL = "http://" + self.DiscoInitURL

        # Read from general deployment fields.
        #
        self.NumInstances = deployment['NumInstances']
        if self.NumInstances == None:
            self.NumInstances = self.setInvalid("Missing NumInstances")

        # If None, do not set -e flag on otpl-service-check call.
        self.HealthcheckEndpoint = env.get("OT_AUTOCHECK_HEALTH_ENDPOINT") or deployment['Startup']['CheckReadyURIPath']

        # If None, do not set -t flag on otpl-service-check call.
        self.HealthcheckTimeout = intOrDefault(env.get("OT_AUTOCHECK_HEALTH_TIMEOUT"), deployment['Startup']['CheckReadyURITimeout'])

        self.CriticalBelowNumInstances = intOrDefault(env.get("OT_AUTOCHECK_NUMINSTANCES_CRITICAL_BELOW"), deployment['NumInstances'])

        self.WarningBelowNumInstances = intOrDefault(env.get("OT_AUTOCHECK_NUMINSTANCES_WARNING_BELOW"), self.CriticalBelowNumInstances)

        pagingDisabled = env.get("OT_AUTOCHECK_PAGING_DISABLED") or "NO"
        self.PagingDisabled = re.match(r'(yes)|(true)', pagingDisabled, flags=re.IGNORECASE)

        # Read from env vars expected to be explicitly set in the manifest.
        #
        # Right now SERVICE_TYPE this is the only required env var.
        self.AnnounceName = env.get('SERVICE_TYPE') or self.setInvalid("Missing SERVICE_TYPE")
        # Default sensu team to be revisited.
        self.SensuTeam = env.get('OT_AUTOCHECK_SENSU_TEAM') or "alert_testing"
        # Default runbook, but should be enforced.
        self.AutocheckRunbookURL = env.get("OT_AUTOCHECK_RUNBOOK") or "https://wiki.otcorp.opentable.com/display/DCNetOps/Runbooks"
        self.AutoCheckTimeout = intOrDefault(env.get("OT_AUTOCHECK_TIMEOUT_SECONDS"), 30)

        self.Occurences = occurences

    def command_args(self):
        flags = [
            "-s", self.AnnounceName,
            "-d", self.DiscoInitURL,
        ]

        if not self.CriticalBelowNumInstances == None:
            flags = flags + ["-c", str(self.CriticalBelowNumInstances)]
        if not self.WarningBelowNumInstances == None:
            flags = flags + ["-w", str(self.WarningBelowNumInstances)]
        if not self.HealthcheckEndpoint == None:
            flags = flags + ["-e", self.HealthcheckEndpoint]

        if not self.HealthcheckTimeout == None:
            flags = flags + ["-t", str(self.HealthcheckTimeout)]

        return flags

    def command(self, binPath):
        return [binPath] + self.command_args()

    # __repr__ is a standard Python method to define the string representation of something,
    # in this case its JSON representation.
    def __repr__(self):
        return json.dumps(self.json(), indent=4, sort_keys=True)

    # setInvalid marks this check as invalid and returns a string meant to convey
    # that information is undefined.
    def setInvalid(self, reason):
        self.valid = False
        self.invalidReason = reason
        return "<undefined>"

    def checkName(self):
        name = "{0.AnnounceName}_sous_autocheck_num_announced_instances".format(self)
        return name.replace(" ", "-")

    def clientName(self):
        return "{0.AnnounceName}-{0.Cluster}".format(self)

    # result returns a json serialisable map of the results of running
    # this check. (It runs the check command in a shell. TODO: Run the check
    # command more securely.)
    def result(self, binPath, interval):
        command = self.command(binPath)
        print "Running {0}".format(" ".join(command))
        cmd = Popen(command, stderr=STDOUT, stdout=PIPE)
        startTime = time.time()
        output = cmd.communicate()
        endTime = time.time()
        stdout = output[0]
        exitCode = cmd.returncode
        refresh = self.Occurences * interval

        return {
            # Result-specific fields.
            "name": self.checkName(),
            "status": exitCode,
            "output": stdout,
            "issued": int(startTime),
            "executed": int(startTime),
            "duration": "{0:.3f}".format(endTime - startTime),

            # General check fields.
            "source": self.clientName(),
            "command": " ".join(command),
            "team": self.SensuTeam,
            "runbook": self.AutocheckRunbookURL,
            "page": not self.PagingDisabled,
            "timeout": self.AutoCheckTimeout,
            "interval": interval,
            "region": self.Cluster,
            "occurences": self.Occurences,
            "refresh": refresh,

            # User agent.
            "sousSensuChecksVersion": useragent
        }


class Main(object):
  # Parse arguments.
  def __init__(self):
    self.parser = ArgumentParser(
      description='Check health of Sous-deployed services.')

    self.parser.add_argument('-s', '--server', default=None,
      help='Sous server URL')

    self.parser.add_argument('-c', '--cluster', default=None,
      help='Sous logical cluster to inspect')

    self.parser.add_argument('-i', '--interval', type=int, default=150,
      help='Interval between beginning a cycle in seconds; note that if a single run '
        'exceeds this interval, the actual interval will be longer; default 150')

    self.parser.add_argument('-a', '--alert-after', type=int, default=3,
      help='Alert after this many failures (maps to "occurences" field)')

    args = self.parser.parse_args()

    # We do this manually here since the argparse default is to exit
    # with code 2.  See parser_error.
    if args.server is None:
      self.parser_error('argument -s/--server is required')
    if args.cluster is None:
      self.parser_error('argument -c/--cluster is required')

    self.args = args

    # track output we've already seen and remove dupes
    self.response_data_seen = set()

  def parser_error(self, message):
    # Code 3 is "UNKNOWN".  (argparse default is 2, which would be
    # "CRITICAL"--inappropriate.)
    self.parser.print_usage()
    self.parser.exit(3, '%s: error: %s\n' % (self.parser.prog, message))

  def requestsget(self, url, timeout):
    return requests.get(url, timeout=timeout, headers={'User-Agent':useragent})

  # Get deployments matching the specified cluster from the specified sous server.
  def get_deployments(self):
    url = urljoin(self.args.server, 'gdm')
    resp = self.requestsget(url, defaulttimeout)
    gdm = resp.json()
    deployments = [d for d in gdm['Deployments'] if d['Env']['OT_ENV'] == self.args.cluster]
    return deployments

  def make_checks(self):
    deployments = self.get_deployments()
    checks = [Check(d, self.args.cluster, self.args.alert_after) for d in deployments]
    return checks

  def run(self):
      print useragent
      interval = self.args.interval
      while True:
        cycle_start_time = time.time()
        self.cycle(interval)
        cycle_end_time = time.time()
        cycle_elapsed_time = cycle_end_time - cycle_start_time
        if cycle_elapsed_time > interval:
          print "WARNING: Cycle took {0}s, longer than specified interval ({1}s).".format(cycle_elapsed_time, interval)
        sleep_time = interval - cycle_elapsed_time
        if sleep_time < 0:
            sleep_time = 0
        print "Running again in {0}s".format(sleep_time)
        time.sleep(sleep_time)


  # cycle performs checks for an entire Sous cluster, once.
  def cycle(self, interval):
    try:
      checks = self.make_checks()
    except Exception:
      print 'failed to generate checks'
      print traceback.format_exc()
      return 3

    exitCode = 0
    invalidChecks = {c.manifestID: c for c in checks if not c.valid}
    for manifestID, c in invalidChecks.iteritems():
        exitCode = 1
        sys.stderr.writelines("unable to check {0}: {1}\n".format(manifestID, c.invalidReason))
    validChecks = [c for c in checks if c.valid]

    binPath = check_output(["which", "otpl-service-check"]).strip()
    if binPath == "":
        print "unable to locate otpl-service-check binary, exiting."
        sys.exit(1)

    print "using {0}".format(binPath)

    results = [c.result(binPath, interval) for c in validChecks]
    for r in results:
        j = json.dumps(r, indent=4, sort_keys=True)
        print "Sending " + j
        try:
            s = socket(AF_INET, SOCK_STREAM)
            s.connect(("localhost", 3030))
            s.sendall(j)
            s.close()
        except Exception, error:
            print "Error sending check result: {0}".format(error)


try:
  sys.exit(Main().run())
except Exception:
  print 'unhandled exception'
  print traceback.format_exc()
  sys.exit(3)
