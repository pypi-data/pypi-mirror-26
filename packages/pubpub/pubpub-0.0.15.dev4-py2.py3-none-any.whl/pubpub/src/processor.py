import os
import shutil
import logging
import re
import io
import nbformat
from bs4 import BeautifulSoup
from subprocess import Popen, PIPE, check_call, check_output
from .data import read_html, compiled_scss, empty_notebook_path
from .utils import get_working_directory, markdown_instance, preserve_cwd
from .create_tplx import create_tplx

LOCAL_IMAGES = re.compile('^\.\.\/assets')


class Processor():
  def __init__(self, **opts):
    logger = logging.getLogger('root')

    output = opts.get('output', '/tmp/output.pdf')

    # Setup build dir
    # output = kwargs.get('output', '/tmp/output.pdf')
    self.output = output
    self.output_basename = os.path.join(
        os.path.dirname(output), os.path.basename(output).split(".")[0])

    self.build_dir = os.path.join(
        os.path.dirname(os.path.realpath(output)), 'build_dir/')

    self.title = opts.get('title', 'Some title')
    self.virtualenv_name = opts.get('virtualenv')
    self.base_dir = opts.get('base_dir', self.build_dir)
    self.working_directory = get_working_directory(
        opts.get('working_directory'), self.base_dir)
    self.template = opts.get('template')
    self.authors = opts.get('authors', [])
    self.asset_files = opts.get('asset_files', [])
    files = opts.get('files', [])

    logger.debug("""
    Book: {}
    Virtualenv: {}
    Authors: {}
    Template: {}
    ---

    Working directory: {}
    Build directory: {}
    Files: {}
    """.format(self.title, self.virtualenv_name, self.authors, self.template,
               self.build_dir, self.working_directory, files))

    self.files = []
    for i, filename in enumerate(files):
      self.files.append(
          get_working_directory(filename, self.working_directory))

    logger.info("Files: {}".format(self.files))

    self.opts = opts

  def create_template(self):
    doc_dict = {
        'abstract':
        r"""
\pagenumbering{roman}

\tableofcontents

\clearpage
\pagenumbering{arabic}
        """,
        'docclass':
        r"""
\usepackage{titlesec}
\usepackage{titletoc}
\renewcommand\thesection{\arabic{section}}
\titlecontents{chapter}[1.05em]{\bigskip}%
{\contentslabel[\MakeUppercase{\romannumeral\thecontentslabel}]{1em}\enspace\textsc}%numbered\contentslabel
{\hspace*{-1em}\textsc}%numberless
{\hfill\contentspage}%
%
\titlecontents{section}[1.6em]{\smallskip}%
{\thecontentslabel.\enspace}%numbered
{}%numberless
{\titlerule*[1pc]{.}\contentspage}%

\setcounter{tocdepth}{2}

\usepackage{lipsum}
      """
    }
    doc_dict.update(**self.opts)
    template = create_tplx(doc_dict)
    output = get_working_directory(self.output, self.working_directory)
    with open(output, 'w') as f:
      f.write(template)
    return template

  def to_latex(self):
    self.make_dir()

    output_files = []
    for i, file in enumerate(self.files):
      output_filename = self.process_notebook_notebooks(file, i, **self.opts)

      output_files.append(output_filename)

    self.copied_assets = self.copy_assets()
    merged_notebook = self.merge_notebooks(output_files)
    latex_filename = self.build_dir + 'complete.tex'
    output_tex = self.run_to_latex(merged_notebook, latex_filename)

    self.run_pdflatex(latex_filename, self.output)
    self.cleanup()
    return output_tex
    # contents = []
    # for file in output_files:
    #   with open(file, 'r') as f:
    #     c = f.read()
    #     contents.append(c)

    # complete_filename = os.path.join(self.build_dir, "complete.tex")
    # with open(complete_filename, "w") as f:
    # f.write(' '.join(contents))

    # output_filename = self.output
    # self.run_pdflatex(complete_filename, output_filename)

  def to_html(self):
    self.make_dir()

    # Get the headers generated by nbconvert on an empty notebook
    header = self.get_header()
    headers = "".join([str(item) for item in header.findChildren()])

    output_files = []
    output_content = []
    for i, file in enumerate(self.files):
      (html_filename, output) = self.process_notebook_html(
          file, i, **self.opts)

      output_files.append(html_filename)
      output_content.append(output)

    (toc_filename, toc) = self.add_toc(output_content)
    all_content = [toc] + output_content

    opts = self.opts.copy()

    opts['head'] = headers

    body_content = []
    # for i, c in enumerate(all_content):
    #   print(i)
    # content = '<div id="chapter{}" class="chapter">{}</div>'.format(i, c)
    # print(content)
    # body_content.append(content)
    body_content = ''.join('<div id="id{}" class="chapter">{}</div>'.format(
        i, c) for i, c in enumerate(all_content))
    opts['body'] = ''.join(body_content)
    body = read_html(**opts)

    complete_filename = os.path.join(self.build_dir, "complete.html")
    with open(complete_filename, "w") as f:
      f.write(body)

  def process_notebook_html(self, filename, i=0, **opts):
    basename = str(i).zfill(2)
    pynb_filename = self.build_dir + basename + '.ipynb'
    html_filename = self.build_dir + basename + '.html'
    # md_filename = self.build_dir + basename + '.md'
    # pdf_filename = self.build_dir + basename + '.pdf'
    # latex_filename = self.build_dir + basename + '.tex'

    self.run_to_notebook(filename, pynb_filename)
    self.run_to_html(pynb_filename, html_filename)
    body = self.format_html(html_filename, opts)
    # self.run_to_latex(pynb_filename, latex_filename)
    # self.run_latex_to_markdown(latex_filename, md_filename)
    # self.run_latex_to_pdf(latex_filename, pdf_filename)
    # self.run_to_markdown(pynb_filename, md_filename)

    self.copy_image_assets(body,
                           os.path.dirname(filename),
                           os.path.dirname(html_filename))

    self.update_styles()

    soup = BeautifulSoup(body, "lxml")
    body = soup.find("body")

    with open(html_filename, 'w') as f:
      contents = "".join(str(item) for item in body.contents)
      f.write(contents)

      return (html_filename, contents)

  def process_notebook_notebooks(self, filename, i=0, **opts):
    basename = str(i).zfill(2)
    pynb_filename = self.build_dir + basename + '.ipynb'
    # latex_filename = self.build_dir + basename + '.tex'
    # self.run_to_latex(pynb_filename, latex_filename)

    self.run_to_notebook(filename, pynb_filename)

    return pynb_filename

  def merge_notebooks(self, chapters):
    '''Merge all the chapters together'''
    merged = None
    for filename in chapters:
      if filename == self.output:
        continue

      with io.open(filename, 'r', encoding='utf-8') as f:
        nb = nbformat.read(f, as_version=4)

      if merged is None:
        merged = nb
      else:
        merged.cells.extend(nb.cells)

    if not hasattr(merged.metadata, 'name'):
      merged.metadata.name = ''

    merged.metadata.name += "_merged"

    output_filename = self.build_dir + "output-merged.ipynb"
    with open(output_filename, 'w') as f:
      f.write(nbformat.writes(merged))
    return output_filename

  @preserve_cwd
  def run_pdflatex(self, filename, output_filename):
    output_dir = os.path.dirname(output_filename)
    args = [
        'pdflatex',
        '-output-directory=%s' % output_dir, '-syntex=1',
        '-interaction=nonstopmode',
        '\"%s\"' % filename
    ]

    self.copied_assets = self.copy_assets()
    os.chdir(self.build_dir)
    return self.execute_in_virtualenv(args)

  def update_styles(self):
    with open(self.build_dir + "custom.css", "w") as f:
      f.write(compiled_scss())

  def add_toc(self, html_content=None):
    if html_content is None:
      html_content = self.read_html_files()
    toc_filename = self.build_dir + "toc.html"
    output = []
    toc = ['<div class="table-of-contents contents">', '<ol>']

    for i, content in enumerate(html_content):
      toc.append('<li class="level-0">')
      soup = BeautifulSoup(content, "lxml")
      headers = soup.find_all(re.compile('^h[%d-3]' % 1))

      first_header = headers[0]
      headers = headers[1:-1]
      toc.append(first_header.text)
      toc.append('<ol>')
      for header in headers:
        hid = header.get('id')
        text = header.text
        level = int(header.name[-1]) - 1
        if hid:
          # chapter_toc[level].append((hid, text))
          toc.append('<li class="level-%d"><a href="#%s">%s</a></li>' %
                     (level, hid, text))
      toc.append("</ol></li>")

    toc.append("</div>")
    toc = "".join(toc)
    with open(toc_filename, "w") as f:
      f.write(toc)
    return (toc_filename, toc)

  def read_html_files(self):
    output_content = []
    for i, file in enumerate(self.files):
      basename = str(i).zfill(2)
      html_filename = self.build_dir + basename + '.html'
      with open(html_filename, "r") as f:
        output_content.append(f.read())
      # output_content.append(output)

    return output_content

  @preserve_cwd
  def get_header(self):
    output_filename = self.build_dir + "empty.html"
    self.run_to_html(empty_notebook_path(), output_filename)
    with open(output_filename, "r") as f:
      soup = BeautifulSoup(f.read(), "lxml")
      header = soup.find("head")
      # os.unlink(output_filename)
      return header

  @preserve_cwd
  def run_to_html(self, processed_file, output_filename):
    args = [
        'jupyter', 'nbconvert', '--to', 'html', '--output', output_filename
    ]

    if self.template is not None:
      args.append('--template %s' % self.template)

    args.append("\"%s\"" % processed_file)

    os.chdir(self.working_directory)
    return self.execute_in_virtualenv(args)

  def format_html(self, html_filename, opts):
    with open(html_filename, 'r') as f:
      body = f.read()
      # opts['body'] = body
      return body
    # html = read_html(**opts)

  @preserve_cwd
  def run_to_notebook(self, processed_file, output_filename):
    args = [
        'jupyter', 'nbconvert', '--to', 'notebook', '--execute', '--output',
        output_filename,
        "\"%s\"" % processed_file
    ]

    os.chdir(self.working_directory)

    logging.getLogger('root').debug('executing: {}'.format(' '.join(args)))
    return self.execute_in_virtualenv(args)

  @preserve_cwd
  def run_to_markdown(self, processed_file, output_filename):
    args = [
        'jupyter', 'nbconvert', '--to', 'markdown', '--template',
        self.template, '--output', output_filename,
        "\"%s\"" % processed_file
    ]

    os.chdir(self.working_directory)
    return self.execute_in_virtualenv(args)

  @preserve_cwd
  def run_to_latex(self, processed_file, output_filename):
    args = [
        'jupyter',
        'nbconvert',
        '--to',
        'latex',
        '--output',
        output_filename,
    ]

    if self.template is not None:
      args.append('--template %s' % self.template)

    args.append("\"%s\"" % processed_file)

    os.chdir(self.working_directory)
    return self.execute_in_virtualenv(args)

  @preserve_cwd
  def run_latex_to_pdf(self, processed_file, output_filename):
    args = [
        'pandoc', '-N', '--template=' + self.template, '--variable',
        'mainfont="Palatino"', '--variable', 'sansfont="Helvetica"',
        '--variable', 'monofont="Menlo"', '--variable', 'fontsize=12pt',
        '--variable', 'version=2.0', processed_file, '--from', 'latex',
        '--listings', '--toc', '-o', output_filename
    # pandoc example.md -o example.pdf --from markdown --template eisvogel --listings
    ]

    os.chdir(self.working_directory)
    return self.execute_in_virtualenv(args)

  def find_images_to_copy(self, html_body):
    markdown_images = []
    soup = BeautifulSoup(html_body, "lxml")
    for img in soup.find_all("img"):
      if not img.attrs.get('src', '').startswith('data:'):
        markdown_images.append(img.get('src'))
    return markdown_images

  def copy_images_assets(self, md_filename, src_file, dest_dir):
    assets = self.find_images_to_copy(md_filename)
    for file in assets:
      dest = os.path.join(dest_dir,
                          os.path.dirname(file), os.path.basename(file))

      src = get_working_directory(os.path.join(src_file, file), self.build_dir)

      self.make_dir(os.path.dirname(dest))
      # print(src, dest)
      logging.getLogger('root').info('Copying {} to {}'.format(src, dest))
      shutil.copyfile(src, dest)

  def copy_assets(self):
    """Copy assets"""
    copied_assets = []
    for file in self.asset_files:
      split = file.split(':')
      if len(split) == 2:
        (file, tofile) = split
      else:
        (file, tofile) = (file, file)

      filepath = os.path.abspath(os.path.join(self.base_dir, file))
      tofilepath = os.path.join(self.build_dir, tofile)
      logging.getLogger('root').info(("Copying %s to %s" % (filepath,
                                                            tofilepath)))
      if tofilepath is not None and os.path.exists(tofilepath):
        shutil.rmtree(tofilepath)
      shutil.copytree(filepath, tofilepath)
      copied_assets.append(tofilepath)
    return copied_assets

  def execute_in_virtualenv(self, args):
    '''Execute Python code in a virtualenv, return its stdout and stderr.'''
    command = '/bin/bash'
    process = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True)

    if self.virtualenv_name is not None:
      args = ['source', 'activate', self.virtualenv_name, '&&'] + args
    else:
      args = args

    args = ' '.join(args)
    (output, err) = process.communicate(args.encode('utf-8'))
    resp = process.wait()

    if resp != 0:
      print("There was an error")
      print(args.encode('utf-8'))
      print(output)
      print(err)

    return output

  def make_dir(self, directory=None):
    '''Make the required directories'''
    if directory is None:
      directory = self.build_dir
    if not os.path.exists(directory):
      logging.debug("Creating build_dir: %s" % directory)
      os.makedirs(directory)

  def cleanup(self):
    '''remove the temporary file'''
    # Cleanup assets
    if self.copied_assets is not None:
      for file in self.copied_assets:
        if file is not None and file != '/':
          shutil.rmtree(file)
    # Cleanup build_dir
    if self.build_dir is not None and self.build_dir is not '' and self.build_dir is not '/':
      logging.debug("Cleaning up build dir: %s" % self.build_dir)
      shutil.rmtree(self.build_dir)

  def write_to_tempfile(self, content):
    '''Write the merged notebook to a tempfile'''
    f = tempfile.NamedTemporaryFile(delete=False, dir=os.getcwd())
    f.write(content.encode('utf-8'))
    f.close()
    self.tempfile = f
    return f
