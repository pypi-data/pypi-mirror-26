
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>trees &#8212; tt 0.6.3 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="transformations" href="transformations.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tt.trees">
<span id="trees"></span><h1><code class="docutils literal"><span class="pre">trees</span></code><a class="headerlink" href="#module-tt.trees" title="Permalink to this headline">¶</a></h1>
<p>Tools for working with Boolean expression trees.</p>
<p>It should be noted that virtually all of the functionality within this module
is presented with an easier-to-use interface in the <a class="reference internal" href="expressions.html#module-tt.expressions" title="tt.expressions"><code class="xref py py-mod docutils literal"><span class="pre">expressions</span></code></a> module.</p>
<div class="section" id="module-tt.trees.tree_node">
<span id="trees-tree-node-module"></span><h2><code class="docutils literal"><span class="pre">trees.tree_node</span></code> module<a class="headerlink" href="#module-tt.trees.tree_node" title="Permalink to this headline">¶</a></h2>
<p>A node, and related classes, for use in expression trees.</p>
<dl class="class">
<dt id="tt.trees.tree_node.BinaryOperatorExpressionTreeNode">
<em class="property">class </em><code class="descclassname">tt.trees.tree_node.</code><code class="descname">BinaryOperatorExpressionTreeNode</code><span class="sig-paren">(</span><em>operator_str</em>, <em>l_child</em>, <em>r_child</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#BinaryOperatorExpressionTreeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.BinaryOperatorExpressionTreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">tt.trees.tree_node.ExpressionTreeNode</span></code></a></p>
<p>An expression tree node for binary operators.</p>
<dl class="attribute">
<dt id="tt.trees.tree_node.BinaryOperatorExpressionTreeNode.operator">
<code class="descname">operator</code><a class="headerlink" href="#tt.trees.tree_node.BinaryOperatorExpressionTreeNode.operator" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual operator object wrapped in this node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference internal" href="definitions.html#tt.definitions.operators.BooleanOperator" title="tt.definitions.operators.BooleanOperator"><code class="xref py py-class docutils literal"><span class="pre">BooleanOperator</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tt.trees.tree_node.ExpressionTreeNode">
<em class="property">class </em><code class="descclassname">tt.trees.tree_node.</code><code class="descname">ExpressionTreeNode</code><span class="sig-paren">(</span><em>symbol_name</em>, <em>l_child=None</em>, <em>r_child=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A base class for expression tree nodes.</p>
<p>This class is extended within tt and is not meant to be used
directly.</p>
<p>If you plan to extend it, note that descendants of this class
must compute the <code class="docutils literal"><span class="pre">_is_cnf</span></code>, <code class="docutils literal"><span class="pre">_is_dnf</span></code>, and <code class="docutils literal"><span class="pre">_is_really_unary</span></code> boolean
attributes and the <code class="docutils literal"><span class="pre">_non_negated_symbol_set</span></code> and <code class="docutils literal"><span class="pre">_negated_symbol_set</span></code>
set attributes within their initialization. Additionally, descendants of
this class must implemented the <code class="docutils literal"><span class="pre">__eq__</span></code> magic method (but not
<code class="docutils literal"><span class="pre">__ne__</span></code>) as well as the private <code class="docutils literal"><span class="pre">_copy</span></code> transformation.</p>
<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.apply_de_morgans">
<code class="descname">apply_de_morgans</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.apply_de_morgans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.apply_de_morgans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, with De Morgan’s Law applied.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all negated AND and OR operators
transformed, following De Morgan’s Law.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.apply_idempotent_law">
<code class="descname">apply_idempotent_law</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.apply_idempotent_law"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.apply_idempotent_law" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a transformed node, with the Idempotent Law applied.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with the Idempotent Law applied to
<em>AND</em> and <em>OR</em> operators.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
<p>This transformation will apply the Idempotent Law to <em>AND</em> and <em>OR</em>
expressions involving repeated operands. Here are a few examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A and A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_idempotent_law</span><span class="p">())</span>
<span class="go">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;~B or ~~~B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_idempotent_law</span><span class="p">())</span>
<span class="go">~</span>
<span class="go">`----B</span>
</pre></div>
</div>
<p>In the latter of the two above examples, we see that this
transformation will compare operands with negations condensed. This
transformation will also prune redundant operands from CNF and DNF
clauses. Let’s take a look:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A and B and B and C and ~C and ~~C and D&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_idempotent_law</span><span class="p">())</span>
<span class="go">and</span>
<span class="go">`----and</span>
<span class="go">|    `----and</span>
<span class="go">|    |    `----and</span>
<span class="go">|    |    |    `----A</span>
<span class="go">|    |    |    `----B</span>
<span class="go">|    |    `----C</span>
<span class="go">|    `----~</span>
<span class="go">|         `----C</span>
<span class="go">`----D</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.apply_identity_law">
<code class="descname">apply_identity_law</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.apply_identity_law"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.apply_identity_law" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, with the Identity Law applied.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<p>This transformation will achieve the following effects by applying the
Inverse Law to the <em>AND</em> and <em>OR</em> operators:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A and 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_identity_law</span><span class="p">())</span>
<span class="go">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;0 or B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_identity_law</span><span class="p">())</span>
<span class="go">B</span>
</pre></div>
</div>
<p>It should also be noted that this transformation will also apply
the annihilator properties of the logical <em>AND</em> and <em>OR</em> operators. For
example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A and 0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_identity_law</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;1 or B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_identity_law</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with AND and OR identities
simplified.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.apply_inverse_law">
<code class="descname">apply_inverse_law</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.apply_inverse_law"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.apply_inverse_law" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, with the Inverse Law applied.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with the Inverse Law applied to
applicable clauses.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
<p>This transformation will apply the Inverse Law to <em>AND</em> and <em>OR</em>
expressions involving the negated and non-negated forms of a variable.
Here are a few examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;~A and A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_inverse_law</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;B or !B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_inverse_law</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Note that this transformation will <strong>not</strong> reduce expressions of
constants; the transformation <a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode.apply_identity_law" title="tt.trees.tree_node.ExpressionTreeNode.apply_identity_law"><code class="xref py py-func docutils literal"><span class="pre">apply_identity_law</span></code></a> will
probably do what you want in this case, though.</p>
<p>This transformation will also reduce expressions in CNF or DNF that
contain negated and non-negated forms of the same symbol. Let’s take a
look:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tt</span> <span class="k">import</span> <span class="n">BooleanExpression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A or B or C or ~B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_inverse_law</span><span class="p">())</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">BooleanExpression</span><span class="p">(</span><span class="s1">&#39;A and B and C and !B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">apply_inverse_law</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="tt.trees.tree_node.ExpressionTreeNode.build_tree">
<em class="property">static </em><code class="descname">build_tree</code><span class="sig-paren">(</span><em>postfix_tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.build_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.build_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a tree from a list of expression tokens in postfix order.</p>
<p>This method does not check that the tokens are indeed in postfix order;
undefined behavior will ensue if you pass tokens in an order other than
postfix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>postfix_tokens</strong> (List[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>]) – A list of string tokens from which to construct
the tree of expression nodes.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The root node of the constructed tree.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="errors.html#tt.errors.arguments.InvalidArgumentTypeError" title="tt.errors.arguments.InvalidArgumentTypeError"><strong>InvalidArgumentTypeError</strong></a> – If <code class="docutils literal"><span class="pre">postfix_tokens</span></code> is not a list
of strings.</li>
<li><a class="reference internal" href="errors.html#tt.errors.arguments.InvalidArgumentValueError" title="tt.errors.arguments.InvalidArgumentValueError"><strong>InvalidArgumentValueError</strong></a> – If <code class="docutils literal"><span class="pre">postfix_tokens</span></code> is empty.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.coalesce_negations">
<code class="descname">coalesce_negations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.coalesce_negations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.coalesce_negations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, with consecutive negations coalesced.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all consecutive negations
compressed into the minimal number of equivalent negations (either
one or none).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.distribute_ands">
<code class="descname">distribute_ands</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.distribute_ands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.distribute_ands" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed nodes, with ANDs recursively distributed across
ORed sub-expressions.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all applicable AND operators
distributed across ORed sub-expressions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.distribute_ors">
<code class="descname">distribute_ors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.distribute_ors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.distribute_ors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed nodes, with ORs recursively distributed across
ANDed sub-expressions.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all applicable OR operators
distributed across ANDed sub-expressions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>input_dict</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively evaluate this node.</p>
<p>This is an interface that should be defined in sub-classes. Node
evaluation does no checking of the validity of inputs; they should be
check before being passed here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_dict</strong> (Dict{<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>: truthy) – A dictionary mapping expression symbols to the value
for which they should be subsituted in expression evaluation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The evaluation of the tree rooted at this node.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.is_cnf">
<code class="descname">is_cnf</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.is_cnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the tree rooted at this node is in conjunctive normal form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.is_dnf">
<code class="descname">is_dnf</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.is_dnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the tree rooted at this node is in disjunctive normal form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.is_really_unary">
<code class="descname">is_really_unary</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.is_really_unary" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the tree rooted at this node contains no binary operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.iter_clauses">
<code class="descname">iter_clauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.iter_clauses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.iter_clauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate the clauses in the expression tree rooted at this node.</p>
<p>If the normal form of the expression is ambiguous, then precedence will
be given to conjunctive normal form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Iterator of each CNF or DNF clause, rooted by a tree node,
contained within the expression tree rooted at this node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Iterator[<a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a>]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="errors.html#tt.errors.state.RequiresNormalFormError" title="tt.errors.state.RequiresNormalFormError"><strong>RequiresNormalFormError</strong></a> – If this expression is  not in
conjunctive or disjunctive normal form.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.iter_cnf_clauses">
<code class="descname">iter_cnf_clauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.iter_cnf_clauses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.iter_cnf_clauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate the clauses in conjunctive normal form order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Iterator of each CNF clause, rooted by a tree node, contained
within the expression tree rooted at this node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Iterator[<a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a>]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="errors.html#tt.errors.state.RequiresNormalFormError" title="tt.errors.state.RequiresNormalFormError"><strong>RequiresNormalFormError</strong></a> – If the expression tree rooted at this
node is not in conjunctive normal form.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.iter_dnf_clauses">
<code class="descname">iter_dnf_clauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.iter_dnf_clauses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.iter_dnf_clauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate the clauses in disjunctive normal form order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Iterator of each DNF clause, rooted by a tree node, contained
within the expression tree rooted at this node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Iterator[<a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a>]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="errors.html#tt.errors.state.RequiresNormalFormError" title="tt.errors.state.RequiresNormalFormError"><strong>RequiresNormalFormError</strong></a> – If the expression tree rooted at this
node is not in disjunctive normal form.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.l_child">
<code class="descname">l_child</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.l_child" title="Permalink to this definition">¶</a></dt>
<dd><p>This node’s left child; <code class="docutils literal"><span class="pre">None</span></code> indicates the absence of a child.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.negated_symbol_set">
<code class="descname">negated_symbol_set</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.negated_symbol_set" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of the negated symbols present in the tree rooted here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Set[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.non_negated_symbol_set">
<code class="descname">non_negated_symbol_set</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.non_negated_symbol_set" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of the non-negated symbols present in the tree rooted here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Set[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.r_child">
<code class="descname">r_child</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.r_child" title="Permalink to this definition">¶</a></dt>
<dd><p>This node’s left child; <code class="docutils literal"><span class="pre">None</span></code> indicates the absence of a child.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tt.trees.tree_node.ExpressionTreeNode.symbol_name">
<code class="descname">symbol_name</code><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.symbol_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The string operator/operand name wrapped in this node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.to_cnf">
<code class="descname">to_cnf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.to_cnf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.to_cnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, in conjunctive normal form.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all operators transformed to
consist only of NOTs, ANDs, and ORs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tt.trees.tree_node.ExpressionTreeNode.to_primitives">
<code class="descname">to_primitives</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#ExpressionTreeNode.to_primitives"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.ExpressionTreeNode.to_primitives" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed node, containing only NOTs, ANDs, and ORs.</p>
<p>Since nodes are immutable, the returned node, and all descendants, are
new objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An expression tree node with all operators transformed to
consist only of NOTs, ANDs, and ORs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">ExpressionTreeNode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tt.trees.tree_node.OperandExpressionTreeNode">
<em class="property">class </em><code class="descclassname">tt.trees.tree_node.</code><code class="descname">OperandExpressionTreeNode</code><span class="sig-paren">(</span><em>operand_str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#OperandExpressionTreeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.OperandExpressionTreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">tt.trees.tree_node.ExpressionTreeNode</span></code></a></p>
<p>An expression tree node for operands.</p>
<p>Nodes of this type will always be leaves in an expression tree.</p>
</dd></dl>

<dl class="class">
<dt id="tt.trees.tree_node.UnaryOperatorExpressionTreeNode">
<em class="property">class </em><code class="descclassname">tt.trees.tree_node.</code><code class="descname">UnaryOperatorExpressionTreeNode</code><span class="sig-paren">(</span><em>operator_str</em>, <em>l_child</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tt/trees/tree_node.html#UnaryOperatorExpressionTreeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tt.trees.tree_node.UnaryOperatorExpressionTreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tt.trees.tree_node.ExpressionTreeNode" title="tt.trees.tree_node.ExpressionTreeNode"><code class="xref py py-class docutils literal"><span class="pre">tt.trees.tree_node.ExpressionTreeNode</span></code></a></p>
<p>An expression tree node for unary operators.</p>
<dl class="attribute">
<dt id="tt.trees.tree_node.UnaryOperatorExpressionTreeNode.operator">
<code class="descname">operator</code><a class="headerlink" href="#tt.trees.tree_node.UnaryOperatorExpressionTreeNode.operator" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual operator object wrapped in this node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><a class="reference internal" href="definitions.html#tt.definitions.operators.BooleanOperator" title="tt.definitions.operators.BooleanOperator"><code class="xref py py-class docutils literal"><span class="pre">BooleanOperator</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">the Boolean expression toolbox</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=welchbj&repo=tt&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prior_art.html">Prior Art</a></li>
<li class="toctree-l1"><a class="reference internal" href="../special_thanks.html">Special Thanks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../author.html">Author</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="cli.html"><code class="docutils literal"><span class="pre">cli</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="definitions.html"><code class="docutils literal"><span class="pre">definitions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html"><code class="docutils literal"><span class="pre">errors</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="expressions.html"><code class="docutils literal"><span class="pre">expressions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="satisfiability.html"><code class="docutils literal"><span class="pre">satisfiability</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="tables.html"><code class="docutils literal"><span class="pre">tables</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="transformations.html"><code class="docutils literal"><span class="pre">transformations</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal"><span class="pre">trees</span></code></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="transformations.html" title="previous chapter"><code class="docutils literal"><span class="pre">transformations</span></code></a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Brian Welch.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/api/trees.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>