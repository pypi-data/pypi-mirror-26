<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Plugin API</title>
<meta name="date" content="2009-01-23" />
<link rel="stylesheet" href="../default.css" type="text/css" />
</head>
<body>
<div class="document" id="plugin-api">
<h1 class="title">Plugin API</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Date:</th>
<td>2009-01-23</td></tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a><ul>
<li><a class="reference internal" href="#see-also" id="id3">See also</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure-of-a-plugin" id="id4">Structure of a plugin</a></li>
<li><a class="reference internal" href="#plugin-metadata-before-installation" id="id5">Plugin metadata before installation</a><ul>
<li><a class="reference internal" href="#metadata-protocol" id="id6">Metadata protocol</a></li>
<li><a class="reference internal" href="#control-formats" id="id7">Control Formats</a></li>
<li><a class="reference internal" href="#example" id="id8">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plugin-metadata-after-installation" id="id9">Plugin metadata after installation</a><ul>
<li><a class="reference internal" href="#help-and-documentation" id="id10">Help and documentation</a></li>
<li><a class="reference internal" href="#api-version" id="id11">API version</a></li>
<li><a class="reference internal" href="#plugin-version" id="id12">Plugin version</a></li>
<li><a class="reference internal" href="#detecting-whether-code-s-being-loaded-as-a-plugin" id="id13">Detecting whether code's being loaded as a plugin</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plugin-performance" id="id14">Plugin performance</a></li>
<li><a class="reference internal" href="#plugin-registrations" id="id15">Plugin registrations</a></li>
<li><a class="reference internal" href="#publishing-your-plugin" id="id16">Publishing your plugin</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>bzrlib has a very flexible internal structure allowing plugins for many
operations. Plugins can add commands, new storage formats, diff and merge
features and more. This document provides an overview of the API and
conventions for plugin authors.</p>
<p>If you're writing a plugin and have questions not addressed by this
document, please ask us.</p>
<div class="section" id="see-also">
<h2><a class="toc-backref" href="#id3">See also</a></h2>
<blockquote>
<ul class="simple">
<li><a class="reference external" href="../index.html">Bazaar Developer Documentation Catalog</a>.</li>
<li><a class="reference external" href="http://doc.bazaar.canonical.com/plugins/en/plugin-development.html">Bazaar Plugins Guide</a> for
more suggestions about particular APIs.</li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="structure-of-a-plugin">
<h1><a class="toc-backref" href="#id4">Structure of a plugin</a></h1>
<p>Plugins are Python modules under <tt class="docutils literal">bzrlib.plugins</tt>. They can be installed
either into the PYTHONPATH in that location, or in ~/.bazaar/plugins.</p>
<p>Plugins should have a setup.py.</p>
<p>As for other Python modules, the name of the directory must match the
expected name of the plugin.</p>
</div>
<div class="section" id="plugin-metadata-before-installation">
<h1><a class="toc-backref" href="#id5">Plugin metadata before installation</a></h1>
<p>Plugins can export a summary of what they provide, and what versions of bzrlib
they are compatible with. This allows tools to be written to work with plugins,
such as to generate a directory of plugins, or install them via a
symlink/checkout to ~/.bazaar/plugins.</p>
<p>This interface allows bzr to interrogate a plugin without actually loading
it. This is useful because loading a plugin may have side effects such
as registering or overriding commands, or the plugin may raise an error,
if for example a prerequisite is not present.</p>
<div class="section" id="metadata-protocol">
<h2><a class="toc-backref" href="#id6">Metadata protocol</a></h2>
<p>A plugin that supports the bzr plugin metadata protocol will do two
things. Firstly, the <tt class="docutils literal">setup.py</tt> for the plugin will guard the call to
<tt class="docutils literal">setup()</tt>:</p>
<pre class="literal-block">
if __name__ == 'main':
    setup(...)
</pre>
<p>Secondly, the setup module will have one or more of the following variables
present at module scope. Any variables that are missing will be given the
defaults from the table. An example of every variable is provided after
the full list.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="12%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Variable</th>
<th class="head">Default</th>
<th class="head">Definition</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>bzr_plugin_name</td>
<td>None</td>
<td>The name the plugin package should be
given on disk. The plugin is then
available to python at
bzrlib.plugins.NAME</td>
</tr>
<tr><td>bzr_commands</td>
<td>[]</td>
<td>A list of the commands that the plugin
provides. Commands that already exist
in bzr and are decorated by the plugin
do not need to be listed (but it is not
harmful if you do list them).</td>
</tr>
<tr><td>bzr_plugin_version</td>
<td>None</td>
<td>A version_info 5-tuple with the plugins
version.</td>
</tr>
<tr><td>bzr_minimum_version</td>
<td>None</td>
<td>A version_info 3-tuple for comparison
with the bzrlib minimum and current
version, for determining likely
compatibility.</td>
</tr>
<tr><td>bzr_maximum_version</td>
<td>None</td>
<td>A version_info 3-tuple like
bzr_minimum_version but checking the
upper limits supported.</td>
</tr>
<tr><td>bzr_control_formats</td>
<td>{}</td>
<td>A dictionary of descriptions of version
control directories. See
<cite>Control Formats</cite> below.</td>
</tr>
<tr><td>bzr_checkout_formats</td>
<td>{}</td>
<td>A dictionary of tree_format_string -&gt;
human description strings, for tree
formats that drop into the
<tt class="docutils literal">.bzr/checkout</tt> metadir system.</td>
</tr>
<tr><td>bzr_branch_formats</td>
<td>{}</td>
<td>As bzr_checkout_formats but for
branches.</td>
</tr>
<tr><td>bzr_repository_formats</td>
<td>{}</td>
<td>As bzr_checkout_formats but for
repositories.</td>
</tr>
<tr><td>bzr_transports</td>
<td>[]</td>
<td>URL prefixes for which this plugin
will register transports.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="control-formats">
<h2><a class="toc-backref" href="#id7">Control Formats</a></h2>
<p>Because disk format detection for formats that bzr does not understand at
all can be useful, we allow a declarative description of the shape of a
control directory. Each description has a name for showing to users, and a
dictonary of relative paths, and the content needed at each path. Paths
that end in '/' are required to be directories and the value for that key
is ignored. Other paths are required to be regular files, and the value
for that key is either None, in which case the file is statted but the
content is ignored, or a literal string which is compared against for
the content of the file. Thus:</p>
<pre class="literal-block">
# (look for a .hg directory)
bzr_control_formats = {&quot;Mercurial&quot;:{'.hg/': None}}

# (look for a file called .svn/format with contents 4\n).
bzr_control_formats = {&quot;Subversion&quot;:{'.svn/format': '4\n'}}
</pre>
</div>
<div class="section" id="example">
<h2><a class="toc-backref" href="#id8">Example</a></h2>
<p>An example setup.py follows:</p>
<pre class="literal-block">
#!/usr/bin/env python2.4
from distutils.core import setup

bzr_plugin_name = 'demo'
bzr_commands = [
    'new-command',
    ]

bzr_branch_formats = {
    &quot;Branch label on disk\n&quot;:&quot;demo branch&quot;,
    }

bzr_control_formats = {&quot;Subversion&quot;:{'.svn/format': '4\n'}}

bzr_transports = [&quot;hg+ssh://&quot;]

bzr_plugin_version = (1, 3, 0, 'dev', 0)
bzr_minimum_version = (1, 0, 0)

if __name__ == 'main':
    setup(name=&quot;Demo&quot;,
          version=&quot;1.3.0dev0&quot;,
          description=&quot;Demo plugin for plugin metadata.&quot;,
          author=&quot;Canonical Ltd&quot;,
          author_email=&quot;bazaar&#64;lists.canonical.com&quot;,
          license = &quot;GNU GPL v2&quot;,
          url=&quot;https://launchpad.net/bzr-demo&quot;,
          packages=['bzrlib.plugins.demo',
                    'bzrlib.plugins.demo.tests',
                    ],
          package_dir={'bzrlib.plugins.demo': '.'})
</pre>
</div>
</div>
<div class="section" id="plugin-metadata-after-installation">
<h1><a class="toc-backref" href="#id9">Plugin metadata after installation</a></h1>
<p>After a plugin has been installed, metadata can be more easily obtained by
looking inside the module object -- in other words, for variables defined
in the plugin's <tt class="docutils literal">__init__.py</tt>.</p>
<div class="section" id="help-and-documentation">
<h2><a class="toc-backref" href="#id10">Help and documentation</a></h2>
<p>The module docstring is used as the plugin description shown by <tt class="docutils literal">bzr
plugins</tt>.  As with all Python docstrings, the first line should be a
short complete sentence summarizing the plugin.  The full docstring is
shown by <tt class="docutils literal">bzr help PLUGIN_NAME</tt>.</p>
<p>This is a user-visible docstring so should be prefixed with <tt class="docutils literal">__doc__ =</tt>
to ensure help works under <tt class="docutils literal">python <span class="pre">-OO</span></tt> with docstrings stripped.</p>
</div>
<div class="section" id="api-version">
<h2><a class="toc-backref" href="#id11">API version</a></h2>
<p>Plugins can and should declare that they depend on a particular version of
bzrlib like so:</p>
<pre class="literal-block">
from bzrlib.api import require_api

require_api(bzrlib, (1, 11, 0))
</pre>
<p>Please see <a class="reference external" href="api-versioning.html">API versioning</a> for more details on the API
metadata protocol used by bzrlib.</p>
</div>
<div class="section" id="plugin-version">
<h2><a class="toc-backref" href="#id12">Plugin version</a></h2>
<p>The plugin should expose a version tuple to describe its own version.
Some plugins use a version number that corresponds to the version of bzr
they're released against, but you can use whatever you want.  For example:</p>
<pre class="literal-block">
version_info = (1, 10, 0)
</pre>
</div>
<div class="section" id="detecting-whether-code-s-being-loaded-as-a-plugin">
<h2><a class="toc-backref" href="#id13">Detecting whether code's being loaded as a plugin</a></h2>
<p>You may have a Python module that can be used as a bzr plugin and also in
other places.  To detect whether the module is being loaded by bzr, use
something like this:</p>
<pre class="literal-block">
if __name__ == 'bzrlib.plugins.loggerhead':
    # register with bzrlib...
</pre>
</div>
</div>
<div class="section" id="plugin-performance">
<h1><a class="toc-backref" href="#id14">Plugin performance</a></h1>
<p>Plugins should avoid doing work or loading code from the plugin or
external libraries, if they're just installed but not actually active,
because this slows down every invocation of bzr.  The bzrlib APIs
generally allow the plugin to 'lazily' register methods to invoke if a
particular disk format or seen or a particular command is run.</p>
</div>
<div class="section" id="plugin-registrations">
<h1><a class="toc-backref" href="#id15">Plugin registrations</a></h1>
<p>The plugin <tt class="docutils literal">__init__.py</tt> runs when the plugin is loaded during bzr
startup.  Generally the plugin won't want to actually do anything at this
time other than register or override functions to be called later.</p>
<p>The plugin can import bzrlib and call any function.
Some interesting APIs are described in <a class="reference external" href="http://doc.bazaar.canonical.com/plugins/en/plugin-development.html">Bazaar Plugins Guide</a>.</p>
</div>
<div class="section" id="publishing-your-plugin">
<h1><a class="toc-backref" href="#id16">Publishing your plugin</a></h1>
<p>When your plugin is basically working you might like to share it with
other people.  Here are some steps to consider:</p>
<blockquote>
<ul class="simple">
<li>make a project on Launchpad.net like
&lt;<a class="reference external" href="https://launchpad.net/bzr-fastimport">https://launchpad.net/bzr-fastimport</a>&gt;
and publish the branches or tarballs there</li>
<li>include the plugin in &lt;<a class="reference external" href="http://wiki.bazaar.canonical.com/BzrPlugins">http://wiki.bazaar.canonical.com/BzrPlugins</a>&gt;</li>
<li>post about it to the <tt class="docutils literal"><span class="pre">bazaar-announce</span></tt> list at <tt class="docutils literal">lists.canonical.com</tt></li>
</ul>
</blockquote>
<!-- vim: ft=rst tw=74 ai shiftwidth=4 -->
</div>
</div>
</body>
</html>
