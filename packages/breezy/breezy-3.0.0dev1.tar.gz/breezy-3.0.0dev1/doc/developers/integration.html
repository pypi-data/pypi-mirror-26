<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Integrating with Bazaar</title>
<link rel="stylesheet" href="../default.css" type="text/css" />
</head>
<body>
<div class="document" id="integrating-with-bazaar">
<h1 class="title">Integrating with Bazaar</h1>

<p>This document provides some general observations on integrating with
Bazaar and some recipes for typical tasks.  It is intended to be useful to
someone developing either a plugin or some other piece of software that
integrates with bzr.  If you want to know about a topic that's not covered
here, just ask us.</p>
<div class="section" id="starting-with-bzrlib">
<h1>Starting with bzrlib</h1>
<div class="section" id="within-bzr">
<h2>Within bzr</h2>
<p>When using bzrlib within the <tt class="docutils literal">bzr</tt> program (for instance as a bzr
plugin), bzrlib's global state is already available for use.</p>
</div>
<div class="section" id="from-outside-bzr">
<h2>From outside bzr</h2>
<p>To use bzrlib outside of <tt class="docutils literal">bzr</tt> some global state needs to be setup.
bzrlib needs ways to handle user input, passwords, a place to emit
progress bars, logging setup appropriately for your program. The easiest
way to set all this up in the same fashion <tt class="docutils literal">bzr</tt> does is to call
<tt class="docutils literal">bzrlib.initialize</tt>.</p>
<p>This returns a context manager within which bzrlib functions will work
correctly. See the pydoc for <tt class="docutils literal">bzrlib.initialize</tt> for more information.
(You can get away without entering the context manager, because the setup
work happens directly from <tt class="docutils literal">initialize</tt>.)</p>
<p>In Python 2.4 the <tt class="docutils literal">with</tt> keyword is not supported and
so you need to use the context manager manually:</p>
<pre class="literal-block">
# This sets up your ~/.bzr.log, ui factory and so on and so forth. It is
# not safe to use as a doctest.
library_state = bzrlib.initialize()
library_state.__enter__()
try:
    pass
    # do stuff here
finally:
    library_state.__exit__(None, None, None)
</pre>
</div>
</div>
<div class="section" id="running-bzr-commands">
<h1>Running bzr commands</h1>
<p>To run command-line commands in-process:</p>
<pre class="literal-block">
from bzrlib.commands import get_command

cmd = get_command('version')
cmd.run([])
</pre>
<p>This will send output through the current UIFactory; you can redirect this
elsewhere through the parameters to <cite>bzrlib.initialize</cite>.</p>
</div>
<div class="section" id="manipulating-the-working-tree">
<h1>Manipulating the Working Tree</h1>
<p>Most objects in Bazaar are in files, named after the class they contain.
To manipulate the Working Tree we need a valid WorkingTree object, which
is loaded from the workingtree.py file, eg:</p>
<pre class="literal-block">
from bzrlib import workingtree
wt = workingtree.WorkingTree.open('/home/jebw/bzrtest')
</pre>
<p>This gives us a WorkingTree object, which has various methods spread over
itself, and its parent classes MutableTree and Tree - it's worth having a
look through these three files (workingtree.py, mutabletree.py and tree.py)
to see which methods are available.</p>
<div class="section" id="compare-trees">
<h2>Compare trees</h2>
<p>There are two methods for comparing trees: <tt class="docutils literal">changes_from</tt> and
<tt class="docutils literal">iter_changes</tt>.  <tt class="docutils literal">iter_changes</tt> is more regular and precise, but it is
somewhat harder to work with.  See the API documentation for more details.</p>
<p><tt class="docutils literal">changes_from</tt> creates a Delta object showing changes:</p>
<pre class="literal-block">
from bzrlib import delta
changes = wt.changes_from(wt.basis_tree())
</pre>
<p>This gives us a Delta object, which has several lists of files for each type of
change, eg changes.added is a list of added files, changes.removed is list
of removed files, changes.modified is a list of modified files. The contents
of the lists aren't just filenames, but include other information as well.
To grab just the filename we want the first value, eg:</p>
<pre class="literal-block">
print(&quot;list of newly added files&quot;)
for filename in changes.added:
  print(&quot;%s has been added&quot; % filename[0])
</pre>
<p>The exception to this is changes.renamed, where the list returned for each
renamed files contains both the old and new names -- one or both may interest
you, depending on what you're doing.</p>
<p>For example:</p>
<pre class="literal-block">
print(&quot;list of renamed files&quot;)
for filename in changes.renamed:
  print(&quot;%s has been renamed to %s&quot; % (filename[0], filename[1]))
</pre>
</div>
<div class="section" id="adding-files">
<h2>Adding Files</h2>
<p>If you want to add files the same way <tt class="docutils literal">bzr add</tt> does, you can use
MutableTree.smart_add.  By default, this is recursive. Paths can either be
absolute or relative to the workingtree:</p>
<pre class="literal-block">
wt.smart_add(['dir1/filea.txt', 'fileb.txt',
              '/home/jebw/bzrtesttree/filec.txt'])
</pre>
<p>For more precise control over which files to add, use MutableTree.add:</p>
<pre class="literal-block">
wt.add(['dir1/filea.txt', 'fileb.txt', '/home/jebw/bzrtesttree/filec.txt'])
</pre>
</div>
<div class="section" id="removing-files">
<h2>Removing Files</h2>
<p>You can remove multiple files at once.  The file paths need to be relative
to the workingtree:</p>
<pre class="literal-block">
wt.remove(['filea.txt', 'fileb.txt', 'dir1'])
</pre>
<p>By default, the files are not deleted, just removed from the inventory.
To delete them from the filesystem as well:</p>
<pre class="literal-block">
wt.remove(['filea.txt', 'fileb.txt', 'dir1'], keep_files=False)
</pre>
</div>
<div class="section" id="renaming-a-file">
<h2>Renaming a File</h2>
<p>You can rename one file to a different name using WorkingTree.rename_one.
You just provide the old and new names, eg:</p>
<pre class="literal-block">
wt.rename_one('oldfile.txt','newfile.txt')
</pre>
</div>
<div class="section" id="moving-files">
<h2>Moving Files</h2>
<p>You can move multiple files from one directory into another using
WorkingTree.move:</p>
<pre class="literal-block">
wt.move(['olddir/file.txt'], 'newdir')
</pre>
<p>More complicated renames/moves can be done with transform.TreeTransform,
which is outside the scope of this document.</p>
</div>
<div class="section" id="committing-changes">
<h2>Committing Changes</h2>
<p>To commit _all_ the changes to our working tree we can just call the
WorkingTree's commit method, giving it a commit message, eg:</p>
<pre class="literal-block">
wt.commit('this is my commit message')
</pre>
<p>To commit only certain files, we need to provide a list of filenames which we
want committing, eg:</p>
<pre class="literal-block">
wt.commit(message='this is my commit message', specific_files=['fileA.txt',
          'dir2/fileB.txt', 'fileD.txt'])
</pre>
</div>
</div>
<div class="section" id="generating-a-log-for-a-file">
<h1>Generating a Log for a File</h1>
<p>Generating a log is, in itself, simple.  Grab a branch (see below) and pass
it to show_log together with a log formatter, eg:</p>
<pre class="literal-block">
from bzrlib import log
from bzrlib import branch

b = branch.Branch.open('/path/to/bazaar/branch')
lf = log.LongLogFormatter(to_file=sys.stdout)
log.show_log(b, lf)
</pre>
<p>Three log formatters are included with bzrlib: LongLogFormatter,
ShortLogFormatter and LineLogFormatter.  These provide long, short and
single-line log output formats. It's also possible to write your own in
very little code.</p>
</div>
<div class="section" id="annotating-a-file">
<h1>Annotating a File</h1>
<p>To annotate a file, we want to walk every line of a file, retrieving the
revision which last modified/created that line and then retrieving the
information for that revision.</p>
<p>First we get an annotation iterator for the file we are interested in:</p>
<pre class="literal-block">
tree, relpath = workingtree.WorkingTree.open_containing('/path/to/file.txt')
fileid = tree.path2id(relpath)
annotation = list(tree.annotate_iter(fileid))
</pre>
<p>To avoid repeatedly retrieving the same revisions we grab all revisions
associated with the file at once and build up a map of id to revision
information. We also build an map of revision numbers, again indexed
by the revision id:</p>
<pre class="literal-block">
revision_ids = set(revision_id for revision_id, text in annotation)
revisions = tree.branch.repository.get_revisions(revision_ids)
revision_map = dict(izip(revision_ids, revisions))
revno_map = tree.branch.get_revision_id_to_revno_map()
</pre>
<p>Finally, we use our annotation iterator to walk the lines of the file,
displaying the information from our revision maps as we go:</p>
<pre class="literal-block">
for revision_id, text in annotation :
    rev = revision_map[revision_id]
    revno = revno_map[revision_id]
    revno_string = '.'.join(str(i) for i in revno)
    print &quot;%s, %s: %s&quot; % (revno_string, rev.committer, text)
</pre>
</div>
<div class="section" id="working-with-branches">
<h1>Working with branches</h1>
<p>To work with a branch you need a branch object, created from your branch:</p>
<pre class="literal-block">
from bzrlib import branch

b = branch.Branch.open('/home/jebw/bzrtest')
</pre>
<div class="section" id="branching-from-an-existing-branch">
<h2>Branching from an existing branch</h2>
<p>To branch you create a branch object representing the branch you are
branching from, and supply a path/url to the new branch location.
The following code clones the bzr.dev branch (the latest copy of the Bazaar
source code) - be warned it has to download 60meg so takes a while to run
with no feedback:</p>
<pre class="literal-block">
from bzrlib import branch

b = branch.Branch.open('http://bazaar.launchpad.net/~bzr-pqm/bzr/bzr.dev')
nb = b.controldir.sprout('/tmp/newBzrBranch').open_branch()
</pre>
<p>This provides no feedback, since Bazaar automatically uses the 'silent' UI.</p>
</div>
<div class="section" id="pushing-and-pulling-branches">
<h2>Pushing and pulling branches</h2>
<p>To push a branch you need to open the source and destination branches, then
just call push with the other branch as a parameter:</p>
<pre class="literal-block">
from bzrlib import branch

b1 = branch.Branch.open('file:///home/user/mybranch')
b2 = branch.Branch.open('http://bazaar.launchpad.net/~bzr-pqm/bzr/bzr.dev')
b1.push(b2)
</pre>
<p>Pulling is much the same:</p>
<pre class="literal-block">
b1.pull(b2)
</pre>
<p>If you have a working tree, as well as a branch, you should use
WorkingTree.pull, not Branch.pull.</p>
<p>This won't handle conflicts automatically though, so any conflicts will be
left in the working tree for the user to resolve.</p>
</div>
</div>
<div class="section" id="checkout-from-an-existing-branch">
<h1>Checkout from an existing branch</h1>
<p>This performs a Lightweight checkout from an existing Branch:</p>
<pre class="literal-block">
from bzrlib import bzrdir

accelerator_tree, source = bzrdir.BzrDir.open_tree_or_branch('http:URL')
source.create_checkout('/tmp/newBzrCheckout', None, True, accelerator_tree)
</pre>
<p>To make a heavyweight checkout, change the last line to:</p>
<pre class="literal-block">
source.create_checkout('/tmp/newBzrCheckout', None, False, accelerator_tree
</pre>
</div>
<div class="section" id="history-operations">
<h1>History Operations</h1>
<div class="section" id="finding-the-last-revision-number-or-id">
<h2>Finding the last revision number or id</h2>
<p>To get the last revision number and id of a branch use:</p>
<pre class="literal-block">
revision_number, revision_id = branch.last_revision_info()
</pre>
<p>If all you care about is the revision_id there is also the
method:</p>
<pre class="literal-block">
revision_id = branch.last_revision()
</pre>
</div>
<div class="section" id="getting-the-list-of-revision-ids-that-make-up-a-branch">
<h2>Getting the list of revision ids that make up a branch</h2>
<p>IMPORTANT: This should be avoided wherever possible, as it scales with the
length of history:</p>
<pre class="literal-block">
revisions = branch.revision_history()
</pre>
<p>now revisions[0] is the revision id of the first commit, and revs[-1] is the
revision id of the most recent. Note that if all you want is the last
revision then you should use branch.last_revision() as described above, as
it is vastly more efficient.</p>
</div>
<div class="section" id="getting-a-revision-object-from-a-revision-id">
<h2>Getting a Revision object from a revision id</h2>
<p>The Revision object has attributes like &quot;message&quot; to get the information
about the revision:</p>
<pre class="literal-block">
repo = branch.repository
revision = repo.get_revision(rev_id)
</pre>
</div>
<div class="section" id="accessing-the-files-from-a-revision">
<h2>Accessing the files from a revision</h2>
<p>To get the file contents and tree shape for a specific revision you need
a RevisionTree. These are supplied by the repository for a specific
revision id:</p>
<pre class="literal-block">
revtree = repo.revision_tree(rev_id)
</pre>
<p>RevisionTrees, like all trees, can be compared as described in &quot;Comparing
Trees&quot; above.</p>
<p>The most common way to list files in a tree is <tt class="docutils literal">Tree.iter_entries()</tt>.
The simplest way to get file content is <tt class="docutils literal">Tree.get_file()</tt>.  The best way
to retrieve file content for large numbers of files <cite>Tree.iter_files_bytes()`</cite></p>
</div>
</div>
</div>
</body>
</html>
