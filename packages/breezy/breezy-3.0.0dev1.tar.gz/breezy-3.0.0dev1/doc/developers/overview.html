<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Bazaar Architectural Overview</title>
<link rel="stylesheet" href="../default.css" type="text/css" />
</head>
<body>
<div class="document" id="bazaar-architectural-overview">
<h1 class="title">Bazaar Architectural Overview</h1>

<p>This document describes the key classes and concepts within Bazaar.  It is
intended to be useful to people working on the Bazaar codebase, or to
people writing plugins.  People writing plugins may also like to read the
guide to <a class="reference external" href="integration.html">Integrating with Bazaar</a> for some specific recipes.</p>
<p>There's some overlap between this and the <a class="reference external" href="http://doc.bazaar.canonical.com/latest/en/user-guide/core_concepts.html">Core Concepts</a> section of the
user guide, but this document is targetted to people interested in the
internals.  In particular the user guide doesn't go any deeper than
&quot;revision&quot;, because regular users don't care about lower-level details
like inventories, but this guide does.</p>
<p>If you have any questions, or if something seems to be incorrect, unclear
or missing, please talk to us in <tt class="docutils literal"><span class="pre">irc://irc.freenode.net/#bzr</span></tt>, write to
the Bazaar mailing list, or simply file a bug report.</p>
<div class="section" id="ids-and-keys">
<h1>IDs and keys</h1>
<div class="section" id="ids">
<h2>IDs</h2>
<p>All IDs are globally unique identifiers.  Inside bzrlib they are almost
always represented as UTF-8 encoded bytestrings (i.e. <tt class="docutils literal">str</tt> objects).</p>
<p>The main two IDs are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Revision IDs:</th><td class="field-body">The unique identifier of a single revision, such as
<tt class="docutils literal"><span class="pre">pqm&#64;pqm.ubuntu.com-20110201161347-ao76mv267gc1b5v2</span></tt></td>
</tr>
<tr class="field"><th class="field-name">File IDs:</th><td class="field-body">The unique identifier of a single file.</td>
</tr>
</tbody>
</table>
<p>By convention, in the bzrlib API, parameters of methods that are expected
to be IDs (as opposed to keys, revision numbers, or some other handle)
will end in <tt class="docutils literal">id</tt>, e.g.  <tt class="docutils literal">revid</tt> or <tt class="docutils literal">file_id</tt>.</p>
<p>Ids may be stored directly or they can be inferred from other
data. Native Bazaar formats store ids directly; foreign VCS
support usually generates them somehow. For example, the
Git commit with SHA <tt class="docutils literal">fb235a3be6372e40ff7f7ebbcd7905a08cb04444</tt>
is referred to with the revision ID
<tt class="docutils literal"><span class="pre">git-v1:fb235a3be6372e40ff7f7ebbcd7905a08cb04444</span></tt>. IDs are expected
to be persistent</p>
<div class="section" id="file-ids">
<h3>File ids</h3>
<p>File ids are unique identifiers for files. There are three slightly different
categories of file ids.</p>
<div class="section" id="tree-file-ids">
<h4>Tree file ids</h4>
<p>Tree file ids are used in the <tt class="docutils literal">Tree</tt> API and can either be UTF-8 encoded
bytestrings or tuples of UTF-8 encoded bytestrings. Plain bytestrings
are considered to be the equivalent of a 1-tuple containing that
bytestring.</p>
<p>Tree file ids should be considered valid only for a specific tree context.
Note that this is a stricter interpretation than what the current bzr
format implementation provides - its file ids are persistent across runs
and across revisions.</p>
<p>For some formats (most notably bzr's own formats) it's possible for the
implementation to specify the file id to use. In other case the tree
mandates a specific file id.</p>
</div>
<div class="section" id="inventory-file-ids">
<h4>Inventory file ids</h4>
<p>Inventories are specific to the bzr native format and are the main layer
below the <tt class="docutils literal">Tree</tt> implementation of bzr. File ids in inventories can
only be UTF-8 encoded bytestrings. A single Tree object can be associated
with multiple inventories if there are nested trees.</p>
<p>Tree file ids for bzr formats are a tuple of inventory file ids for the file
in question. Each non-last item in the tuple refers to the tree
reference of an inner tree. The last item in the tuple refers to the
actual file. This means that lookups of file ids doesn't scale with
the number of nested trees.</p>
<p>Inventory file ids are only relevant for native Bazaar formats; foreign
formats don't use inventories.</p>
</div>
<div class="section" id="transform-ids">
<h4>Transform ids</h4>
<p>Transform ids are used during tree transform operations (used by e.g. merge).
The same transform id is expected to be used for two instances of the
same file. At the moment transform ids are directly derived from file
ids, but in the future they could be based on other data too (e.g.
automatic rename detection or format-specific rules).</p>
</div>
</div>
</div>
<div class="section" id="keys">
<h2>Keys</h2>
<p>A composite of one or more ID elements.  E.g. a (file-id, revision-id)
pair is the key to the &quot;texts&quot; store, but a single element key of
(revision-id) is the key to the &quot;revisions&quot; store.</p>
</div>
</div>
<div class="section" id="core-classes">
<h1>Core classes</h1>
<div class="section" id="transport">
<h2>Transport</h2>
<p>The <tt class="docutils literal">Transport</tt> layer handles access to local or remote directories.
Each Transport object acts as a logical connection to a particular
directory, and it allows various operations on files within it.  You can
<em>clone</em> a transport to get a new Transport connected to a subdirectory or
parent directory.</p>
<p>Transports are not used for access to the working tree.  At present
working trees are always local and they are accessed through the regular
Python file I/O mechanisms.</p>
<div class="section" id="filenames-vs-urls">
<h3>Filenames vs URLs</h3>
<p>Transports work in terms of URLs.  Take note that URLs are by definition
only ASCII - the decision of how to encode a Unicode string into a URL
must be taken at a higher level, typically in the Store.  (Note that
Stores also escape filenames which cannot be safely stored on all
filesystems, but this is a different level.)</p>
<p>The main reason for this is that it's not possible to safely roundtrip a
URL into Unicode and then back into the same URL.  The URL standard
gives a way to represent non-ASCII bytes in ASCII (as %-escapes), but
doesn't say how those bytes represent non-ASCII characters.  (They're not
guaranteed to be UTF-8 -- that is common but doesn't happen everywhere.)</p>
<p>For example, if the user enters the URL <tt class="docutils literal"><span class="pre">http://example/%e0</span></tt>, there's no
way to tell whether that character represents &quot;latin small letter a with
grave&quot; in iso-8859-1, or &quot;latin small letter r with acute&quot; in iso-8859-2,
or malformed UTF-8.  So we can't convert the URL to Unicode reliably.</p>
<p>Equally problematic is if we're given a URL-like string containing
(unescaped) non-ASCII characters (such as the accented a).  We can't be
sure how to convert that to a valid (i.e. ASCII-only) URL, because we
don't know what encoding the server expects for those characters.
(Although it is not totally reliable, we might still accept these and
assume that they should be put into UTF-8.)</p>
<p>A similar edge case is that the URL <tt class="docutils literal"><span class="pre">http://foo/sweet%2Fsour</span></tt> contains
one directory component whose name is &quot;sweet/sour&quot;.  The escaped slash is
not a directory separator, but if we try to convert the URL to a regular
Unicode path, this information will be lost.</p>
<p>This implies that Transports must natively deal with URLs.  For simplicity
they <em>only</em> deal with URLs; conversion of other strings to URLs is done
elsewhere.  Information that Transports return, such as from <tt class="docutils literal">list_dir</tt>,
is also in the form of URL components.</p>
</div>
<div class="section" id="more-information">
<h3>More information</h3>
<p>See also:</p>
<ul class="simple">
<li><a class="reference external" href="transports.html">Developer guide to bzrlib transports</a></li>
<li>API docs for <tt class="docutils literal">bzrlib.transport.Transport</tt></li>
</ul>
</div>
</div>
<div class="section" id="control-directory">
<h2>Control directory</h2>
<p>Each control directory (such as &quot;.bzr/&quot;) can contain zero or one
repositories, zero or one working trees and zero or more branches.</p>
<p>The <tt class="docutils literal">BzrDir</tt> class is the <tt class="docutils literal">ControlDir</tt> implementation that is
responsible for the &quot;.bzr/&quot; directory and its implementation. Plugins
that provide support for other version control systems can provide
other subclasses of <tt class="docutils literal">ControlDir</tt>.</p>
</div>
<div class="section" id="tree">
<h2>Tree</h2>
<p>A representation of a directory of files (and other directories and
symlinks etc).  The most important kinds of Tree are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">WorkingTree:</th><td class="field-body">the files on disk editable by the user</td>
</tr>
<tr class="field"><th class="field-name">RevisionTree:</th><td class="field-body">a tree as recorded at some point in the past</td>
</tr>
</tbody>
</table>
<p>Trees can map file paths to file-ids and vice versa (although trees such
as WorkingTree may have unversioned files not described in that mapping).
Trees have an inventory and parents (an ordered list of zero or more
revision IDs).</p>
<p>The implementation of <tt class="docutils literal">Tree</tt> for Bazaar's own formats is based around
<tt class="docutils literal">Inventory</tt> objects which describe the shape of the tree. Each tree has
at least one inventory associated with it, which is available as the
<tt class="docutils literal">root_inventory</tt> attribute on tree. The tree can have more inventories
associated with it if there are references to other trees in it. These
references are indicated with <tt class="docutils literal"><span class="pre">tree-reference</span></tt> inventory entry at the
point where the other tree is nested. The tree reference entry contains
sufficient information for looking up the inventory associated with the
nested tree. There can be multiple layers of nesting.</p>
<p>Not each <tt class="docutils literal">Tree</tt> implementation will necessarily have an associated
<tt class="docutils literal">root_inventory</tt>, as not all implementations of <tt class="docutils literal">Tree</tt> are based
around inventories (most notably, implementations of foreign VCS file
formats).</p>
</div>
<div class="section" id="workingtree">
<h2>WorkingTree</h2>
<p>A workingtree is a special type of Tree that's associated with a working
directory on disk, where the user can directly modify the files.</p>
<p>Responsibilities:</p>
<ul class="simple">
<li>Maintaining a WorkingTree on disk at a file path.</li>
<li>Maintaining the basis inventory (the inventory of the last commit done)</li>
<li>Maintaining the working inventory.</li>
<li>Maintaining the pending merges list.</li>
<li>Maintaining the stat cache.</li>
<li>Maintaining the last revision the working tree was updated to.</li>
<li>Knows where its Branch is located.</li>
</ul>
<p>Dependencies:</p>
<ul class="simple">
<li>a Branch</li>
<li>local access to the working tree</li>
</ul>
</div>
<div class="section" id="branch">
<h2>Branch</h2>
<p>A Branch is a key user concept - its a single line of history that one or
more people have been committing to.</p>
<p>A Branch is responsible for:</p>
<ul class="simple">
<li>Holding user preferences that are set in a Branch.</li>
<li>Holding the 'tip': the last revision to be committed to this Branch.
(And the revno of that revision.)</li>
<li>Knowing how to open the Repository that holds its history.</li>
<li>Allowing write locks to be taken out to prevent concurrent alterations to the branch.</li>
</ul>
<p>Depends on:</p>
<ul class="simple">
<li>URL access to its base directory.</li>
<li>A Transport to access its files.</li>
<li>A Repository to hold its history.</li>
</ul>
</div>
<div class="section" id="repository">
<h2>Repository</h2>
<p>Repositories store committed history: file texts, revisions, inventories,
and graph relationships between them.  A repository holds a bag of
revision data that can be pointed to by various branches:</p>
<ul class="simple">
<li>Maintains storage of various history data at a URL:<ul>
<li>Revisions (Must have a matching inventory)</li>
<li>Digital Signatures</li>
<li>Inventories for each Revision. (Must have all the file texts available).</li>
<li>File texts</li>
</ul>
</li>
<li>Synchronizes concurrent access to the repository by different
processes.  (Most repository implementations use a physical mutex only
for a short period, and effectively support multiple readers and
writers.)</li>
</ul>
<div class="section" id="stacked-repositories">
<h3>Stacked Repositories</h3>
<p>A repository can be configured to refer to a list of &quot;fallback&quot;
repositories.  If a particular revision is not present in the original
repository, it refers the query to the fallbacks.</p>
<p>Compression deltas don't span physical repository boundaries.  So the
first commit to a new, empty repository with fallback repositories will
store a full text of the inventory, and of every new file text.</p>
<p>At runtime, repository stacking is actually configured by the branch, not
the repository.  So doing <tt class="docutils literal">a_bzrdir.open_repository()</tt>
gets you just the single physical repository, while
<tt class="docutils literal"><span class="pre">a_bzrdir.open_branch().repository</span></tt> gets one configured with a stacking.
Therefore, to permanently change the fallback repository stored on disk,
you must use <tt class="docutils literal">Branch.set_stacked_on_url</tt>.</p>
<p>Changing away from an existing stacked-on URL will copy across any
necessary history so that the repository remains usable.</p>
<p>A repository opened from an HPSS server is never stacked on the server
side, because this could cause complexity or security problems with the
server acting as a proxy for the client.  Instead, the branch on the
server exposes the stacked-on URL and the client can open that.</p>
</div>
</div>
</div>
<div class="section" id="storage-model">
<h1>Storage model</h1>
<p>This section describes the model for how bzr stores its data.  The
representation of that data on disk varies considerable depending on the
format of the repository (and to a lesser extent the format of the branch
and working tree), but ultimately the set of objects being represented is
the same.</p>
<div class="section" id="id1">
<h2>Branch</h2>
<p>A branch directly contains:</p>
<ul class="simple">
<li>the ID of the current revision that branch (a.k.a. the “tip”)</li>
<li>some settings for that branch (the values in “branch.conf”)</li>
<li>the set of tags for that branch (not supported in all formats)</li>
</ul>
<p>A branch implicitly references:</p>
<ul class="simple">
<li>A repository.  The repository might be colocated in the same directory
as the branch, or it might be somewhere else entirely.</li>
</ul>
</div>
<div class="section" id="id2">
<h2>Repository</h2>
<p>A repository contains:</p>
<ul class="simple">
<li>a revision store</li>
<li>an inventory store</li>
<li>a text store</li>
<li>a signature store</li>
</ul>
<p>A store is a key-value mapping.  This says nothing about the layout on
disk, just that conceptually there are distinct stores, each with a
separate namespace for the keys.  Internally the repository may serialize
stores in the same file, and/or e.g. apply compression algorithms that
combine records from separate stores in one block, etc.</p>
<p>You can consider the repository as a single key space, with keys that look
like <em>(store-name, ...)</em>.  For example, <em>('revisions',
revision-id)</em> or <em>('texts', revision-id, file-id)</em>.</p>
<div class="section" id="revision-store">
<h3>Revision store</h3>
<p>Stores revision objects.  The keys are GUIDs.  The value is a revision
object (the exact representation on disk depends on the repository
format).</p>
<p>As described in <a class="reference external" href="http://doc.bazaar.canonical.com/latest/en/user-guide/core_concepts.html">Core Concepts</a> a revision describes a snapshot of the
tree of files and some metadata about them.</p>
<ul class="simple">
<li>metadata:<ul>
<li>parent revisions (an ordered sequence of zero or more revision IDs)</li>
<li>commit message</li>
<li>author(s)</li>
<li>timestamp</li>
<li>(and all other revision properties)</li>
</ul>
</li>
<li>an inventory ID (that inventory describes the tree contents).  Is often
the same as the revision ID, but doesn't have to be (e.g. if no files
were changed between two revisions then both revisions will refer to
the same inventory).</li>
</ul>
</div>
<div class="section" id="inventory-store">
<h3>Inventory store</h3>
<p>Stores inventory objects.  The keys are GUIDs.  (Footnote: there will
usually be a revision with the same key in the revision store, but there
are rare cases where this is not true.)</p>
<p>An inventory object contains:</p>
<ul class="simple">
<li>a set of inventory entries</li>
</ul>
<p>An inventory entry has the following attributes</p>
<ul class="simple">
<li>a file-id (a GUID, or the special value TREE_ROOT for the root entry of
inventories created by older versions of bzr)</li>
<li>a revision-id, a GUID (generally corresponding to the ID of a
revision).  The combination of (file-id, revision-id) is a key into the
texts store.</li>
<li>a kind: one of file, directory, symlink, tree-reference (tree-reference
is only supported in unsupported developer formats)</li>
<li>parent-id: the file-id of the directory that contains this entry (this
value is unset for the root of the tree).</li>
<li>name: the name of the file/directory/etc in that parent directory</li>
<li>executable: a flag indicating if the executable bit is set for that
file.</li>
</ul>
<p>An inventory entry will have other attributes, depending on the kind:</p>
<ul class="simple">
<li>file:<ul>
<li>SHA1</li>
<li>size</li>
</ul>
</li>
<li>directory<ul>
<li>children</li>
</ul>
</li>
<li>symlink<ul>
<li>symlink_target</li>
</ul>
</li>
<li>tree-reference<ul>
<li>reference_revision</li>
</ul>
</li>
</ul>
<p>For some more details see <a class="reference external" href="inventory.html">Inventories</a>.</p>
</div>
<div class="section" id="texts-store">
<h3>Texts store</h3>
<p>Stores the contents of individual versions of files.  The keys are pairs
of (file-id, revision-id), and the values are the full content (or
&quot;text&quot;) of a version of a file.</p>
<p>For consistency/simplicity text records exist for all inventory entries,
but in general only entries with of kind &quot;file&quot; have interesting records.</p>
</div>
<div class="section" id="signature-store">
<h3>Signature store</h3>
<p>Stores cryptographic signatures of revision contents.  The keys match
those of the revision store.</p>
<!-- vim: ft=rst tw=74 ai -->
</div>
</div>
</div>
</div>
</body>
</html>
