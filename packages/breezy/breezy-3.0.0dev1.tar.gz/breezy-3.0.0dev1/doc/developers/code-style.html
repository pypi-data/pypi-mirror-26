<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Bazaar Code Style Guide</title>
<link rel="stylesheet" href="../default.css" type="text/css" />
</head>
<body>
<div class="document" id="bazaar-code-style-guide">
<h1 class="title">Bazaar Code Style Guide</h1>

<div class="section" id="code-layout">
<h1>Code layout</h1>
<p>Please write <a class="reference external" href="http://www.python.org/peps/pep-0008.html">PEP-8</a> compliant code.</p>
<p>One often-missed requirement is that the first line of docstrings
should be a self-contained one-sentence summary.</p>
<p>We use 4 space indents for blocks, and never use tab characters.  (In vim,
<tt class="docutils literal">set expandtab</tt>.)</p>
<p>Trailing white space should be avoided, but is allowed.
You should however not make lots of unrelated white space changes.</p>
<p>Unix style newlines (LF) are used.</p>
<p>Each file must have a newline at the end of it.</p>
<p>Lines should be no more than 79 characters if at all possible.
Lines that continue a long statement may be indented in either of
two ways:</p>
<p>within the parenthesis or other character that opens the block, e.g.:</p>
<pre class="literal-block">
my_long_method(arg1,
               arg2,
               arg3)
</pre>
<p>or indented by four spaces:</p>
<pre class="literal-block">
my_long_method(arg1,
    arg2,
    arg3)
</pre>
<p>The first is considered clearer by some people; however it can be a bit
harder to maintain (e.g. when the method name changes), and it does not
work well if the relevant parenthesis is already far to the right.  Avoid
this:</p>
<pre class="literal-block">
self.legbone.kneebone.shinbone.toebone.shake_it(one,
                                                two,
                                                three)
</pre>
<p>but rather</p>
<pre class="literal-block">
self.legbone.kneebone.shinbone.toebone.shake_it(one,
    two,
    three)
</pre>
<p>or</p>
<pre class="literal-block">
self.legbone.kneebone.shinbone.toebone.shake_it(
    one, two, three)
</pre>
<p>For long lists, we like to add a trailing comma and put the closing
character on the following line.  This makes it easier to add new items in
future:</p>
<pre class="literal-block">
from bzrlib.goo import (
    jam,
    jelly,
    marmalade,
    )
</pre>
<p>There should be spaces between function parameters, but not between the
keyword name and the value:</p>
<pre class="literal-block">
call(1, 3, cheese=quark)
</pre>
</div>
<div class="section" id="python-versions">
<h1>Python versions</h1>
<p>Bazaar supports Python from 2.6 through 2.7, and in the future we want to
support Python 3.  Avoid using language features added in
2.7, or features deprecated in Python 3.0.  (You can check v3
compatibility using the <tt class="docutils literal"><span class="pre">-3</span></tt> option of Python2.6.)</p>
</div>
<div class="section" id="hasattr-and-getattr">
<h1>hasattr and getattr</h1>
<p><tt class="docutils literal">hasattr</tt> should not be used because it swallows exceptions including
<tt class="docutils literal">KeyboardInterrupt</tt>.  Instead, say something like</p>
<pre class="literal-block">
if getattr(thing, 'name', None) is None
</pre>
</div>
<div class="section" id="kwargs">
<h1>kwargs</h1>
<p><tt class="docutils literal">**kwargs</tt> in the prototype of a function should be used sparingly.
It can be good on higher-order functions that decorate other functions,
such as <tt class="docutils literal">addCleanup</tt> or <tt class="docutils literal">assertRaises</tt>, or on functions that take only
(or almost only) kwargs, where any kwargs can be passed.</p>
<p>Otherwise, be careful: if the parameters to a function are a bit complex
and might vary over time (e.g.  the <tt class="docutils literal">commit</tt> API) then we prefer to pass an
object rather than a bag of positional and/or keyword args.  If you have
an arbitrary set of keys and values that are different with each use (e.g.
string interpolation inputs) then again that should not be mixed in with
the regular positional/keyword args, it seems like a different category of
thing.</p>
</div>
<div class="section" id="imitating-standard-objects">
<h1>Imitating standard objects</h1>
<p>Don't provide methods that imitate built-in classes (eg <tt class="docutils literal">__in__</tt>,
<tt class="docutils literal">__call__</tt>, <tt class="docutils literal">__int__</tt>, <tt class="docutils literal">__getitem__</tt>) unless the class you're
implementing really does act like the builtin class, in semantics and
performance.</p>
<p>For example, old code lets you say <tt class="docutils literal">file_id in inv</tt> but we no longer
consider this good style.  Instead, say more explicitly
<tt class="docutils literal">inv.has_id(file_id)</tt>.</p>
<p><tt class="docutils literal">__repr__</tt>, <tt class="docutils literal">__cmp__</tt>, <tt class="docutils literal">__str__</tt> are usually fine.</p>
</div>
<div class="section" id="module-imports">
<h1>Module Imports</h1>
<ul class="simple">
<li>Imports should be done at the top-level of the file, unless there is
a strong reason to have them lazily loaded when a particular
function runs.  Import statements have a cost, so try to make sure
they don't run inside hot functions.</li>
<li>Module names should always be given fully-qualified,
i.e. <tt class="docutils literal">bzrlib.hashcache</tt> not just <tt class="docutils literal">hashcache</tt>.</li>
</ul>
</div>
<div class="section" id="naming">
<h1>Naming</h1>
<p>Functions, methods or members that are relatively private are given
a leading underscore prefix.  Names without a leading underscore are
public not just across modules but to programmers using bzrlib as an
API.</p>
<p>We prefer class names to be concatenated capital words (<tt class="docutils literal">TestCase</tt>)
and variables, methods and functions to be lowercase words joined by
underscores (<tt class="docutils literal">revision_id</tt>, <tt class="docutils literal">get_revision</tt>).</p>
<p>For the purposes of naming some names are treated as single compound
words: &quot;filename&quot;, &quot;revno&quot;.</p>
<p>Consider naming classes as nouns and functions/methods as verbs.</p>
<p>Try to avoid using abbreviations in names, because there can be
inconsistency if other people use the full name.</p>
</div>
<div class="section" id="standard-names">
<h1>Standard Names</h1>
<p><tt class="docutils literal">revision_id</tt> not <tt class="docutils literal">rev_id</tt> or <tt class="docutils literal">revid</tt></p>
<p>Functions that transform one thing to another should be named <tt class="docutils literal">x_to_y</tt>
(not <tt class="docutils literal">x2y</tt> as occurs in some old code.)</p>
</div>
<div class="section" id="destructors">
<h1>Destructors</h1>
<p>Python destructors (<tt class="docutils literal">__del__</tt>) work differently to those of other
languages.  In particular, bear in mind that destructors may be called
immediately when the object apparently becomes unreferenced, or at some
later time, or possibly never at all.  Therefore we have restrictions on
what can be done inside them.</p>
<ol class="arabic simple" start="0">
<li>If you think you need to use a <tt class="docutils literal">__del__</tt> method ask another
developer for alternatives.  If you do need to use one, explain
why in a comment.</li>
<li>Never rely on a <tt class="docutils literal">__del__</tt> method running.  If there is code that
must run, instead have a <tt class="docutils literal">finally</tt> block or an <tt class="docutils literal">addCleanup</tt> call an
explicit <tt class="docutils literal">close</tt> method.</li>
<li>Never <tt class="docutils literal">import</tt> from inside a <tt class="docutils literal">__del__</tt> method, or you may crash the
interpreter!!</li>
<li>Prior to bzr 2.4, we sometimes used to raise warnings from del methods
that the object was not cleaned up or closed.  We no longer do this:
failure to close the object doesn't cause a test failure; the warning
appears an arbitrary long time after the problem occurred (the object
being leaked); merely having a del method inhibits Python gc; the
warnings appear to users and upset them; they can also break tests that
are checking what appears on stderr.</li>
</ol>
<p>In short, just don't use <tt class="docutils literal">__del__</tt>.</p>
</div>
<div class="section" id="cleanup-methods">
<h1>Cleanup methods</h1>
<p>Often when something has failed later code will fail too, including
cleanups invoked from <tt class="docutils literal">finally</tt> blocks.  These secondary failures are
generally uninteresting compared to the original exception.  <tt class="docutils literal">bzrlib</tt>
has some facilities you can use to mitigate this.</p>
<ul>
<li><p class="first">In <tt class="docutils literal">Command</tt> subclasses, prefer the <tt class="docutils literal">add_cleanup</tt> method to using
<tt class="docutils literal">try</tt>/<tt class="docutils literal">finally</tt> blocks.  E.g. to acquire a lock and ensure it will
always be released when the command is done:</p>
<pre class="literal-block">
self.add_cleanup(branch.lock_read().unlock)
</pre>
<p>This also avoids heavily indented code. It also makes it easier to notice
mismatched lock/unlock pairs (and other kinds of resource
acquire/release) because there isn't a large block of code separating
them.</p>
</li>
<li><p class="first">Use the <tt class="docutils literal">only_raises</tt> decorator (from <tt class="docutils literal">bzrlib.decorators</tt>) when
defining methods that are typically called in <tt class="docutils literal">finally</tt> blocks, such
as <tt class="docutils literal">unlock</tt> methods.  For example, <tt class="docutils literal">&#64;only_raises(LockNotHeld,
LockBroken)</tt>.  All errors that are unlikely to be a knock-on failure
from a previous failure should be allowed.</p>
</li>
<li><p class="first">Consider using the <tt class="docutils literal">OperationWithCleanups</tt> helper from
<tt class="docutils literal">bzrlib.cleanup</tt> anywhere else you have a <tt class="docutils literal">finally</tt> block that
might fail.</p>
</li>
</ul>
</div>
<div class="section" id="factories">
<h1>Factories</h1>
<p>In some places we have variables which point to callables that construct
new instances.  That is to say, they can be used a lot like class objects,
but they shouldn't be <em>named</em> like classes.  Things called <tt class="docutils literal">FooBar</tt> should
create an instance of <tt class="docutils literal">FooBar</tt>.  A factory method that might create a
<tt class="docutils literal">FooBar</tt> or might make something else should be called <tt class="docutils literal">foo_factory</tt>.</p>
</div>
<div class="section" id="registries">
<h1>Registries</h1>
<p>Several places in Bazaar use (or will use) a registry, which is a
mapping from names to objects or classes.  The registry allows for
loading in registered code only when it's needed, and keeping
associated information such as a help string or description.</p>
</div>
<div class="section" id="interobject-and-multiple-dispatch">
<h1>InterObject and multiple dispatch</h1>
<p>The <tt class="docutils literal">InterObject</tt> provides for two-way <a class="reference external" href="http://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>: matching
up for example a source and destination repository to find the right way
to transfer data between them.</p>
<p>There is a subclass <tt class="docutils literal">InterObject</tt> classes for each type of object that is
dispatched this way, e.g. <tt class="docutils literal">InterRepository</tt>.  Calling <tt class="docutils literal">.get()</tt> on this
class will return an <tt class="docutils literal">InterObject</tt> instance providing the best match for
those parameters, and this instance then has methods for operations
between the objects.</p>
<pre class="literal-block">
inter = InterRepository.get(source_repo, target_repo)
inter.fetch(revision_id)
</pre>
<p><tt class="docutils literal">InterRepository</tt> also acts as a registry-like object for its
subclasses, and they can be added through <tt class="docutils literal">.register_optimizer</tt>.  The
right one to run is selected by asking each class, in reverse order of
registration, whether it <tt class="docutils literal">.is_compatible</tt> with the relevant objects.</p>
</div>
<div class="section" id="lazy-imports">
<h1>Lazy Imports</h1>
<p>To make startup time faster, we use the <tt class="docutils literal">bzrlib.lazy_import</tt> module to
delay importing modules until they are actually used. <tt class="docutils literal">lazy_import</tt> uses
the same syntax as regular python imports. So to import a few modules in a
lazy fashion do:</p>
<pre class="literal-block">
from bzrlib.lazy_import import lazy_import
lazy_import(globals(), &quot;&quot;&quot;
import os
import subprocess
import sys
import time

from bzrlib import (
   errors,
   transport,
   revision as _mod_revision,
   )
import bzrlib.transport
import bzrlib.xml5
&quot;&quot;&quot;)
</pre>
<p>At this point, all of these exist as a <tt class="docutils literal">ImportReplacer</tt> object, ready to
be imported once a member is accessed. Also, when importing a module into
the local namespace, which is likely to clash with variable names, it is
recommended to prefix it as <tt class="docutils literal">_mod_&lt;module&gt;</tt>. This makes it clearer that
the variable is a module, and these object should be hidden anyway, since
they shouldn't be imported into other namespaces.</p>
<p>While it is possible for <tt class="docutils literal">lazy_import()</tt> to import members of a module
when using the <tt class="docutils literal">from module import member</tt> syntax, it is recommended to
only use that syntax to load sub modules <tt class="docutils literal">from module import submodule</tt>.
This is because variables and classes can frequently be used without
needing a sub-member for example:</p>
<pre class="literal-block">
lazy_import(globals(), &quot;&quot;&quot;
from module import MyClass
&quot;&quot;&quot;)

def test(x):
    return isinstance(x, MyClass)
</pre>
<p>This will incorrectly fail, because <tt class="docutils literal">MyClass</tt> is a <tt class="docutils literal">ImportReplacer</tt>
object, rather than the real class.</p>
<p>It also is incorrect to assign <tt class="docutils literal">ImportReplacer</tt> objects to other variables.
Because the replacer only knows about the original name, it is unable to
replace other variables. The <tt class="docutils literal">ImportReplacer</tt> class will raise an
<tt class="docutils literal">IllegalUseOfScopeReplacer</tt> exception if it can figure out that this
happened. But it requires accessing a member more than once from the new
variable, so some bugs are not detected right away.</p>
</div>
<div class="section" id="the-null-revision">
<h1>The Null revision</h1>
<p>The null revision is the ancestor of all revisions.  Its revno is 0, its
revision-id is <tt class="docutils literal">null:</tt>, and its tree is the empty tree.  When referring
to the null revision, please use <tt class="docutils literal">bzrlib.revision.NULL_REVISION</tt>.  Old
code sometimes uses <tt class="docutils literal">None</tt> for the null revision, but this practice is
being phased out.</p>
</div>
<div class="section" id="object-string-representations">
<h1>Object string representations</h1>
<p>Python prints objects using their <tt class="docutils literal">__repr__</tt> method when they are
written to logs, exception tracebacks, or the debugger.  We want
objects to have useful representations to help in determining what went
wrong.</p>
<p>If you add a new class you should generally add a <tt class="docutils literal">__repr__</tt> method
unless there is an adequate method in a parent class.  There should be a
test for the repr.</p>
<p>Representations should typically look like Python constructor syntax, but
they don't need to include every value in the object and they don't need
to be able to actually execute.  They're to be read by humans, not
machines.  Don't hardcode the classname in the format, so that we get the
correct value if the method is inherited by a subclass.  If you're
printing attributes of the object, including strings, you should normally
use <tt class="docutils literal">%r</tt> syntax (to call their repr in turn).</p>
<p>Try to avoid the representation becoming more than one or two lines long.
(But balance this against including useful information, and simplicity of
implementation.)</p>
<p>Because repr methods are often called when something has already gone
wrong, they should be written somewhat more defensively than most code.
They shouldn't have side effects like doing network or disk
IO.
The object may be half-initialized or in some other way in an illegal
state.  The repr method shouldn't raise an exception, or it may hide the
(probably more useful) underlying exception.</p>
<p>Example:</p>
<pre class="literal-block">
def __repr__(self):
    return '%s(%r)' % (self.__class__.__name__,
                       self._transport)
</pre>
</div>
<div class="section" id="exception-handling">
<h1>Exception handling</h1>
<p>A bare <tt class="docutils literal">except</tt> statement will catch all exceptions, including ones that
really should terminate the program such as <tt class="docutils literal">MemoryError</tt> and
<tt class="docutils literal">KeyboardInterrupt</tt>.  They should rarely be used unless the exception is
later re-raised.  Even then, think about whether catching just
<tt class="docutils literal">Exception</tt> (which excludes system errors in Python2.5 and later) would
be better.</p>
<p>The <tt class="docutils literal">__str__</tt> method on exceptions should be small and have no side
effects, following the rules given for <a class="reference internal" href="#object-string-representations">Object string representations</a>.
In particular it should not do any network IO, or complicated
introspection of other objects.  All the state needed to present the
exception to the user should be gathered before the error is raised.
In other words, exceptions should basically be value objects.</p>
</div>
<div class="section" id="test-coverage">
<h1>Test coverage</h1>
<p>All code should be exercised by the test suite.  See the <a class="reference external" href="http://doc.bazaar.canonical.com/developers/testing.html">Bazaar Testing
Guide</a> for detailed
information about writing tests.</p>
</div>
<div class="section" id="assertions">
<h1>Assertions</h1>
<p>Do not use the Python <tt class="docutils literal">assert</tt> statement, either in tests or elsewhere.
A source test checks that it is not used.  It is ok to explicitly raise
AssertionError.</p>
<p>Rationale:</p>
<ul class="simple">
<li>It makes the behaviour vary depending on whether bzr is run with -O
or not, therefore giving a chance for bugs that occur in one case or
the other, several of which have already occurred: assertions with
side effects, code which can't continue unless the assertion passes,
cases where we should give the user a proper message rather than an
assertion failure.</li>
<li>It's not that much shorter than an explicit if/raise.</li>
<li>It tends to lead to fuzzy thinking about whether the check is
actually needed or not, and whether it's an internal error or not</li>
<li>It tends to cause look-before-you-leap patterns.</li>
<li>It's unsafe if the check is needed to protect the integrity of the
user's data.</li>
<li>It tends to give poor messages since the developer can get by with
no explanatory text at all.</li>
<li>We can't rely on people always running with -O in normal use, so we
can't use it for tests that are actually expensive.</li>
<li>Expensive checks that help developers are better turned on from the
test suite or a -D flag.</li>
<li>If used instead of <tt class="docutils literal"><span class="pre">self.assert*()</span></tt> in tests it makes them falsely
pass with -O.</li>
</ul>
</div>
<div class="section" id="emacs-setup">
<h1>emacs setup</h1>
<p>In emacs:</p>
<pre class="literal-block">
;(defface my-invalid-face
;  '((t (:background &quot;Red&quot; :underline t)))
;  &quot;Face used to highlight invalid constructs or other uglyties&quot;
;  )

(defun my-python-mode-hook ()
 ;; setup preferred indentation style.
 (setq fill-column 79)
 (setq indent-tabs-mode nil) ; no tabs, never, I will not repeat
;  (font-lock-add-keywords 'python-mode
;                         '((&quot;^\\s *\t&quot; . 'my-invalid-face) ; Leading tabs
;                            (&quot;[ \t]+$&quot; . 'my-invalid-face)  ; Trailing spaces
;                            (&quot;^[ \t]+$&quot; . 'my-invalid-face)); Spaces only
;                          )
 )

(add-hook 'python-mode-hook 'my-python-mode-hook)
</pre>
<p>The lines beginning with ';' are comments. They can be activated
if one want to have a strong notice of some tab/space usage
violations.</p>
</div>
<div class="section" id="portability-tips">
<h1>Portability Tips</h1>
<p>The <tt class="docutils literal">bzrlib.osutils</tt> module has many useful helper functions, including
some more portable variants of functions in the standard library.</p>
<p>In particular, don't use <tt class="docutils literal">shutil.rmtree</tt> unless it's acceptable for it
to fail on Windows if some files are readonly or still open elsewhere.
Use <tt class="docutils literal">bzrlib.osutils.rmtree</tt> instead.</p>
<p>Using the <tt class="docutils literal"><span class="pre">open(..).read(..)</span></tt> or <tt class="docutils literal"><span class="pre">open(..).write(..)</span></tt> style chaining
of methods for reading or writing file content relies on garbage collection
to close the file which may keep the file open for an undefined period of
time. This may break some follow up operations like rename on Windows.
Use <tt class="docutils literal">try/finally</tt> to explictly close the file. E.g.:</p>
<pre class="literal-block">
f = open('foo.txt', 'w')
try:
    f.write(s)
finally:
    f.close()
</pre>
</div>
<div class="section" id="dynamic-imports">
<h1>Dynamic imports</h1>
<p>If you need to import a module (or attribute of a module) named in a
variable:</p>
<blockquote>
<ul class="simple">
<li>If importing a module, not an attribute, and the module is a top-level
module (i.e. has no dots in the name), then it's ok to use the builtin
<tt class="docutils literal">__import__</tt>, e.g. <tt class="docutils literal">__import__(module_name)</tt>.</li>
<li>In all other cases, prefer <tt class="docutils literal">bzrlib.pyutils.get_named_object</tt> to the
built-in <tt class="docutils literal">__import__</tt>.  <tt class="docutils literal">__import__</tt> has some subtleties and
unintuitive behaviours that make it hard to use correctly.</li>
</ul>
</blockquote>
<!-- vim: ft=rst tw=74 ai -->
</div>
</div>
</body>
</html>
