<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Breezy Tutorial</title>
<link rel="stylesheet" href="../../default.css" type="text/css" />
</head>
<body>
<div class="document" id="breezy-tutorial">
<h1 class="title">Breezy Tutorial</h1>

<!-- This file is in Python ReStructuredText format - it can be formatted -->
<!-- into HTML or text.  In the future we plan to extract the example commands -->
<!-- and automatically test them. -->
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>If you are already familiar with decentralized version control, then
please feel free to skip ahead to &quot;Introducing Yourself to Breezy&quot;. If,
on the other hand, you are familiar with version control but not
decentralized version control, then please start at &quot;How DVCS is
different.&quot; Otherwise, get some coffee or tea, get comfortable and get
ready to catch up.</p>
</div>
<div class="section" id="the-purpose-of-version-control">
<h1>The purpose of version control</h1>
<p>Odds are that you have worked on some sort of textual data -- the sources
to a program, web sites or the config files that Unix system
administrators have to deal with in /etc. The chances are also good that
you have made some sort of mistake that you deeply regretted. Perhaps you
deleted the configuration file for your mailserver or perhaps mauled the
source code for a pet project. Whatever happened, you have just deleted
important information that you would desperately like to get back. If this
has ever happened to you, then you are probably ready for Breezy.</p>
<p>Version control systems (which I'll henceforth call VCS) such as
Breezy give you the ability to track changes for a directory by turning
it into something slightly more complicated than a directory that we call
a <strong>branch</strong>. The branch not only stores how the directory looks right
now, but also how it looked at various points in the past. Then, when you
do something you wish you hadn't, you can restore the directory to the way
it looked at some point in the past.</p>
<p>Version control systems give users the ability to save changes to a
branch by &quot;committing a <strong>revision</strong>&quot;. The revision created is essentially
a summary of the changes that were made since the last time the tree was
saved.</p>
<p>These revisions have other uses as well. For example, one can comment
revisions to record what the recent set of changes meant by providing an
optional log message. Real life log messages include things like &quot;Fixed
the web template to close the table&quot; and &quot;Added SFTP suppport. Fixes #595&quot;</p>
<p>We keep these logs so that if later there is some sort of problem with
SFTP, we can figure out when the problem probably happened.</p>
</div>
<div class="section" id="how-dvcs-is-different">
<h1>How DVCS is different</h1>
<p>Many Version Control Systems (VCS) are stored on servers. If one wants to
work on the code stored within a VCS, then one needs to connect to the
server and &quot;checkout&quot; the code. Doing so gives one a directory in which a
person can make changes and then commit. The VCS client then connects to
the VCS server and stores the changes. This method is known as the
centralized model.</p>
<p>The centralized model can have some drawbacks. A centralized VCS requires
that one is able to connect to the server whenever one wants to do version
control work. This can be a bit of a problem if your server is on some other
machine on the internet and you are not. Or, worse yet, you <strong>are</strong> on the
internet but the server is missing!</p>
<p>Decentralized Version Control Systems (which I'll call DVCS after this
point) deal with this problem by keeping branches on the same machine as
the client. In Breezy's case, the branch is kept in the same place as
the code that is being version controlled. This allows the user to save
his changes (<strong>commit</strong>) whenever he wants -- even if he is offline. The
user only needs internet access when he wants to access the changes in
someone else's branch that are somewhere else.</p>
<p>A common requirement that many people have is the need to keep track of
the changes for a directory such as file and subdirectory changes.
Performing this tracking by hand is a awkward process that over time
becomes unwieldy. That is, until one considers version control tools such
as Breezy. These tools automate the process of storing data by creating
a <strong>revision</strong> of the directory tree whenever the user asks.</p>
<p>Version control software such as Breezy can do much more than just
storage and performing undo.  For example, with Breezy a developer can
take the modifications in one branch of software and apply them to a
related branch -- even if those changes exist in a branch owned by
somebody else. This allows developers to cooperate without giving
write access to the repository.</p>
<p>Breezy remembers the ''ancestry'' of a revision: the previous revisions
that it is based upon.  A single revision may have more than one direct
descendant, each with different changes, representing a divergence in the
evolution of the tree. By branching, Breezy allows multiple people to
cooperate on the evolution of a project, without all needing to work in
strict lock-step.  Branching can be useful even for a single developer.</p>
</div>
<div class="section" id="introducing-yourself-to-breezy">
<h1>Introducing yourself to Breezy</h1>
<p>Breezy installs a single new command, <strong>brz</strong>.  Everything else is a
subcommand of this.  You can get some help with <tt class="docutils literal">brz help</tt>. Some arguments
are grouped in topics: <tt class="docutils literal">brz help topics</tt> to see which topics are available.</p>
<p>One function of a version control system is to keep track of who changed
what.  In a decentralized system, that requires an identifier for each
author that is globally unique.  Most people already have one of these: an
email address. Breezy is smart enough to automatically generate an email
address by looking up your username and hostname. If you don't like the
guess that Breezy makes, then three options exist:</p>
<ol class="arabic">
<li><p class="first">Set an email address via <tt class="docutils literal">brz whoami</tt>.  This is the simplest way.</p>
<p>To set a global identity, use:</p>
<pre class="literal-block">
% brz whoami &quot;Your Name &lt;email&#64;example.com&gt;&quot;
</pre>
<p>If you'd like to use a different address for a specific branch, enter
the branch folder and use:</p>
<pre class="literal-block">
% brz whoami --branch &quot;Your Name &lt;email&#64;example.com&gt;&quot;
</pre>
</li>
<li><p class="first">Setting the email address in the <tt class="docutils literal"><span class="pre">~/.config/breezy/breezy.conf</span></tt><a class="footnote-reference" href="#id2" id="id1"><sup>1</sup></a> by
adding the following lines.  Please note that  <tt class="docutils literal">[DEFAULT]</tt> is case
sensitive:</p>
<pre class="literal-block">
[DEFAULT]
email=Your Name &lt;email&#64;isp.com&gt;
</pre>
<p>As above, you can override this settings on a branch by branch basis
by creating a branch section in <tt class="docutils literal"><span class="pre">~/.config/breezy/locations.conf</span></tt> and
adding the following lines:</p>
<pre class="literal-block">
[/the/path/to/the/branch]
email=Your Name &lt;email&#64;isp.com&gt;
</pre>
</li>
<li><p class="first">Overriding the two previous options by setting the global environment
variable <tt class="docutils literal">$brz_EMAIL</tt> or <tt class="docutils literal">$EMAIL</tt> (<tt class="docutils literal">$brz_EMAIL</tt> will take
precedence) to your full email address.</p>
</li>
</ol>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> On Windows, the users configuration files can be found in the
application data directory. So instead of <tt class="docutils literal"><span class="pre">~/.config/breezy/breezy.conf</span></tt>
the configuration file can be found as:
<tt class="docutils literal"><span class="pre">C:\Documents</span> and <span class="pre">Settings\&lt;username&gt;\Application</span> Data\Breezy\2.0\breezy.conf</tt>.
The same is true for <tt class="docutils literal">locations.conf</tt>, <tt class="docutils literal">ignore</tt>, and the
<tt class="docutils literal">plugins</tt> directory.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="creating-a-branch">
<h1>Creating a branch</h1>
<p>History is by default stored in the .bzr directory of the branch. In a
future version of Breezy, there will be a facility to store it in a
separate repository, which may be remote.</p>
<p>We create a new branch by running <tt class="docutils literal">brz init</tt> in an existing directory:</p>
<pre class="literal-block">
% mkdir tutorial
% cd tutorial
% ls -a
./  ../
% pwd
/home/mbp/work/brz.test/tutorial
%
% brz init
% ls -aF
./  ../  .bzr/
%
</pre>
<p>As with CVS, there are three classes of file: unknown, ignored, and
versioned.  The <strong>add</strong> command makes a file versioned: that is, changes
to it will be recorded by the system:</p>
<pre class="literal-block">
% echo 'hello world' &gt; hello.txt
% brz status
unknown:
  hello.txt
% brz add hello.txt
added hello.txt
% brz status
added:
  hello.txt
</pre>
<p>If you add the wrong file, simply use <tt class="docutils literal">brz remove</tt> to make it
unversioned again.  This does not delete the working copy in this case,
though it may in others<a class="footnote-reference" href="#id4" id="id3"><sup>2</sup></a>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <tt class="docutils literal">brz remove</tt> will remove the working copy if it is currently
versioned, but has no changes from the last committed version.  You
can force the file to always be kept with the <tt class="docutils literal"><span class="pre">--keep</span></tt> option to
<tt class="docutils literal">brz remove</tt>, or force it to always be deleted with <tt class="docutils literal"><span class="pre">--force</span></tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="branch-locations">
<h1>Branch locations</h1>
<p>All history is stored in a branch, which is just an on-disk directory
containing control files.  By default there is no separate repository or
database as used in svn or svk. You can choose to create a repository if
you want to (see the <tt class="docutils literal">brz <span class="pre">init-repo</span></tt> command). You may wish to do this
if you have very large branches, or many branches of a moderately sized
project.</p>
<p>You'll usually refer to branches on your computer's filesystem just by
giving the name of the directory containing the branch.  brz also supports
accessing branches over SSH, HTTP and SFTP, amongst other things:</p>
<pre class="literal-block">
% brz log brz+ssh://code.launchpad.net/~brz/brz/brz.dev/
% brz log http://code.launchpad.net/~brz/brz/brz.dev/
% brz log sftp://code.launchpad.net/~brz/brz/brz.dev/
</pre>
<p>By installing brz plugins you can also access branches using the rsync
protocol.</p>
<p>See the <a class="reference internal" href="#publishing-your-branch">Publishing your branch</a> section for more about how to put your
branch at a given location.</p>
</div>
<div class="section" id="reviewing-changes">
<h1>Reviewing changes</h1>
<p>Once you have completed some work, you will want to <strong>commit</strong> it to the
version history.  It is good to commit fairly often: whenever you get a
new feature working, fix a bug, or improve some code or documentation.
It's also a good practice to make sure that the code compiles and passes
its test suite before committing, to make sure that every revision is a
known-good state.  You can also review your changes, to make sure you're
committing what you intend to, and as a chance to rethink your work before
you permanently record it.</p>
<p>Two brz commands are particularly useful here: <strong>status</strong> and <strong>diff</strong>.</p>
<div class="section" id="brz-status">
<h2>brz status</h2>
<p>The <strong>status</strong> command tells you what changes have been made to the
working directory since the last revision:</p>
<pre class="literal-block">
% brz status
modified:
   foo
</pre>
<p><tt class="docutils literal">brz status</tt> hides &quot;boring&quot; files that are either unchanged or ignored.
The status command can optionally be given the name of some files or
directories to check.</p>
</div>
<div class="section" id="brz-diff">
<h2>brz diff</h2>
<p>The <strong>diff</strong> command shows the full text of changes to all files as a
standard unified diff.  This can be piped through many programs such as
''patch'', ''diffstat'', ''filterdiff'' and ''colordiff'':</p>
<pre class="literal-block">
% brz diff
=== added file 'hello.txt'
--- hello.txt   1970-01-01 00:00:00 +0000
+++ hello.txt   2005-10-18 14:23:29 +0000
&#64;&#64; -0,0 +1,1 &#64;&#64;
+hello world
</pre>
<p>With the <tt class="docutils literal"><span class="pre">-r</span></tt> option, the tree is compared to an earlier revision, or
the differences between two versions are shown:</p>
<pre class="literal-block">
% brz diff -r 1000..          # everything since r1000
% brz diff -r 1000..1100      # changes from 1000 to 1100
</pre>
<p>The <tt class="docutils literal"><span class="pre">--diff-options</span></tt> option causes brz to run the external diff program,
passing options.  For example:</p>
<pre class="literal-block">
% brz diff --diff-options --side-by-side foo
</pre>
<p>Some projects prefer patches to show a prefix at the start of the path
for old and new files.  The <tt class="docutils literal"><span class="pre">--prefix</span></tt> option can be used to provide
such a prefix.
As a shortcut, <tt class="docutils literal">brz diff <span class="pre">-p1</span></tt> produces a form that works with the
command <tt class="docutils literal">patch <span class="pre">-p1</span></tt>.</p>
</div>
</div>
<div class="section" id="committing-changes">
<h1>Committing changes</h1>
<p>When the working tree state is satisfactory, it can be <strong>committed</strong> to
the branch, creating a new revision holding a snapshot of that state.</p>
<div class="section" id="brz-commit">
<h2>brz commit</h2>
<p>The <strong>commit</strong> command takes a message describing the changes in the
revision.  It also records your userid, the current time and timezone, and
the inventory and contents of the tree.  The commit message is specified
by the <tt class="docutils literal"><span class="pre">-m</span></tt> or <tt class="docutils literal"><span class="pre">--message</span></tt> option. You can enter a multi-line commit
message; in most shells you can enter this just by leaving the quotes open
at the end of the line.</p>
<pre class="literal-block">
% brz commit -m &quot;added my first file&quot;
</pre>
<p>You can also use the <tt class="docutils literal"><span class="pre">-F</span></tt> option to take the message from a file.  Some
people like to make notes for a commit message while they work, then
review the diff to make sure they did what they said they did.  (This file
can also be useful when you pick up your work after a break.)</p>
</div>
<div class="section" id="message-from-an-editor">
<h2>Message from an editor</h2>
<p>If you use neither the <tt class="docutils literal"><span class="pre">-m</span></tt> nor the <tt class="docutils literal"><span class="pre">-F</span></tt> option then brz will open an
editor for you to enter a message.  The editor to run is controlled by
your <tt class="docutils literal">$VISUAL</tt> or <tt class="docutils literal">$EDITOR</tt> environment variable, which can be overridden
by the <tt class="docutils literal">editor</tt> setting in <tt class="docutils literal"><span class="pre">~/.config/breezy/breezy.conf</span></tt>; <tt class="docutils literal">$BRZ_EDITOR</tt>
will override either of the above mentioned editor options.  If you quit the
editor without making any changes, the commit will be cancelled.</p>
<p>The file that is opened in the editor contains a horizontal line. The part
of the file below this line is included for information only, and will not
form part of the commit message. Below the separator is shown the list of
files that are changed in the commit. You should write your message above
the line, and then save the file and exit.</p>
<p>If you would like to see the diff that will be committed as you edit the
message you can use the <tt class="docutils literal"><span class="pre">--show-diff</span></tt> option to <tt class="docutils literal">commit</tt>. This will include
the diff in the editor when it is opened, below the separator and the
information about the files that will be committed. This means that you can
read it as you write the message, but the diff itself wont be seen in the
commit message when you have finished. If you would like parts to be
included in the message you can copy and paste them above the separator.</p>
</div>
<div class="section" id="marking-bugs-as-fixed">
<h2>Marking bugs as fixed</h2>
<p>Many changes to a project are as a result of fixing bugs. Breezy can keep
metadata about bugs you fixed when you commit them. To do this you use the
<tt class="docutils literal"><span class="pre">--fixes</span></tt> option. This option takes an argument that looks like this:</p>
<pre class="literal-block">
% brz commit --fixes &lt;tracker&gt;:&lt;id&gt;
</pre>
<p>Where <tt class="docutils literal">&lt;tracker&gt;</tt> is an identifier for a bug tracker and <tt class="docutils literal">&lt;id&gt;</tt> is an
identifier for a bug that is tracked in that bug tracker. <tt class="docutils literal">&lt;id&gt;</tt> is usually
a number. Breezy already knows about a few popular bug trackers. They are
bugs.launchpad.net, bugs.debian.org, and bugzilla.gnome.org. These trackers
have their own identifiers: lp, deb, and gnome respectively. For example,
if you made a change to fix the bug #1234 on bugs.launchpad.net, you would
use the following command to commit your fix:</p>
<pre class="literal-block">
% brz commit -m &quot;fixed my first bug&quot; --fixes lp:1234
</pre>
<p>For more information on this topic or for information on how to configure
other bug trackers please read <a class="reference external" href="../user-reference/index.html#bug-tracker-settings">Bug Tracker Settings</a>.</p>
</div>
<div class="section" id="selective-commit">
<h2>Selective commit</h2>
<p>If you give file or directory names on the commit command line then only
the changes to those files will be committed.  For example:</p>
<pre class="literal-block">
% brz commit -m &quot;documentation fix&quot; commit.py
</pre>
<p>By default brz always commits all changes to the tree, even if run from a
subdirectory.  To commit from only the current directory down, use:</p>
<pre class="literal-block">
% brz commit .
</pre>
</div>
</div>
<div class="section" id="removing-uncommitted-changes">
<h1>Removing uncommitted changes</h1>
<p>If you've made some changes and don't want to keep them, use the
<strong>revert</strong> command to go back to the previous head version.  It's a good
idea to use <tt class="docutils literal">brz diff</tt> first to see what will be removed. By default the
revert command reverts the whole tree; if file or directory names are
given then only those ones will be affected. <tt class="docutils literal">brz revert</tt> also clears the
list of pending merges revisions.</p>
</div>
<div class="section" id="ignoring-files">
<h1>Ignoring files</h1>
<div class="section" id="the-bzrignore-file">
<h2>The .bzrignore file</h2>
<p>Many source trees contain some files that do not need to be versioned,
such as editor backups, object or bytecode files, and built programs.  You
can simply not add them, but then they'll always crop up as unknown files.
You can also tell brz to ignore these files by adding them to a file
called <tt class="docutils literal">.bzrignore</tt> at the top of the tree.</p>
<p>This file contains a list of file wildcards (or &quot;globs&quot;), one per line.
Typical contents are like this:</p>
<pre class="literal-block">
*.o
*~
*.tmp
*.py[co]
</pre>
<p>If a glob contains a slash, it is matched against the whole path from the
top of the tree; otherwise it is matched against only the filename.  So
the previous example ignores files with extension <tt class="docutils literal">.o</tt> in all
subdirectories, but this example ignores only <tt class="docutils literal">config.h</tt> at the top level
and HTML files in <tt class="docutils literal">doc/</tt>:</p>
<pre class="literal-block">
./config.h
doc/*.html
</pre>
<p>To get a list of which files are ignored and what pattern they matched,
use <tt class="docutils literal">brz ignored</tt>:</p>
<pre class="literal-block">
% brz ignored
config.h                 ./config.h
configure.in~            *~
</pre>
<p>It is OK to have either an ignore pattern match a versioned file, or to
add an ignored file.  Ignore patterns have no effect on versioned files;
they only determine whether unversioned files are reported as unknown or
ignored.</p>
<p>The <tt class="docutils literal">.bzrignore</tt> file should normally be versioned, so that new copies
of the branch see the same patterns:</p>
<pre class="literal-block">
% brz add .bzrignore
% brz commit -m &quot;Add ignore patterns&quot;
</pre>
</div>
<div class="section" id="brz-ignore">
<h2>brz ignore</h2>
<p>As an alternative to editing the <tt class="docutils literal">.bzrignore</tt> file, you can use the
<tt class="docutils literal">brz ignore</tt> command. The <tt class="docutils literal">brz ignore</tt> command takes filenames and/or
patterns as arguments and then adds them to the <tt class="docutils literal">.bzrignore</tt> file. If a
<tt class="docutils literal">.bzrignore</tt> file does not exist the <tt class="docutils literal">brz ignore</tt> command will
automatically create one for you, and implicitly add it to be versioned:</p>
<pre class="literal-block">
% brz ignore tags
% brz status
added:
  .bzrignore
</pre>
<p>Just like when editing the <tt class="docutils literal">.bzrignore</tt> file on your own, you should
commit the automatically created <tt class="docutils literal">.bzrignore</tt> file:</p>
<pre class="literal-block">
% brz commit -m &quot;Added tags to ignore file&quot;
</pre>
</div>
<div class="section" id="global-ignores">
<h2>Global ignores</h2>
<p>There are some ignored files which are not project specific, but more user
specific. Things like editor temporary files, or personal temporary files.
Rather than add these ignores to every project, brz supports a global
ignore file in <tt class="docutils literal"><span class="pre">~/.config/breezy/ignore</span></tt><a class="footnote-reference" href="#id2" id="id5"><sup>1</sup></a>. It has the same syntax as the
per-project ignore file.</p>
</div>
</div>
<div class="section" id="examining-history">
<h1>Examining history</h1>
<div class="section" id="brz-log">
<h2>brz log</h2>
<p>The <tt class="docutils literal">brz log</tt> command shows a list of previous revisions. The <tt class="docutils literal">brz log
<span class="pre">--forward</span></tt> command does the same in chronological order to get most
recent revisions printed at last.</p>
<p>As with <tt class="docutils literal">brz diff</tt>, <tt class="docutils literal">brz log</tt> supports the <tt class="docutils literal"><span class="pre">-r</span></tt> argument:</p>
<pre class="literal-block">
% brz log -r 1000..          # Revision 1000 and everything after it
% brz log -r ..1000          # Everything up to and including r1000
% brz log -r 1000..1100      # changes from 1000 to 1100
% brz log -r 1000            # The changes in only revision 1000
</pre>
</div>
</div>
<div class="section" id="branch-statistics">
<h1>Branch statistics</h1>
<p>The <tt class="docutils literal">brz info</tt> command shows some summary information about the working
tree and the branch history.</p>
</div>
<div class="section" id="versioning-directories">
<h1>Versioning directories</h1>
<p>brz versions files and directories in a way that can keep track of renames
and intelligently merge them:</p>
<pre class="literal-block">
% mkdir src
% echo 'int main() {}' &gt; src/simple.c
% brz add src
added src
added src/simple.c
% brz status
added:
  src/
  src/simple.c
</pre>
</div>
<div class="section" id="deleting-and-removing-files">
<h1>Deleting and removing files</h1>
<p>You can delete files or directories by just deleting them from the working
directory.  This is a bit different to CVS, which requires that you also
do <tt class="docutils literal">cvs remove</tt>.</p>
<p><tt class="docutils literal">brz remove</tt> makes the file un-versioned, but may or may not delete the
working copy<a class="footnote-reference" href="#id4" id="id6"><sup>2</sup></a>.  This is useful when you add the wrong file, or decide that
a file should actually not be versioned.</p>
<pre class="literal-block">
% rm -r src
% brz remove -v hello.txt
?       hello.txt
% brz status
removed:
  hello.txt
  src/
  src/simple.c
unknown:
  hello.txt
</pre>
<p>If you remove the wrong file by accident, you can use <tt class="docutils literal">brz revert</tt> to
restore it.</p>
</div>
<div class="section" id="branching">
<h1>Branching</h1>
<p>Often rather than starting your own project, you will want to submit a
change to an existing project.  To do this, you'll need to get a copy of
the existing branch.  Because this new copy is potentially a new branch,
the command is called <strong>branch</strong>:</p>
<pre class="literal-block">
% brz branch lp:brz brz.dev
% cd brz.dev
</pre>
<p>This copies down the complete history of this branch, so we can do all
operations on it locally: log, annotate, making and merging branches.
There will be an option to get only part of the history if you wish.</p>
<p>You can also get a copy of an existing branch by copying its directory,
expanding a tarball, or by a remote copy using something like rsync.</p>
</div>
<div class="section" id="following-upstream-changes">
<h1>Following upstream changes</h1>
<p>You can stay up-to-date with the parent branch by &quot;pulling&quot; in their
changes:</p>
<pre class="literal-block">
% brz pull
</pre>
<p>After this change, the local directory will be a mirror of the source. This
includes the ''revision-history'' - which is a list of the commits done in
this branch, rather than merged from other branches.</p>
<p>This command only works if your local (destination) branch is either an
older copy of the parent branch with no new commits of its own, or if the
most recent commit in your local branch has been merged into the parent
branch.</p>
</div>
<div class="section" id="merging-from-related-branches">
<h1>Merging from related branches</h1>
<p>If two branches have diverged (both have unique changes) then <tt class="docutils literal">brz
merge</tt> is the appropriate command to use. Merge will automatically
calculate the changes that exist in the branch you're merging from that
are not in your branch and attempt to apply them in your branch.</p>
<pre class="literal-block">
% brz merge URL
</pre>
<p>If there is a conflict during a merge, 3 files with the same basename
are created. The filename of the common base is appended with &quot;.BASE&quot;,
the filename of the file containing your changes is appended with
&quot;.THIS&quot; and the filename with the changes from the other tree is
appended with &quot;.OTHER&quot;.  Using a program such as kdiff3, you can now
comfortably merge them into one file.  In order to commit you have to
rename the merged file (&quot;.THIS&quot;) to the original file name.  To
complete the conflict resolution you must use the resolve command,
which will remove the &quot;.OTHER&quot; and &quot;.BASE&quot; files.  As long as there
exist files with .BASE, .THIS or .OTHER the commit command will
report an error.</p>
<pre class="literal-block">
% kdiff3 file.BASE file.OTHER file.THIS
% mv file.THIS file
% brz resolve file
</pre>
<p>[<strong>TODO</strong>: explain conflict markers within files]</p>
</div>
<div class="section" id="publishing-your-branch">
<h1>Publishing your branch</h1>
<p>You don't need a special server to publish a brz branch, just a normal web
server.  Just mirror the files to your server, including the .bzr
directory.  One can push a branch (or the changes for a branch) by one of
the following three methods:</p>
<ul>
<li><p class="first">The best method is to use brz itself to do it.</p>
<pre class="literal-block">
% brz push brz+ssh://servername.com/path/to/directory
</pre>
<p>(The destination directory must already exist unless the
<tt class="docutils literal"><span class="pre">--create-prefix</span></tt> option is used.)</p>
</li>
<li><p class="first">Another option is the <tt class="docutils literal">rspush</tt> plugin that comes with brzTools, which
uses rsync to push the changes to the revision history and the working
tree.</p>
</li>
<li><p class="first">You can also copy the files around manually, by sending a tarball, or using
rsync, or other related file transfer methods.  This is usually less safe
than using <tt class="docutils literal">push</tt>, but may be faster or easier in some situations.</p>
</li>
</ul>
</div>
<div class="section" id="moving-changes-between-trees">
<h1>Moving changes between trees</h1>
<p>It happens to the best of us: sometimes you'll make changes in the wrong
tree.  Maybe because you've accidentally started work in the wrong directory,
maybe because as you're working, the change turns out to be bigger than you
expected, so you start a new branch for it.</p>
<p>To move your changes from one tree to another, use</p>
<pre class="literal-block">
% cd NEWDIR
% brz merge --uncommitted OLDDIR
</pre>
<p>This will apply all of the uncommitted changes you made in OLDDIR to NEWDIR.
It will not apply committed changes, even if they could be applied to NEWDIR
with a regular merge.  The changes will remain in OLDDIR, but you can use <tt class="docutils literal">brz
revert OLDDIR</tt> to remove them, once you're satisfied with NEWDIR.</p>
<p>NEWDIR does not have to be a copy of OLDDIR, but they should be related.
The more different they are, the greater the chance of conflicts.</p>
</div>
</div>
</body>
</html>
