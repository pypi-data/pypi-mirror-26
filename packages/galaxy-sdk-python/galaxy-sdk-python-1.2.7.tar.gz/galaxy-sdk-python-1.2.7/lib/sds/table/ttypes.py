# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import sds.errors.ttypes
import sds.common.ttypes
import sds.auth.ttypes
import rpc.authorization.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class DataType(object):
  """
  数据类型
  """
  BOOL = 1
  INT8 = 2
  INT16 = 3
  INT32 = 4
  INT64 = 5
  FLOAT = 6
  DOUBLE = 7
  STRING = 8
  BINARY = 9
  RAWBINARY = 10
  BOOL_SET = 100
  INT8_SET = 101
  INT16_SET = 102
  INT32_SET = 103
  INT64_SET = 104
  FLOAT_SET = 105
  DOUBLE_SET = 106
  STRING_SET = 107
  BINARY_SET = 108

  _VALUES_TO_NAMES = {
    1: "BOOL",
    2: "INT8",
    3: "INT16",
    4: "INT32",
    5: "INT64",
    6: "FLOAT",
    7: "DOUBLE",
    8: "STRING",
    9: "BINARY",
    10: "RAWBINARY",
    100: "BOOL_SET",
    101: "INT8_SET",
    102: "INT16_SET",
    103: "INT32_SET",
    104: "INT64_SET",
    105: "FLOAT_SET",
    106: "DOUBLE_SET",
    107: "STRING_SET",
    108: "BINARY_SET",
  }

  _NAMES_TO_VALUES = {
    "BOOL": 1,
    "INT8": 2,
    "INT16": 3,
    "INT32": 4,
    "INT64": 5,
    "FLOAT": 6,
    "DOUBLE": 7,
    "STRING": 8,
    "BINARY": 9,
    "RAWBINARY": 10,
    "BOOL_SET": 100,
    "INT8_SET": 101,
    "INT16_SET": 102,
    "INT32_SET": 103,
    "INT64_SET": 104,
    "FLOAT_SET": 105,
    "DOUBLE_SET": 106,
    "STRING_SET": 107,
    "BINARY_SET": 108,
  }

class OperatorType(object):
  """
  操作符类型
  """
  EQUAL = 1
  NOT_EQUAL = 2
  GREATER = 3
  GREATER_OR_EQUAL = 4
  LESS = 5
  LESS_OR_EQUAL = 6

  _VALUES_TO_NAMES = {
    1: "EQUAL",
    2: "NOT_EQUAL",
    3: "GREATER",
    4: "GREATER_OR_EQUAL",
    5: "LESS",
    6: "LESS_OR_EQUAL",
  }

  _NAMES_TO_VALUES = {
    "EQUAL": 1,
    "NOT_EQUAL": 2,
    "GREATER": 3,
    "GREATER_OR_EQUAL": 4,
    "LESS": 5,
    "LESS_OR_EQUAL": 6,
  }

class SecondaryIndexConsistencyMode(object):
  """
  索引数据一致性类型
  """
  LAZY = 0
  EAGER = 1
  IMMUTABLE = 2

  _VALUES_TO_NAMES = {
    0: "LAZY",
    1: "EAGER",
    2: "IMMUTABLE",
  }

  _NAMES_TO_VALUES = {
    "LAZY": 0,
    "EAGER": 1,
    "IMMUTABLE": 2,
  }

class CannedAcl(object):
  """
  ACL模板，针对每个应用进行设置，
  开发者登录可以访问所拥有的表数据，无需额外设置
  """
  APP_SECRET_READ = 1
  APP_SECRET_WRITE = 2
  APP_USER_ENTITY_GROUP_READ = 3
  APP_USER_ENTITY_GROUP_WRITE = 4
  APP_USER_READ = 5
  APP_USER_WRITE = 6
  PUBLIC_READ = 7
  PUBLIC_WRITE = 8

  _VALUES_TO_NAMES = {
    1: "APP_SECRET_READ",
    2: "APP_SECRET_WRITE",
    3: "APP_USER_ENTITY_GROUP_READ",
    4: "APP_USER_ENTITY_GROUP_WRITE",
    5: "APP_USER_READ",
    6: "APP_USER_WRITE",
    7: "PUBLIC_READ",
    8: "PUBLIC_WRITE",
  }

  _NAMES_TO_VALUES = {
    "APP_SECRET_READ": 1,
    "APP_SECRET_WRITE": 2,
    "APP_USER_ENTITY_GROUP_READ": 3,
    "APP_USER_ENTITY_GROUP_WRITE": 4,
    "APP_USER_READ": 5,
    "APP_USER_WRITE": 6,
    "PUBLIC_READ": 7,
    "PUBLIC_WRITE": 8,
  }

class Permission(object):
  READ = 1
  WRITE = 2
  ADMIN = 3

  _VALUES_TO_NAMES = {
    1: "READ",
    2: "WRITE",
    3: "ADMIN",
  }

  _NAMES_TO_VALUES = {
    "READ": 1,
    "WRITE": 2,
    "ADMIN": 3,
  }

class ConsistencyLevel(object):
  """
  数据一致性级别
  """
  STRONG = 0
  EVENTUAL = 1
  WEAK = 2

  _VALUES_TO_NAMES = {
    0: "STRONG",
    1: "EVENTUAL",
    2: "WEAK",
  }

  _NAMES_TO_VALUES = {
    "STRONG": 0,
    "EVENTUAL": 1,
    "WEAK": 2,
  }

class StreamViewType(object):
  """
  stream view type
  """
  RECORD_IMAGE = 1
  MUTATE_LOG = 2
  KEYS_ONLY = 3

  _VALUES_TO_NAMES = {
    1: "RECORD_IMAGE",
    2: "MUTATE_LOG",
    3: "KEYS_ONLY",
  }

  _NAMES_TO_VALUES = {
    "RECORD_IMAGE": 1,
    "MUTATE_LOG": 2,
    "KEYS_ONLY": 3,
  }

class TableState(object):
  """
  表状态
  """
  CREATING = 1
  ENABLING = 2
  ENABLED = 3
  DISABLING = 4
  DISABLED = 5
  DELETING = 6
  DELETED = 7
  LAZY_DELETE = 8
  RENAMING = 9
  RECOVERING = 10

  _VALUES_TO_NAMES = {
    1: "CREATING",
    2: "ENABLING",
    3: "ENABLED",
    4: "DISABLING",
    5: "DISABLED",
    6: "DELETING",
    7: "DELETED",
    8: "LAZY_DELETE",
    9: "RENAMING",
    10: "RECOVERING",
  }

  _NAMES_TO_VALUES = {
    "CREATING": 1,
    "ENABLING": 2,
    "ENABLED": 3,
    "DISABLING": 4,
    "DISABLED": 5,
    "DELETING": 6,
    "DELETED": 7,
    "LAZY_DELETE": 8,
    "RENAMING": 9,
    "RECOVERING": 10,
  }

class SnapshotState(object):
  """
  快照状态
  """
  ENABLED = 1
  INPROGRESS = 2

  _VALUES_TO_NAMES = {
    1: "ENABLED",
    2: "INPROGRESS",
  }

  _NAMES_TO_VALUES = {
    "ENABLED": 1,
    "INPROGRESS": 2,
  }

class ScanOp(object):
  COUNT = 0
  DELETE = 1
  UPDATE = 2

  _VALUES_TO_NAMES = {
    0: "COUNT",
    1: "DELETE",
    2: "UPDATE",
  }

  _NAMES_TO_VALUES = {
    "COUNT": 0,
    "DELETE": 1,
    "UPDATE": 2,
  }

class BatchOp(object):
  GET = 1
  PUT = 2
  INCREMENT = 3
  REMOVE = 4

  _VALUES_TO_NAMES = {
    1: "GET",
    2: "PUT",
    3: "INCREMENT",
    4: "REMOVE",
  }

  _NAMES_TO_VALUES = {
    "GET": 1,
    "PUT": 2,
    "INCREMENT": 3,
    "REMOVE": 4,
  }

class MutationType(object):
  """
  mutation type
  """
  PUT = 1
  DELETE = 2
  INCREMENT = 3

  _VALUES_TO_NAMES = {
    1: "PUT",
    2: "DELETE",
    3: "INCREMENT",
  }

  _NAMES_TO_VALUES = {
    "PUT": 1,
    "DELETE": 2,
    "INCREMENT": 3,
  }


class Value(object):
  """
  数据值union类型

  Attributes:
   - boolValue
   - int8Value
   - int16Value
   - int32Value
   - int64Value
   - doubleValue: 用于FLOAT/DOUBLE类型
   - stringValue
   - binaryValue: 用于BINARY/RAWBINARY类型
   - boolSetValue
   - int8SetValue
   - int16SetValue
   - int32SetValue
   - int64SetValue
   - doubleSetValue: 用于FLOAT/DOUBLE类型集合
   - stringSetValue
   - binarySetValue
   - nullValue: null，只用于RC_BASIC存储格式
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'boolValue', None, None, ), # 1
    (2, TType.BYTE, 'int8Value', None, None, ), # 2
    (3, TType.I16, 'int16Value', None, None, ), # 3
    (4, TType.I32, 'int32Value', None, None, ), # 4
    (5, TType.I64, 'int64Value', None, None, ), # 5
    (6, TType.DOUBLE, 'doubleValue', None, None, ), # 6
    (7, TType.STRING, 'stringValue', None, None, ), # 7
    (8, TType.STRING, 'binaryValue', None, None, ), # 8
    (9, TType.LIST, 'boolSetValue', (TType.BOOL,None), None, ), # 9
    (10, TType.LIST, 'int8SetValue', (TType.BYTE,None), None, ), # 10
    (11, TType.LIST, 'int16SetValue', (TType.I16,None), None, ), # 11
    (12, TType.LIST, 'int32SetValue', (TType.I32,None), None, ), # 12
    (13, TType.LIST, 'int64SetValue', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'doubleSetValue', (TType.DOUBLE,None), None, ), # 14
    (15, TType.LIST, 'stringSetValue', (TType.STRING,None), None, ), # 15
    (16, TType.LIST, 'binarySetValue', (TType.STRING,None), None, ), # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'nullValue', None, None, ), # 20
  )

  def __init__(self, boolValue=None, int8Value=None, int16Value=None, int32Value=None, int64Value=None, doubleValue=None, stringValue=None, binaryValue=None, boolSetValue=None, int8SetValue=None, int16SetValue=None, int32SetValue=None, int64SetValue=None, doubleSetValue=None, stringSetValue=None, binarySetValue=None, nullValue=None,):
    self.boolValue = boolValue
    self.int8Value = int8Value
    self.int16Value = int16Value
    self.int32Value = int32Value
    self.int64Value = int64Value
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.binaryValue = binaryValue
    self.boolSetValue = boolSetValue
    self.int8SetValue = int8SetValue
    self.int16SetValue = int16SetValue
    self.int32SetValue = int32SetValue
    self.int64SetValue = int64SetValue
    self.doubleSetValue = doubleSetValue
    self.stringSetValue = stringSetValue
    self.binarySetValue = binarySetValue
    self.nullValue = nullValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.boolValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int8Value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.int16Value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int32Value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.int64Value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.boolSetValue = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readBool();
            self.boolSetValue.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.int8SetValue = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readByte();
            self.int8SetValue.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.int16SetValue = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI16();
            self.int16SetValue.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.int32SetValue = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readI32();
            self.int32SetValue.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.int64SetValue = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readI64();
            self.int64SetValue.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.doubleSetValue = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readDouble();
            self.doubleSetValue.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.stringSetValue = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.stringSetValue.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.binarySetValue = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.binarySetValue.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.nullValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Value')
    if self.boolValue is not None:
      oprot.writeFieldBegin('boolValue', TType.BOOL, 1)
      oprot.writeBool(self.boolValue)
      oprot.writeFieldEnd()
    if self.int8Value is not None:
      oprot.writeFieldBegin('int8Value', TType.BYTE, 2)
      oprot.writeByte(self.int8Value)
      oprot.writeFieldEnd()
    if self.int16Value is not None:
      oprot.writeFieldBegin('int16Value', TType.I16, 3)
      oprot.writeI16(self.int16Value)
      oprot.writeFieldEnd()
    if self.int32Value is not None:
      oprot.writeFieldBegin('int32Value', TType.I32, 4)
      oprot.writeI32(self.int32Value)
      oprot.writeFieldEnd()
    if self.int64Value is not None:
      oprot.writeFieldBegin('int64Value', TType.I64, 5)
      oprot.writeI64(self.int64Value)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 6)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 7)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 8)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    if self.boolSetValue is not None:
      oprot.writeFieldBegin('boolSetValue', TType.LIST, 9)
      oprot.writeListBegin(TType.BOOL, len(self.boolSetValue))
      for iter48 in self.boolSetValue:
        oprot.writeBool(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int8SetValue is not None:
      oprot.writeFieldBegin('int8SetValue', TType.LIST, 10)
      oprot.writeListBegin(TType.BYTE, len(self.int8SetValue))
      for iter49 in self.int8SetValue:
        oprot.writeByte(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int16SetValue is not None:
      oprot.writeFieldBegin('int16SetValue', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.int16SetValue))
      for iter50 in self.int16SetValue:
        oprot.writeI16(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int32SetValue is not None:
      oprot.writeFieldBegin('int32SetValue', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.int32SetValue))
      for iter51 in self.int32SetValue:
        oprot.writeI32(iter51)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int64SetValue is not None:
      oprot.writeFieldBegin('int64SetValue', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.int64SetValue))
      for iter52 in self.int64SetValue:
        oprot.writeI64(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleSetValue is not None:
      oprot.writeFieldBegin('doubleSetValue', TType.LIST, 14)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleSetValue))
      for iter53 in self.doubleSetValue:
        oprot.writeDouble(iter53)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringSetValue is not None:
      oprot.writeFieldBegin('stringSetValue', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.stringSetValue))
      for iter54 in self.stringSetValue:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binarySetValue is not None:
      oprot.writeFieldBegin('binarySetValue', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.binarySetValue))
      for iter55 in self.binarySetValue:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullValue is not None:
      oprot.writeFieldBegin('nullValue', TType.BOOL, 20)
      oprot.writeBool(self.nullValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.boolValue)
    value = (value * 31) ^ hash(self.int8Value)
    value = (value * 31) ^ hash(self.int16Value)
    value = (value * 31) ^ hash(self.int32Value)
    value = (value * 31) ^ hash(self.int64Value)
    value = (value * 31) ^ hash(self.doubleValue)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.binaryValue)
    value = (value * 31) ^ hash(self.boolSetValue)
    value = (value * 31) ^ hash(self.int8SetValue)
    value = (value * 31) ^ hash(self.int16SetValue)
    value = (value * 31) ^ hash(self.int32SetValue)
    value = (value * 31) ^ hash(self.int64SetValue)
    value = (value * 31) ^ hash(self.doubleSetValue)
    value = (value * 31) ^ hash(self.stringSetValue)
    value = (value * 31) ^ hash(self.binarySetValue)
    value = (value * 31) ^ hash(self.nullValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Datum(object):
  """
  数据单元

  Attributes:
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'value', (Value, Value.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, value=None,):
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Datum')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvisionThroughput(object):
  """
  吞吐量配额

  Attributes:
   - readCapacity
   - writeCapacity
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'readCapacity', None, None, ), # 1
    (2, TType.I64, 'writeCapacity', None, None, ), # 2
  )

  def __init__(self, readCapacity=None, writeCapacity=None,):
    self.readCapacity = readCapacity
    self.writeCapacity = writeCapacity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.readCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvisionThroughput')
    if self.readCapacity is not None:
      oprot.writeFieldBegin('readCapacity', TType.I64, 1)
      oprot.writeI64(self.readCapacity)
      oprot.writeFieldEnd()
    if self.writeCapacity is not None:
      oprot.writeFieldBegin('writeCapacity', TType.I64, 2)
      oprot.writeI64(self.writeCapacity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.readCapacity)
    value = (value * 31) ^ hash(self.writeCapacity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableQuota(object):
  """
  空间配额

  Attributes:
   - size: 空间配额，单位为字节
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'size', None, None, ), # 1
  )

  def __init__(self, size=None,):
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableQuota')
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 1)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeySpec(object):
  """
  Attributes:
   - attribute
   - asc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'attribute', None, None, ), # 1
    (2, TType.BOOL, 'asc', None, True, ), # 2
  )

  def __init__(self, attribute=None, asc=thrift_spec[2][4],):
    self.attribute = attribute
    self.asc = asc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.attribute = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.asc = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeySpec')
    if self.attribute is not None:
      oprot.writeFieldBegin('attribute', TType.STRING, 1)
      oprot.writeString(self.attribute)
      oprot.writeFieldEnd()
    if self.asc is not None:
      oprot.writeFieldBegin('asc', TType.BOOL, 2)
      oprot.writeBool(self.asc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attribute)
    value = (value * 31) ^ hash(self.asc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LocalSecondaryIndexSpec(object):
  """
  局部二级索引定义

  Attributes:
   - indexSchema: 索引定义
   - projections: 映射的属性，仅当索引类型为Eager时才可设置
   - consistencyMode: 索引数据一致性模式
   - unique: 是否为唯一索引
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'indexSchema', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'projections', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'consistencyMode', None,     0, ), # 3
    (4, TType.BOOL, 'unique', None, False, ), # 4
  )

  def __init__(self, indexSchema=None, projections=None, consistencyMode=thrift_spec[3][4], unique=thrift_spec[4][4],):
    self.indexSchema = indexSchema
    self.projections = projections
    self.consistencyMode = consistencyMode
    self.unique = unique

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.indexSchema = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = KeySpec()
            _elem61.read(iprot)
            self.indexSchema.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.projections = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.projections.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.consistencyMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.unique = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocalSecondaryIndexSpec')
    if self.indexSchema is not None:
      oprot.writeFieldBegin('indexSchema', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.indexSchema))
      for iter68 in self.indexSchema:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.projections is not None:
      oprot.writeFieldBegin('projections', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.projections))
      for iter69 in self.projections:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.consistencyMode is not None:
      oprot.writeFieldBegin('consistencyMode', TType.I32, 3)
      oprot.writeI32(self.consistencyMode)
      oprot.writeFieldEnd()
    if self.unique is not None:
      oprot.writeFieldBegin('unique', TType.BOOL, 4)
      oprot.writeBool(self.unique)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexSchema)
    value = (value * 31) ^ hash(self.projections)
    value = (value * 31) ^ hash(self.consistencyMode)
    value = (value * 31) ^ hash(self.unique)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EntityGroupSpec(object):
  """
  EntityGroup定义

  Attributes:
   - attributes: 属性有序列表
   - enableHash: 是否对属性进行哈希分布:
  开启后表中记录按照(hash(attribute value), attribute value)大小顺序分布
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'attributes', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'enableHash', None, True, ), # 2
  )

  def __init__(self, attributes=None, enableHash=thrift_spec[2][4],):
    self.attributes = attributes
    self.enableHash = enableHash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = KeySpec()
            _elem75.read(iprot)
            self.attributes.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.enableHash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntityGroupSpec')
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.attributes))
      for iter76 in self.attributes:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enableHash is not None:
      oprot.writeFieldBegin('enableHash', TType.BOOL, 2)
      oprot.writeBool(self.enableHash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.enableHash)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GlobalSecondaryIndexSpec(object):
  """
  全局二级索引定义

  Attributes:
   - indexEntityGroup: 索引表的实体组键
  可用于对索引表进行hash
   - indexPrimaryKey: 索引表的主键
   - projections: 投影的属性，全局二级索引不能读取非投影属性
   - consistencyLevel: 索引数据一致性级别
   - unique: 是否为唯一索引
   - throughput: 索引表的吞吐量配额
   - slaveThroughput: 索引表的备集群的吞吐量配额
   - exceededThroughput: 索引表的最大超发吞吐量配额
   - exceededSlaveThroughput: 索引表的备集群的最大超发吞吐量配额
   - preSplits: 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'indexEntityGroup', (EntityGroupSpec, EntityGroupSpec.thrift_spec), None, ), # 1
    (2, TType.LIST, 'indexPrimaryKey', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'projections', (TType.STRING,None), None, ), # 3
    (4, TType.I32, 'consistencyLevel', None,     0, ), # 4
    (5, TType.BOOL, 'unique', None, False, ), # 5
    (6, TType.STRUCT, 'throughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'slaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'exceededThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'exceededSlaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 9
    (10, TType.I32, 'preSplits', None, 1, ), # 10
  )

  def __init__(self, indexEntityGroup=None, indexPrimaryKey=None, projections=None, consistencyLevel=thrift_spec[4][4], unique=thrift_spec[5][4], throughput=None, slaveThroughput=None, exceededThroughput=None, exceededSlaveThroughput=None, preSplits=thrift_spec[10][4],):
    self.indexEntityGroup = indexEntityGroup
    self.indexPrimaryKey = indexPrimaryKey
    self.projections = projections
    self.consistencyLevel = consistencyLevel
    self.unique = unique
    self.throughput = throughput
    self.slaveThroughput = slaveThroughput
    self.exceededThroughput = exceededThroughput
    self.exceededSlaveThroughput = exceededSlaveThroughput
    self.preSplits = preSplits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.indexEntityGroup = EntityGroupSpec()
          self.indexEntityGroup.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.indexPrimaryKey = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = KeySpec()
            _elem82.read(iprot)
            self.indexPrimaryKey.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.projections = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readString();
            self.projections.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.consistencyLevel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.unique = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.throughput = ProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.slaveThroughput = ProvisionThroughput()
          self.slaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.exceededThroughput = ProvisionThroughput()
          self.exceededThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.exceededSlaveThroughput = ProvisionThroughput()
          self.exceededSlaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.preSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GlobalSecondaryIndexSpec')
    if self.indexEntityGroup is not None:
      oprot.writeFieldBegin('indexEntityGroup', TType.STRUCT, 1)
      self.indexEntityGroup.write(oprot)
      oprot.writeFieldEnd()
    if self.indexPrimaryKey is not None:
      oprot.writeFieldBegin('indexPrimaryKey', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.indexPrimaryKey))
      for iter89 in self.indexPrimaryKey:
        iter89.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.projections is not None:
      oprot.writeFieldBegin('projections', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.projections))
      for iter90 in self.projections:
        oprot.writeString(iter90)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.consistencyLevel is not None:
      oprot.writeFieldBegin('consistencyLevel', TType.I32, 4)
      oprot.writeI32(self.consistencyLevel)
      oprot.writeFieldEnd()
    if self.unique is not None:
      oprot.writeFieldBegin('unique', TType.BOOL, 5)
      oprot.writeBool(self.unique)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 6)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.slaveThroughput is not None:
      oprot.writeFieldBegin('slaveThroughput', TType.STRUCT, 7)
      self.slaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.exceededThroughput is not None:
      oprot.writeFieldBegin('exceededThroughput', TType.STRUCT, 8)
      self.exceededThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.exceededSlaveThroughput is not None:
      oprot.writeFieldBegin('exceededSlaveThroughput', TType.STRUCT, 9)
      self.exceededSlaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.preSplits is not None:
      oprot.writeFieldBegin('preSplits', TType.I32, 10)
      oprot.writeI32(self.preSplits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexEntityGroup)
    value = (value * 31) ^ hash(self.indexPrimaryKey)
    value = (value * 31) ^ hash(self.projections)
    value = (value * 31) ^ hash(self.consistencyLevel)
    value = (value * 31) ^ hash(self.unique)
    value = (value * 31) ^ hash(self.throughput)
    value = (value * 31) ^ hash(self.slaveThroughput)
    value = (value * 31) ^ hash(self.exceededThroughput)
    value = (value * 31) ^ hash(self.exceededSlaveThroughput)
    value = (value * 31) ^ hash(self.preSplits)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamSpec(object):
  """
  stream specification

  Attributes:
   - enableStream: stream is enabled or not
   - viewType: view type
   - attributes: attribute list
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enableStream', None, None, ), # 1
    (2, TType.I32, 'viewType', None, None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, enableStream=None, viewType=None, attributes=None,):
    self.enableStream = enableStream
    self.viewType = viewType
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enableStream = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.viewType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readString();
            self.attributes.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamSpec')
    if self.enableStream is not None:
      oprot.writeFieldBegin('enableStream', TType.BOOL, 1)
      oprot.writeBool(self.enableStream)
      oprot.writeFieldEnd()
    if self.viewType is not None:
      oprot.writeFieldBegin('viewType', TType.I32, 2)
      oprot.writeI32(self.viewType)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter97 in self.attributes:
        oprot.writeString(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.enableStream)
    value = (value * 31) ^ hash(self.viewType)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PointInTimeRecovery(object):
  """
  point-in-time recovery


  Attributes:
   - enablePointInTimeRecovery: PITR is enabled or not;
   - topicName: topic name, should be stream-enabled and topic ttl >= pitr ttl;
   - ttl: PITR ttl, include checkpoints and snapshots;
   - snapshotPeriod: snapshot period;
   - createdTimestamp: created timestamp, output value;
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enablePointInTimeRecovery', None, None, ), # 1
    (2, TType.STRING, 'topicName', None, None, ), # 2
    (3, TType.I64, 'ttl', None, None, ), # 3
    (4, TType.I64, 'snapshotPeriod', None, None, ), # 4
    (5, TType.I64, 'createdTimestamp', None, None, ), # 5
  )

  def __init__(self, enablePointInTimeRecovery=None, topicName=None, ttl=None, snapshotPeriod=None, createdTimestamp=None,):
    self.enablePointInTimeRecovery = enablePointInTimeRecovery
    self.topicName = topicName
    self.ttl = ttl
    self.snapshotPeriod = snapshotPeriod
    self.createdTimestamp = createdTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enablePointInTimeRecovery = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.topicName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ttl = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.snapshotPeriod = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.createdTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PointInTimeRecovery')
    if self.enablePointInTimeRecovery is not None:
      oprot.writeFieldBegin('enablePointInTimeRecovery', TType.BOOL, 1)
      oprot.writeBool(self.enablePointInTimeRecovery)
      oprot.writeFieldEnd()
    if self.topicName is not None:
      oprot.writeFieldBegin('topicName', TType.STRING, 2)
      oprot.writeString(self.topicName)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I64, 3)
      oprot.writeI64(self.ttl)
      oprot.writeFieldEnd()
    if self.snapshotPeriod is not None:
      oprot.writeFieldBegin('snapshotPeriod', TType.I64, 4)
      oprot.writeI64(self.snapshotPeriod)
      oprot.writeFieldEnd()
    if self.createdTimestamp is not None:
      oprot.writeFieldBegin('createdTimestamp', TType.I64, 5)
      oprot.writeI64(self.createdTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.enablePointInTimeRecovery)
    value = (value * 31) ^ hash(self.topicName)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.snapshotPeriod)
    value = (value * 31) ^ hash(self.createdTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSchema(object):
  """
  表Schema设置

  Attributes:
   - version: Schema版本号，仅作为输出，作为输入不需要设置
   - entityGroup: Entity group定义, 不设置表示不开启Entity Group支持。
  开启后自动支持应用用户表空间隔离(需配合相应权限设置),
  即每个应用用户将看到独立的表空间
   - primaryIndex: 主键定义
   - secondaryIndexes: 二级索引定义
   - attributes: 属性定义
   - ttl: 记录存活时间，单位为秒。-1表示不会自动删除
   - preSplits: 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
   - streams: stream定义，TopicName => StreamSpec
   - globalSecondaryIndexes: 全局二级索引定义
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'entityGroup', (EntityGroupSpec, EntityGroupSpec.thrift_spec), None, ), # 2
    (3, TType.LIST, 'primaryIndex', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'secondaryIndexes', (TType.STRING,None,TType.STRUCT,(LocalSecondaryIndexSpec, LocalSecondaryIndexSpec.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'attributes', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'ttl', None, -1, ), # 6
    (7, TType.I32, 'preSplits', None, 1, ), # 7
    (8, TType.MAP, 'streams', (TType.STRING,None,TType.STRUCT,(StreamSpec, StreamSpec.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'globalSecondaryIndexes', (TType.STRING,None,TType.STRUCT,(GlobalSecondaryIndexSpec, GlobalSecondaryIndexSpec.thrift_spec)), None, ), # 9
  )

  def __init__(self, version=None, entityGroup=None, primaryIndex=None, secondaryIndexes=None, attributes=None, ttl=thrift_spec[6][4], preSplits=thrift_spec[7][4], streams=None, globalSecondaryIndexes=None,):
    self.version = version
    self.entityGroup = entityGroup
    self.primaryIndex = primaryIndex
    self.secondaryIndexes = secondaryIndexes
    self.attributes = attributes
    self.ttl = ttl
    self.preSplits = preSplits
    self.streams = streams
    self.globalSecondaryIndexes = globalSecondaryIndexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityGroup = EntityGroupSpec()
          self.entityGroup.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.primaryIndex = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = KeySpec()
            _elem103.read(iprot)
            self.primaryIndex.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.secondaryIndexes = {}
          (_ktype105, _vtype106, _size104 ) = iprot.readMapBegin()
          for _i108 in xrange(_size104):
            _key109 = iprot.readString();
            _val110 = LocalSecondaryIndexSpec()
            _val110.read(iprot)
            self.secondaryIndexes[_key109] = _val110
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype112, _vtype113, _size111 ) = iprot.readMapBegin()
          for _i115 in xrange(_size111):
            _key116 = iprot.readString();
            _val117 = iprot.readI32();
            self.attributes[_key116] = _val117
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.preSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.streams = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin()
          for _i122 in xrange(_size118):
            _key123 = iprot.readString();
            _val124 = StreamSpec()
            _val124.read(iprot)
            self.streams[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.globalSecondaryIndexes = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin()
          for _i129 in xrange(_size125):
            _key130 = iprot.readString();
            _val131 = GlobalSecondaryIndexSpec()
            _val131.read(iprot)
            self.globalSecondaryIndexes[_key130] = _val131
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSchema')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.entityGroup is not None:
      oprot.writeFieldBegin('entityGroup', TType.STRUCT, 2)
      self.entityGroup.write(oprot)
      oprot.writeFieldEnd()
    if self.primaryIndex is not None:
      oprot.writeFieldBegin('primaryIndex', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryIndex))
      for iter132 in self.primaryIndex:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.secondaryIndexes is not None:
      oprot.writeFieldBegin('secondaryIndexes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.secondaryIndexes))
      for kiter133,viter134 in self.secondaryIndexes.items():
        oprot.writeString(kiter133)
        viter134.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.attributes))
      for kiter135,viter136 in self.attributes.items():
        oprot.writeString(kiter135)
        oprot.writeI32(viter136)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I32, 6)
      oprot.writeI32(self.ttl)
      oprot.writeFieldEnd()
    if self.preSplits is not None:
      oprot.writeFieldBegin('preSplits', TType.I32, 7)
      oprot.writeI32(self.preSplits)
      oprot.writeFieldEnd()
    if self.streams is not None:
      oprot.writeFieldBegin('streams', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.streams))
      for kiter137,viter138 in self.streams.items():
        oprot.writeString(kiter137)
        viter138.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.globalSecondaryIndexes is not None:
      oprot.writeFieldBegin('globalSecondaryIndexes', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.globalSecondaryIndexes))
      for kiter139,viter140 in self.globalSecondaryIndexes.items():
        oprot.writeString(kiter139)
        viter140.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.entityGroup)
    value = (value * 31) ^ hash(self.primaryIndex)
    value = (value * 31) ^ hash(self.secondaryIndexes)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.preSplits)
    value = (value * 31) ^ hash(self.streams)
    value = (value * 31) ^ hash(self.globalSecondaryIndexes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMetadata(object):
  """
  表元信息

  Attributes:
   - tableId: 表ID
  仅作为输出值，作为输入时无需指定
   - developerId: 所有者的开发者ID，
  对于CreateTable/AlterTable，值不设置时，默认为当前登录用户。
   - appAcl: 权限控制设置
   - quota: @Deprecated 空间配额
   - throughput: 吞吐量配额
   - description: 表备注信息
   - stream: stream设置，deprecated
   - enableSysSnapshot: 是否支持系统定期做snapshot， 默认为true
   - exceededThroughput: 主集群最大超发的读写配额，即系统空闲时可能达到的最大吞吐，设置比throughput大即允许超发
   - slaveThroughput: 预设备集群读写配额
   - exceededSlaveThroughput: 备集群最大超发的读写配额，即系统空闲时可能达到最大的吞吐，设置比slaveThroughput大即允许超发
   - acl: 融合云权限模型的acl
   - spaceId: 表所在的命名空间
   - enableEgAcl: entityGroup acl 开关
   - pitr: Point-In-Time recovery
   - softDeletedTtl: 软删除时，已删表保留的时间，单位为秒
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableId', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.MAP, 'appAcl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 3
    (4, TType.STRUCT, 'quota', (TableQuota, TableQuota.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'throughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.STRUCT, 'stream', (StreamSpec, StreamSpec.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'enableSysSnapshot', None, None, ), # 8
    (9, TType.STRUCT, 'exceededThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'slaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'exceededSlaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 11
    (12, TType.MAP, 'acl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 12
    (13, TType.STRING, 'spaceId', None, None, ), # 13
    (14, TType.BOOL, 'enableEgAcl', None, False, ), # 14
    (15, TType.STRUCT, 'pitr', (PointInTimeRecovery, PointInTimeRecovery.thrift_spec), None, ), # 15
    (16, TType.I64, 'softDeletedTtl', None, None, ), # 16
  )

  def __init__(self, tableId=None, developerId=None, appAcl=None, quota=None, throughput=None, description=None, stream=None, enableSysSnapshot=None, exceededThroughput=None, slaveThroughput=None, exceededSlaveThroughput=None, acl=None, spaceId=None, enableEgAcl=thrift_spec[14][4], pitr=None, softDeletedTtl=None,):
    self.tableId = tableId
    self.developerId = developerId
    self.appAcl = appAcl
    self.quota = quota
    self.throughput = throughput
    self.description = description
    self.stream = stream
    self.enableSysSnapshot = enableSysSnapshot
    self.exceededThroughput = exceededThroughput
    self.slaveThroughput = slaveThroughput
    self.exceededSlaveThroughput = exceededSlaveThroughput
    self.acl = acl
    self.spaceId = spaceId
    self.enableEgAcl = enableEgAcl
    self.pitr = pitr
    self.softDeletedTtl = softDeletedTtl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.appAcl = {}
          (_ktype142, _vtype143, _size141 ) = iprot.readMapBegin()
          for _i145 in xrange(_size141):
            _key146 = iprot.readString();
            _val147 = []
            (_etype151, _size148) = iprot.readListBegin()
            for _i152 in xrange(_size148):
              _elem153 = iprot.readI32();
              _val147.append(_elem153)
            iprot.readListEnd()
            self.appAcl[_key146] = _val147
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.quota = TableQuota()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.throughput = ProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.stream = StreamSpec()
          self.stream.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enableSysSnapshot = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.exceededThroughput = ProvisionThroughput()
          self.exceededThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.slaveThroughput = ProvisionThroughput()
          self.slaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.exceededSlaveThroughput = ProvisionThroughput()
          self.exceededSlaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.acl = {}
          (_ktype155, _vtype156, _size154 ) = iprot.readMapBegin()
          for _i158 in xrange(_size154):
            _key159 = iprot.readString();
            _val160 = []
            (_etype164, _size161) = iprot.readListBegin()
            for _i165 in xrange(_size161):
              _elem166 = iprot.readI32();
              _val160.append(_elem166)
            iprot.readListEnd()
            self.acl[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.spaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.enableEgAcl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.pitr = PointInTimeRecovery()
          self.pitr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.softDeletedTtl = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMetadata')
    if self.tableId is not None:
      oprot.writeFieldBegin('tableId', TType.STRING, 1)
      oprot.writeString(self.tableId)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.appAcl is not None:
      oprot.writeFieldBegin('appAcl', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.appAcl))
      for kiter167,viter168 in self.appAcl.items():
        oprot.writeString(kiter167)
        oprot.writeListBegin(TType.I32, len(viter168))
        for iter169 in viter168:
          oprot.writeI32(iter169)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 4)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 5)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.stream is not None:
      oprot.writeFieldBegin('stream', TType.STRUCT, 7)
      self.stream.write(oprot)
      oprot.writeFieldEnd()
    if self.enableSysSnapshot is not None:
      oprot.writeFieldBegin('enableSysSnapshot', TType.BOOL, 8)
      oprot.writeBool(self.enableSysSnapshot)
      oprot.writeFieldEnd()
    if self.exceededThroughput is not None:
      oprot.writeFieldBegin('exceededThroughput', TType.STRUCT, 9)
      self.exceededThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.slaveThroughput is not None:
      oprot.writeFieldBegin('slaveThroughput', TType.STRUCT, 10)
      self.slaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.exceededSlaveThroughput is not None:
      oprot.writeFieldBegin('exceededSlaveThroughput', TType.STRUCT, 11)
      self.exceededSlaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.acl))
      for kiter170,viter171 in self.acl.items():
        oprot.writeString(kiter170)
        oprot.writeListBegin(TType.I32, len(viter171))
        for iter172 in viter171:
          oprot.writeI32(iter172)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.spaceId is not None:
      oprot.writeFieldBegin('spaceId', TType.STRING, 13)
      oprot.writeString(self.spaceId)
      oprot.writeFieldEnd()
    if self.enableEgAcl is not None:
      oprot.writeFieldBegin('enableEgAcl', TType.BOOL, 14)
      oprot.writeBool(self.enableEgAcl)
      oprot.writeFieldEnd()
    if self.pitr is not None:
      oprot.writeFieldBegin('pitr', TType.STRUCT, 15)
      self.pitr.write(oprot)
      oprot.writeFieldEnd()
    if self.softDeletedTtl is not None:
      oprot.writeFieldBegin('softDeletedTtl', TType.I64, 16)
      oprot.writeI64(self.softDeletedTtl)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableId)
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.appAcl)
    value = (value * 31) ^ hash(self.quota)
    value = (value * 31) ^ hash(self.throughput)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.stream)
    value = (value * 31) ^ hash(self.enableSysSnapshot)
    value = (value * 31) ^ hash(self.exceededThroughput)
    value = (value * 31) ^ hash(self.slaveThroughput)
    value = (value * 31) ^ hash(self.exceededSlaveThroughput)
    value = (value * 31) ^ hash(self.acl)
    value = (value * 31) ^ hash(self.spaceId)
    value = (value * 31) ^ hash(self.enableEgAcl)
    value = (value * 31) ^ hash(self.pitr)
    value = (value * 31) ^ hash(self.softDeletedTtl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSpec(object):
  """
  表配置信息

  Attributes:
   - schema
   - metadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (TableSchema, TableSchema.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (TableMetadata, TableMetadata.thrift_spec), None, ), # 2
  )

  def __init__(self, schema=None, metadata=None,):
    self.schema = schema
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = TableSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = TableMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSpec')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.metadata)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatus(object):
  """
  表状态信息

  Attributes:
   - state: 表状态
   - createTime: 创建时间
   - alterTime: 最近修改时间
   - statTime: 最近统计时间
   - size: 占用空间统计，单位为字节
   - rowCount: 行数统计，非即时精确值
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
    (2, TType.I64, 'createTime', None, None, ), # 2
    (3, TType.I64, 'alterTime', None, None, ), # 3
    (4, TType.I64, 'statTime', None, None, ), # 4
    (5, TType.I64, 'size', None, None, ), # 5
    (6, TType.I64, 'rowCount', None, None, ), # 6
  )

  def __init__(self, state=None, createTime=None, alterTime=None, statTime=None, size=None, rowCount=None,):
    self.state = state
    self.createTime = createTime
    self.alterTime = alterTime
    self.statTime = statTime
    self.size = size
    self.rowCount = rowCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.alterTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.statTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.rowCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatus')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I64, 2)
      oprot.writeI64(self.createTime)
      oprot.writeFieldEnd()
    if self.alterTime is not None:
      oprot.writeFieldBegin('alterTime', TType.I64, 3)
      oprot.writeI64(self.alterTime)
      oprot.writeFieldEnd()
    if self.statTime is not None:
      oprot.writeFieldBegin('statTime', TType.I64, 4)
      oprot.writeI64(self.statTime)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 5)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.rowCount is not None:
      oprot.writeFieldBegin('rowCount', TType.I64, 6)
      oprot.writeI64(self.rowCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.alterTime)
    value = (value * 31) ^ hash(self.statTime)
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.rowCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableInfo(object):
  """
  表信息

  Attributes:
   - name
   - spec
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'spec', (TableSpec, TableSpec.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'status', (TableStatus, TableStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, spec=None, status=None,):
    self.name = name
    self.spec = spec
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TableSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = TableStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SimpleCondition(object):
  """
  简单条件，用于checkAndPut/Delete操作，判定逻辑为: value operator field

  Attributes:
   - operator
   - field
   - value
   - rowExist
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'operator', None, None, ), # 1
    (2, TType.STRING, 'field', None, None, ), # 2
    (3, TType.STRUCT, 'value', (Datum, Datum.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'rowExist', None, None, ), # 4
  )

  def __init__(self, operator=None, field=None, value=None, rowExist=None,):
    self.operator = operator
    self.field = field
    self.value = value
    self.rowExist = rowExist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.operator = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.value = Datum()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.rowExist = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SimpleCondition')
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 1)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 2)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 3)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.rowExist is not None:
      oprot.writeFieldBegin('rowExist', TType.BOOL, 4)
      oprot.writeBool(self.rowExist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.rowExist)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSplit(object):
  """
  表分片信息，包括起始和结束的row key

  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype174, _vtype175, _size173 ) = iprot.readMapBegin()
          for _i177 in xrange(_size173):
            _key178 = iprot.readString();
            _val179 = Datum()
            _val179.read(iprot)
            self.startKey[_key178] = _val179
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype181, _vtype182, _size180 ) = iprot.readMapBegin()
          for _i184 in xrange(_size180):
            _key185 = iprot.readString();
            _val186 = Datum()
            _val186.read(iprot)
            self.stopKey[_key185] = _val186
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSplit')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter187,viter188 in self.startKey.items():
        oprot.writeString(kiter187)
        viter188.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter189,viter190 in self.stopKey.items():
        oprot.writeString(kiter189)
        viter190.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRequest(object):
  """
  Attributes:
   - tableName
   - keys: 记录主键，必须包含主键所有的属性
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, attributes=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype192, _vtype193, _size191 ) = iprot.readMapBegin()
          for _i195 in xrange(_size191):
            _key196 = iprot.readString();
            _val197 = Datum()
            _val197.read(iprot)
            self.keys[_key196] = _val197
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype201, _size198) = iprot.readListBegin()
          for _i202 in xrange(_size198):
            _elem203 = iprot.readString();
            self.attributes.append(_elem203)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter204,viter205 in self.keys.items():
        oprot.writeString(kiter204)
        viter205.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter206 in self.attributes:
        oprot.writeString(iter206)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetResult(object):
  """
  Attributes:
   - item
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'item', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, item=None,):
    self.item = item

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.item = {}
          (_ktype208, _vtype209, _size207 ) = iprot.readMapBegin()
          for _i211 in xrange(_size207):
            _key212 = iprot.readString();
            _val213 = Datum()
            _val213.read(iprot)
            self.item[_key212] = _val213
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetResult')
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.item))
      for kiter214,viter215 in self.item.items():
        oprot.writeString(kiter214)
        viter215.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.item)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutRequest(object):
  """
  Attributes:
   - tableName
   - record: 待写入的记录
   - condition: 仅当满足指定条件时执行写入操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 3
  )

  def __init__(self, tableName=None, record=None, condition=None,):
    self.tableName = tableName
    self.record = record
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype217, _vtype218, _size216 ) = iprot.readMapBegin()
          for _i220 in xrange(_size216):
            _key221 = iprot.readString();
            _val222 = Datum()
            _val222.read(iprot)
            self.record[_key221] = _val222
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter223,viter224 in self.record.items():
        oprot.writeString(kiter223)
        viter224.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 3)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutResult(object):
  """
  Attributes:
   - success: 写入操作是否被执行(是否满足设置的条件)
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待自增的记录主键
   - amounts: 需要进行自增操作的属性，必须为整形，且不能为索引属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, amounts=None,):
    self.tableName = tableName
    self.keys = keys
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype226, _vtype227, _size225 ) = iprot.readMapBegin()
          for _i229 in xrange(_size225):
            _key230 = iprot.readString();
            _val231 = Datum()
            _val231.read(iprot)
            self.keys[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin()
          for _i236 in xrange(_size232):
            _key237 = iprot.readString();
            _val238 = Datum()
            _val238.read(iprot)
            self.amounts[_key237] = _val238
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter239,viter240 in self.keys.items():
        oprot.writeString(kiter239)
        viter240.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter241,viter242 in self.amounts.items():
        oprot.writeString(kiter241)
        viter242.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementResult(object):
  """
  Attributes:
   - amounts
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, amounts=None,):
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype244, _vtype245, _size243 ) = iprot.readMapBegin()
          for _i247 in xrange(_size243):
            _key248 = iprot.readString();
            _val249 = Datum()
            _val249.read(iprot)
            self.amounts[_key248] = _val249
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementResult')
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter250,viter251 in self.amounts.items():
        oprot.writeString(kiter250)
        viter251.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待删除的记录主键
   - attributes: 待删除的属性列表，不指定表示删除整条记录。
  当删除部分属性时，即使所有属性均已被删除，记录仍存在，删除整条记录需要显式删除
   - condition: 仅当满足指定条件时执行删除操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 4
  )

  def __init__(self, tableName=None, keys=None, attributes=None, condition=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype253, _vtype254, _size252 ) = iprot.readMapBegin()
          for _i256 in xrange(_size252):
            _key257 = iprot.readString();
            _val258 = Datum()
            _val258.read(iprot)
            self.keys[_key257] = _val258
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype262, _size259) = iprot.readListBegin()
          for _i263 in xrange(_size259):
            _elem264 = iprot.readString();
            self.attributes.append(_elem264)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter265,viter266 in self.keys.items():
        oprot.writeString(kiter265)
        viter266.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter267 in self.attributes:
        oprot.writeString(iter267)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 4)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveResult(object):
  """
  Attributes:
   - success: 删除操作是否被执行（是否满足设置的条件）
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request(object):
  """
  Attributes:
   - getRequest: 随机读操作
   - putRequest: 写入操作，不支持条件
   - incrementRequest: 自增操作
   - removeRequest: 删除操作，不支持条件
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (GetRequest, GetRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putRequest', (PutRequest, PutRequest.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementRequest', (IncrementRequest, IncrementRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeRequest', (RemoveRequest, RemoveRequest.thrift_spec), None, ), # 4
  )

  def __init__(self, getRequest=None, putRequest=None, incrementRequest=None, removeRequest=None,):
    self.getRequest = getRequest
    self.putRequest = putRequest
    self.incrementRequest = incrementRequest
    self.removeRequest = removeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = GetRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putRequest = PutRequest()
          self.putRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementRequest = IncrementRequest()
          self.incrementRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeRequest = RemoveRequest()
          self.removeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.putRequest is not None:
      oprot.writeFieldBegin('putRequest', TType.STRUCT, 2)
      self.putRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementRequest is not None:
      oprot.writeFieldBegin('incrementRequest', TType.STRUCT, 3)
      self.incrementRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.removeRequest is not None:
      oprot.writeFieldBegin('removeRequest', TType.STRUCT, 4)
      self.removeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getRequest)
    value = (value * 31) ^ hash(self.putRequest)
    value = (value * 31) ^ hash(self.incrementRequest)
    value = (value * 31) ^ hash(self.removeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanAction(object):
  """
  Attributes:
   - action: scan时连带操作
   - request: 实际操作，不需要指定key
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanAction')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanRequest(object):
  """
  范围查询，支持主键和二级索引查询，
  查询范围为闭开区间[startKey, endKey)，
  当指定索引时，查询范围的entity group必须唯一指定

  Attributes:
   - tableName
   - indexName: 不指定表示通过主键进行查询
   - startKey: 查询范围开始，包含startKey，
  如果startKey不是完整键，而是部分key的前缀，则实际查询的startKey为{startKey, 最小可能的后缀}补全形式
   - stopKey: 查询范围结束，不包含stopKey，
  如果stopKey不是完整键，而是部分key的前缀，则实际查询的stopKey为{stopKey, 最大可能的后缀}补全形式
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
   - condition: 类SQL WHERE语句的查询条件。
  注意：与SQL不同，此条件仅作为过滤条件，不影响具体查询计划(index, startKey, endKey)，
  进行范围查询时需要显示设置index和startKey以及endKey。每个扫描的记录均计入读配额，
  即使不满足查询条件。尽量避免使用条件过滤，尤其是当过滤掉的记录占一半以上时，强烈不建议使用。
   - limit: 返回记录的最大数目，返回数目可能小于此值(如超出表的读配额时)
   - reverse: 是否进行逆序扫描，进行逆序扫描时startKey应大于endKey，
  注意：逆序查询效率较低，谨慎使用，建议设置对应的Key为逆序存储
   - inGlobalOrder: 是否全局有序扫描
   - cacheResult: 是否将结果放入cache，对于类似MapReduce的大批量扫描的应用应该关闭此选项
   - lookAheadStep: 查找属性在seek之前进行顺序skip的次数。非必要情况，请不要设置
   - action: scan时的连带操作，包括COUNT，DELETE和UPDATE
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'indexName', None, None, ), # 2
    (3, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'condition', None, None, ), # 6
    (7, TType.I32, 'limit', None, 10, ), # 7
    (8, TType.BOOL, 'reverse', None, False, ), # 8
    (9, TType.BOOL, 'inGlobalOrder', None, True, ), # 9
    (10, TType.BOOL, 'cacheResult', None, True, ), # 10
    (11, TType.I32, 'lookAheadStep', None, 0, ), # 11
    (12, TType.STRUCT, 'action', (ScanAction, ScanAction.thrift_spec), None, ), # 12
  )

  def __init__(self, tableName=None, indexName=None, startKey=None, stopKey=None, attributes=None, condition=None, limit=thrift_spec[7][4], reverse=thrift_spec[8][4], inGlobalOrder=thrift_spec[9][4], cacheResult=thrift_spec[10][4], lookAheadStep=thrift_spec[11][4], action=None,):
    self.tableName = tableName
    self.indexName = indexName
    self.startKey = startKey
    self.stopKey = stopKey
    self.attributes = attributes
    self.condition = condition
    self.limit = limit
    self.reverse = reverse
    self.inGlobalOrder = inGlobalOrder
    self.cacheResult = cacheResult
    self.lookAheadStep = lookAheadStep
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype269, _vtype270, _size268 ) = iprot.readMapBegin()
          for _i272 in xrange(_size268):
            _key273 = iprot.readString();
            _val274 = Datum()
            _val274.read(iprot)
            self.startKey[_key273] = _val274
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype276, _vtype277, _size275 ) = iprot.readMapBegin()
          for _i279 in xrange(_size275):
            _key280 = iprot.readString();
            _val281 = Datum()
            _val281.read(iprot)
            self.stopKey[_key280] = _val281
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype285, _size282) = iprot.readListBegin()
          for _i286 in xrange(_size282):
            _elem287 = iprot.readString();
            self.attributes.append(_elem287)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.reverse = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.inGlobalOrder = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.cacheResult = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.lookAheadStep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.action = ScanAction()
          self.action.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 2)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter288,viter289 in self.startKey.items():
        oprot.writeString(kiter288)
        viter289.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter290,viter291 in self.stopKey.items():
        oprot.writeString(kiter290)
        viter291.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter292 in self.attributes:
        oprot.writeString(iter292)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRING, 6)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.reverse is not None:
      oprot.writeFieldBegin('reverse', TType.BOOL, 8)
      oprot.writeBool(self.reverse)
      oprot.writeFieldEnd()
    if self.inGlobalOrder is not None:
      oprot.writeFieldBegin('inGlobalOrder', TType.BOOL, 9)
      oprot.writeBool(self.inGlobalOrder)
      oprot.writeFieldEnd()
    if self.cacheResult is not None:
      oprot.writeFieldBegin('cacheResult', TType.BOOL, 10)
      oprot.writeBool(self.cacheResult)
      oprot.writeFieldEnd()
    if self.lookAheadStep is not None:
      oprot.writeFieldBegin('lookAheadStep', TType.I32, 11)
      oprot.writeI32(self.lookAheadStep)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRUCT, 12)
      self.action.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.indexName)
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.reverse)
    value = (value * 31) ^ hash(self.inGlobalOrder)
    value = (value * 31) ^ hash(self.cacheResult)
    value = (value * 31) ^ hash(self.lookAheadStep)
    value = (value * 31) ^ hash(self.action)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanResult(object):
  """
  Attributes:
   - nextStartKey: 下一个需要扫描的记录主键，NULL表示达到制定的结束位置
   - records: 扫描的记录
   - throttled: 是否超过表的qps quota
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nextStartKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'records', (TType.MAP,(TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec))), None, ), # 2
    (3, TType.BOOL, 'throttled', None, None, ), # 3
  )

  def __init__(self, nextStartKey=None, records=None, throttled=None,):
    self.nextStartKey = nextStartKey
    self.records = records
    self.throttled = throttled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nextStartKey = {}
          (_ktype294, _vtype295, _size293 ) = iprot.readMapBegin()
          for _i297 in xrange(_size293):
            _key298 = iprot.readString();
            _val299 = Datum()
            _val299.read(iprot)
            self.nextStartKey[_key298] = _val299
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype303, _size300) = iprot.readListBegin()
          for _i304 in xrange(_size300):
            _elem305 = {}
            (_ktype307, _vtype308, _size306 ) = iprot.readMapBegin()
            for _i310 in xrange(_size306):
              _key311 = iprot.readString();
              _val312 = Datum()
              _val312.read(iprot)
              _elem305[_key311] = _val312
            iprot.readMapEnd()
            self.records.append(_elem305)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanResult')
    if self.nextStartKey is not None:
      oprot.writeFieldBegin('nextStartKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nextStartKey))
      for kiter313,viter314 in self.nextStartKey.items():
        oprot.writeString(kiter313)
        viter314.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.records))
      for iter315 in self.records:
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(iter315))
        for kiter316,viter317 in iter315.items():
          oprot.writeString(kiter316)
          viter317.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 3)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nextStartKey)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.throttled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequestItem(object):
  """
  Attributes:
   - action
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequestItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Result(object):
  """
  Attributes:
   - getResult
   - putResult
   - incrementResult
   - removeResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getResult', (GetResult, GetResult.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putResult', (PutResult, PutResult.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementResult', (IncrementResult, IncrementResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeResult', (RemoveResult, RemoveResult.thrift_spec), None, ), # 4
  )

  def __init__(self, getResult=None, putResult=None, incrementResult=None, removeResult=None,):
    self.getResult = getResult
    self.putResult = putResult
    self.incrementResult = incrementResult
    self.removeResult = removeResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getResult = GetResult()
          self.getResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putResult = PutResult()
          self.putResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementResult = IncrementResult()
          self.incrementResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeResult = RemoveResult()
          self.removeResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.getResult is not None:
      oprot.writeFieldBegin('getResult', TType.STRUCT, 1)
      self.getResult.write(oprot)
      oprot.writeFieldEnd()
    if self.putResult is not None:
      oprot.writeFieldBegin('putResult', TType.STRUCT, 2)
      self.putResult.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementResult is not None:
      oprot.writeFieldBegin('incrementResult', TType.STRUCT, 3)
      self.incrementResult.write(oprot)
      oprot.writeFieldEnd()
    if self.removeResult is not None:
      oprot.writeFieldBegin('removeResult', TType.STRUCT, 4)
      self.removeResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getResult)
    value = (value * 31) ^ hash(self.putResult)
    value = (value * 31) ^ hash(self.incrementResult)
    value = (value * 31) ^ hash(self.removeResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResultItem(object):
  """
  Attributes:
   - action: 操作类型
   - success: 是否成功执行，即无异常
   - result: 操作结果，操作成功时被设置
   - serviceException: 操作时发生的异常，操作失败时被设置
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.BOOL, 'success', None, None, ), # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'serviceException', (sds.errors.ttypes.ServiceException, sds.errors.ttypes.ServiceException.thrift_spec), None, ), # 4
  )

  def __init__(self, action=None, success=None, result=None, serviceException=None,):
    self.action = action
    self.success = success
    self.result = result
    self.serviceException = serviceException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.serviceException = sds.errors.ttypes.ServiceException()
          self.serviceException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResultItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 2)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serviceException is not None:
      oprot.writeFieldBegin('serviceException', TType.STRUCT, 4)
      self.serviceException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.serviceException)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequest(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchRequestItem, BatchRequestItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype321, _size318) = iprot.readListBegin()
          for _i322 in xrange(_size318):
            _elem323 = BatchRequestItem()
            _elem323.read(iprot)
            self.items.append(_elem323)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequest')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter324 in self.items:
        iter324.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResult(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchResultItem, BatchResultItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype328, _size325) = iprot.readListBegin()
          for _i329 in xrange(_size325):
            _elem330 = BatchResultItem()
            _elem330.read(iprot)
            self.items.append(_elem330)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResult')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter331 in self.items:
        iter331.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InternalMutationLogEntry(object):
  """
  internal mutation log entry


  Attributes:
   - record: row key and items
   - type: mutation type
   - rowDeleted: is row deleted or not
   - amounts: increment amounts
   - topicName: mq topic name
   - streamType: stream type
   - partitionNum: topic partition number
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.BOOL, 'rowDeleted', None, None, ), # 3
    (4, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'topicName', None, None, ), # 5
    (6, TType.I32, 'streamType', None, None, ), # 6
    (7, TType.I32, 'partitionNum', None, None, ), # 7
  )

  def __init__(self, record=None, type=None, rowDeleted=None, amounts=None, topicName=None, streamType=None, partitionNum=None,):
    self.record = record
    self.type = type
    self.rowDeleted = rowDeleted
    self.amounts = amounts
    self.topicName = topicName
    self.streamType = streamType
    self.partitionNum = partitionNum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype333, _vtype334, _size332 ) = iprot.readMapBegin()
          for _i336 in xrange(_size332):
            _key337 = iprot.readString();
            _val338 = Datum()
            _val338.read(iprot)
            self.record[_key337] = _val338
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype340, _vtype341, _size339 ) = iprot.readMapBegin()
          for _i343 in xrange(_size339):
            _key344 = iprot.readString();
            _val345 = Datum()
            _val345.read(iprot)
            self.amounts[_key344] = _val345
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.topicName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.streamType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.partitionNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InternalMutationLogEntry')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter346,viter347 in self.record.items():
        oprot.writeString(kiter346)
        viter347.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 3)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter348,viter349 in self.amounts.items():
        oprot.writeString(kiter348)
        viter349.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.topicName is not None:
      oprot.writeFieldBegin('topicName', TType.STRING, 5)
      oprot.writeString(self.topicName)
      oprot.writeFieldEnd()
    if self.streamType is not None:
      oprot.writeFieldBegin('streamType', TType.I32, 6)
      oprot.writeI32(self.streamType)
      oprot.writeFieldEnd()
    if self.partitionNum is not None:
      oprot.writeFieldBegin('partitionNum', TType.I32, 7)
      oprot.writeI32(self.partitionNum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.rowDeleted)
    value = (value * 31) ^ hash(self.amounts)
    value = (value * 31) ^ hash(self.topicName)
    value = (value * 31) ^ hash(self.streamType)
    value = (value * 31) ^ hash(self.partitionNum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InternalMutationLogGroup(object):
  """
  internal mutation log entries, use in TraceRegionServer coprocessor


  Attributes:
   - developerId: developerId
   - originalTableName: sds tableName
   - entries: mutation long entries
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'developerId', None, None, ), # 1
    (2, TType.STRING, 'originalTableName', None, None, ), # 2
    (3, TType.LIST, 'entries', (TType.STRUCT,(InternalMutationLogEntry, InternalMutationLogEntry.thrift_spec)), None, ), # 3
  )

  def __init__(self, developerId=None, originalTableName=None, entries=None,):
    self.developerId = developerId
    self.originalTableName = originalTableName
    self.entries = entries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.originalTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.entries = []
          (_etype353, _size350) = iprot.readListBegin()
          for _i354 in xrange(_size350):
            _elem355 = InternalMutationLogEntry()
            _elem355.read(iprot)
            self.entries.append(_elem355)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InternalMutationLogGroup')
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 1)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.originalTableName is not None:
      oprot.writeFieldBegin('originalTableName', TType.STRING, 2)
      oprot.writeString(self.originalTableName)
      oprot.writeFieldEnd()
    if self.entries is not None:
      oprot.writeFieldBegin('entries', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.entries))
      for iter356 in self.entries:
        iter356.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.originalTableName)
    value = (value * 31) ^ hash(self.entries)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MutationLogEntry(object):
  """
  mutation log entry,


  Attributes:
   - record: row key and items
   - type: mutation type
   - rowDeleted: is row deleted or not
   - timestamp: mutation timestamp
   - amounts: increment amounts
   - tableName: sds tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.BOOL, 'rowDeleted', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 5
    (6, TType.STRING, 'tableName', None, None, ), # 6
  )

  def __init__(self, record=None, type=None, rowDeleted=None, timestamp=None, amounts=None, tableName=None,):
    self.record = record
    self.type = type
    self.rowDeleted = rowDeleted
    self.timestamp = timestamp
    self.amounts = amounts
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype358, _vtype359, _size357 ) = iprot.readMapBegin()
          for _i361 in xrange(_size357):
            _key362 = iprot.readString();
            _val363 = Datum()
            _val363.read(iprot)
            self.record[_key362] = _val363
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype365, _vtype366, _size364 ) = iprot.readMapBegin()
          for _i368 in xrange(_size364):
            _key369 = iprot.readString();
            _val370 = Datum()
            _val370.read(iprot)
            self.amounts[_key369] = _val370
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MutationLogEntry')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter371,viter372 in self.record.items():
        oprot.writeString(kiter371)
        viter372.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 3)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter373,viter374 in self.amounts.items():
        oprot.writeString(kiter373)
        viter374.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 6)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.rowDeleted)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.amounts)
    value = (value * 31) ^ hash(self.tableName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordImage(object):
  """
  record image


  Attributes:
   - record: row key and attributes
   - rowDeleted: is row deleted or not
   - timestamp: record mutated timestamp
   - tableName: sds tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'rowDeleted', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
  )

  def __init__(self, record=None, rowDeleted=None, timestamp=None, tableName=None,):
    self.record = record
    self.rowDeleted = rowDeleted
    self.timestamp = timestamp
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype376, _vtype377, _size375 ) = iprot.readMapBegin()
          for _i379 in xrange(_size375):
            _key380 = iprot.readString();
            _val381 = Datum()
            _val381.read(iprot)
            self.record[_key380] = _val381
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordImage')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter382,viter383 in self.record.items():
        oprot.writeString(kiter382)
        viter383.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 2)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.rowDeleted)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.tableName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeysOnlyEntry(object):
  """
  Attributes:
   - record: row key
   - timestamp: record mutated timestamp
   - tableName: sds tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
  )

  def __init__(self, record=None, timestamp=None, tableName=None,):
    self.record = record
    self.timestamp = timestamp
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype385, _vtype386, _size384 ) = iprot.readMapBegin()
          for _i388 in xrange(_size384):
            _key389 = iprot.readString();
            _val390 = Datum()
            _val390.read(iprot)
            self.record[_key389] = _val390
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeysOnlyEntry')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter391,viter392 in self.record.items():
        oprot.writeString(kiter391)
        viter392.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.tableName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
