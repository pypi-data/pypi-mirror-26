.. _tutorial:

===============
Getting started
===============

This tutorial is for bioinformaticians. It will help you install the ReSDK
and explain some basic commands. We will connect to a Resolwe server,
do some basic queries, and align raw reads to a genome.

Installation
============

Installing is easy, just make sure you have Python_ and pip_ installed
on your computer. Run this command in the terminal (CMD on Windows)::

  pip install resdk

.. _Python: https://www.python.org/downloads/
.. _pip: https://pip.pypa.io/en/stable/installing/

.. warning::

   If you use macOS, be aware that the version of `Python shipped with the
   system doesn't support TLSv1.2`_, which is required for connecting to
   any Resolwe server (and probably others). To solve the issue,
   install the latest version of Python 2.7 or Python 3 `via official
   installer from Python.org`_ or `with Homebrew`_.

.. _`Python shipped with the system doesn't support TLSv1.2`:
    http://pyfound.blogspot.si/2017/01/time-to-upgrade-your-python-tls-v12.html
.. _`via official installer from Python.org`:
    https://www.python.org/downloads/mac-osx/
.. _`with Homebrew`:
    http://docs.python-guide.org/en/latest/starting/install/osx/

Registration
============

Examples in documentation require access to a public Resolwe server.
You can use a public Resolwe server `Genialis Platform`_ that is
configured for the examples in tutorial. Some parts of the
documentation will work for registered users only. Please
`create an account`_ on Genialis Platform before you continue,
and remember your username and password.

.. _`Genialis Platform`: https://app.genialis.com
.. _`create an account`: https://app.genialis.com/rna-seq/user/create_account

Query data
==========

Start Python interpreter by typing ``python`` into the command line. You'll recognize the
interpreter by '>>>'. Now we can connect to the Resolwe server:

.. literalinclude:: files/example_index.py
   :lines: 1-7

.. note::

	We suggest you use the ``resdk.start_logging()`` command when
	connecting to the server in interactive session. It allows you
	to see different types of messages (`e.g.,` warnings and errors)
	when executing commands.

Before we start querying data on the server we should get familiar with what a data
object is. Everything that is uploaded or created (via processes) on a server is a
data object. The data object is a complete record of the processing. It stores the
inputs (files, arguments, parameters...), the process (the algorithm) and the outputs
(files, images, numbers...). Let's retrieve all data objects from the server:

.. code-block:: python

	res.data.all()

This is all the data on the server you have permissions for. As a new
user you can only see a small subset of all data objects. We can see the
data objects are referenced by *id*, *slug* and *name*.

.. note::

	``name`` is an arbitrary, **non unique name** of an object.

	``slug`` is an **unique name** of the object. The slug is automatically created from the
	``name`` but can also be edited by the user. Only lowercase letters, numbers
	and dashes are allowed (will not accept white space or uppercase letters).

	``id`` is autogenerated **unique identifier** of an object. IDs are integers.

Let's say we now want to find some genomes. We don't always know the *id*, *slug* or *name*
by heart, but we can use `filters`_ to find them. We will query for all
genome data objects:

.. _filters: http://resdk.readthedocs.io/en/latest/ref.html#resdk.ResolweQuery

.. code-block:: python

	res.data.filter(type='data:genome')

There are several data objects that fall through our filter. We can filter the
data even more, this time trying to find a genome in a FASTA format:

.. code-block:: python

	res.data.filter(type='data:genome:fasta')

There are still multiple data objects so we add another filter. This time adding
a creation date field to the query:

.. code-block:: python

	res.data.filter(type='data:genome:fasta', created__date='2017-06-06')

We have now narrowed our search to one genome. We want to do something with
this genome. We will `get`_ it and store a reference to it for later:

.. _get: http://resdk.readthedocs.io/en/latest/ref.html#resdk.ResolweQuery.get

.. code-block:: python

	# Get data object by id
	genome = res.data.get(1488)

or

.. code-block:: python

	# Get data object by slug
	genome = res.data.get('genome-mm10-chr19')

We have seen how to use filters to find and get what we want. Let us now
query and get a paired-end FASTQ data object:

.. code-block:: python

	# All paired-end fastq objects
	res.data.filter(type='data:reads:fastq:paired')

	# Add date filter
	res.data.filter(type='data:reads:fastq:paired', created__date='2017-06-06')

	# Get the last data object by id
	reads = res.data.get(1487)

We now have ``genome`` and ``reads`` data objects. We can learn about an object by
calling certain object attributes. We can find out who created the object:

.. code-block:: python

	reads.contributor


and inspect the list of files it contains:

.. code-block:: python

	reads.output

All data object attributes are listed `here`_.

.. _here: http://resdk.readthedocs.io/en/latest/ref.html#resdk.resources.Data

Run alignment
=============

A common analysis in bioinformatics is to align sequencing reads to a reference
genome. This is done by running a certain *process*. A process uses an algorithm or
a sequence of algorithms to turn given inputs into outputs. Here we will use a HISAT2
alignment process, but many more processes are available (see the `Process catalog`_).
This process automatically creates a BAM alignment file, BAI index, a file with
unmapped reads, and a stats file.

.. _Process catalog: http://resolwe-bio.readthedocs.io/en/latest/catalog.html

So let us now run HISAT2 on our reads and using our genome:

.. code-block:: python

	bam = reads.run_hisat2(genome)

The processing may take some time. Note that we have stored the reference to the alignment
object into a ``bam`` variable. We can check the `status`_ of the process and if the
processing has finished:

.. _status: http://resdk.readthedocs.io/en/latest/ref.html#resdk.resources.Data.status

.. code-block:: python

	# Get the latest meta data from the server
	bam.update()

	# Print the status
	bam.status

Status ``OK`` indicates that processing has finished successfully. If the status is not ``OK``
yet, run the ``bam.update()`` and ``bam.status`` commands again in few minutes. We can
inspect our newly created data object:

.. code-block:: python

	bam

As any other data object it has its own *id*, *slug* and *name*. We can explore
the process inputs and outputs:

.. code-block:: python

	# Process inputs
	bam.input

	# Process outputs
	bam.output

Download outputs to your local disk:

.. code-block:: python

	bam.download()

We have come to the end of Getting started. You now know some basic ReSDK concepts and
commands. But so far we have only scratched the surface. By continuing with the Tutorials,
you will get familiar with more advanced concepts and options and will soon be able
to perform powerful analysis of your data.
